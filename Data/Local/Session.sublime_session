{
	"folder_history":
	[
		"/D/workspace/4U/sy.src/sy.hmi/rttask",
		"/D/workspace/4U/sy.src/sy.hmi/lcd",
		"/D/workspace/Distribution_Network",
		"/E/apprentice/eclipse/algs4",
		"/D/workspace/BSPU21",
		"/D/workspace/4U"
	],
	"last_version": 3126,
	"last_window_id": 44,
	"log_indexing": false,
	"settings":
	{
		"new_window_height": 648.0,
		"new_window_settings":
		{
			"auto_complete":
			{
				"selected_items":
				[
					[
						"__",
						"__LINE__\t(sysntp.c)"
					],
					[
						"con",
						"convert2D"
					],
					[
						"res",
						"result"
					],
					[
						"re",
						"resvd"
					],
					[
						"r",
						"rmsg"
					],
					[
						"mc",
						"mcpu_addr"
					],
					[
						"gdd",
						"gdd_type"
					],
					[
						"p_s",
						"p_setting_value"
					],
					[
						"dat",
						"data_type"
					],
					[
						"w",
						"w_artc"
					],
					[
						"t",
						"tmp_tsk"
					],
					[
						"de",
						"define"
					],
					[
						"row",
						"row_num"
					],
					[
						"L",
						"LCD_MAX_FACTOR"
					],
					[
						"f",
						"f_accoeff"
					],
					[
						"n",
						"nfactor"
					],
					[
						"b",
						"buffer"
					],
					[
						"sec",
						"sec_factor"
					],
					[
						"IN",
						"INT8"
					],
					[
						"B",
						"BUFFER_SIZE"
					],
					[
						"fac",
						"factorOut"
					],
					[
						"f_f",
						"f_factor"
					],
					[
						"f_",
						"f_coeff"
					],
					[
						"sour",
						"source1"
					],
					[
						"print",
						"printf\tprintf …"
					],
					[
						"buf",
						"buffer"
					],
					[
						"fa",
						"factorOut"
					],
					[
						"p",
						"printf\tprintf …"
					],
					[
						"l",
						"lcd_temp"
					],
					[
						"LCD_MAX",
						"LCD_MAX_FACTOR_ADJUST"
					],
					[
						"factor",
						"factor_temp"
					],
					[
						"cr",
						"crc_ini"
					],
					[
						"crc",
						"crc_ini"
					],
					[
						"INT",
						"INT32"
					],
					[
						"c",
						"crc"
					],
					[
						"a",
						"accoeff"
					],
					[
						"S",
						"Section_Name"
					],
					[
						"se",
						"section"
					],
					[
						"s",
						"section"
					],
					[
						"section",
						"Section_Name"
					],
					[
						"K",
						"Key_Name"
					],
					[
						"st",
						"strcat"
					],
					[
						"d",
						"d_ptr"
					],
					[
						"max",
						"max_all"
					],
					[
						"arr",
						"arr1"
					],
					[
						"h",
						"head"
					],
					[
						"str",
						"strlen"
					],
					[
						"va",
						"value"
					],
					[
						"all",
						"allocp"
					],
					[
						"al",
						"allocbuf"
					],
					[
						"ma",
						"maxlines"
					],
					[
						"M",
						"MAXLINE"
					],
					[
						"bu",
						"buf_sign"
					],
					[
						"get",
						"getchar"
					],
					[
						"m",
						"MAXLINE　100"
					],
					[
						"mask",
						"mask_x"
					],
					[
						"i",
						"inc\t#include \"…\""
					],
					[
						"inc",
						"include"
					],
					[
						"he",
						"hexa"
					],
					[
						"u",
						"uni"
					],
					[
						"H",
						"HEAD1"
					],
					[
						"in",
						"inspace"
					],
					[
						"ele",
						"ele_src"
					],
					[
						"ds",
						"dst"
					],
					[
						"res_b",
						"res_b"
					],
					[
						"D",
						"Distance_a"
					]
				]
			},
			"build_system_choices":
			[
			],
			"build_varint": "",
			"command_palette":
			{
				"height": 242.0,
				"last_filter": "Cscope: ",
				"selected_items":
				[
					[
						"Cscope: ",
						"Cscope: Look up functions calling this function"
					],
					[
						"syntax",
						"Set Syntax: C"
					],
					[
						"syntax:c",
						"Set Syntax: C"
					],
					[
						"install",
						"Package Control: Install Package"
					],
					[
						"Package Control: ",
						"Package Control: Install Package"
					],
					[
						"set syntax:c",
						"Set Syntax: C"
					],
					[
						"ins",
						"Package Control: Install Package"
					],
					[
						"x",
						"Set Syntax: XML"
					],
					[
						"sy",
						"Set Syntax: C"
					],
					[
						"make",
						"Set Syntax: Makefile"
					],
					[
						"syntax:make",
						"Set Syntax: Makefile"
					],
					[
						"Package Control: install ",
						"Package Control: Install Package"
					],
					[
						"Package Control: install c",
						"Package Control: Install Package"
					],
					[
						":w",
						":w - Save"
					]
				],
				"width": 528.0
			},
			"console":
			{
				"height": 146.0,
				"history":
				[
					"install package",
					"import urllib.request,os; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ','%20')).read())"
				]
			},
			"distraction_free":
			{
				"menu_visible": true,
				"show_minimap": false,
				"show_open_files": false,
				"show_tabs": false,
				"side_bar_visible": false,
				"status_bar_visible": false
			},
			"file_history":
			[
				"/D/workspace/U21/sy.src/vxworks.mk",
				"/D/workspace/U21/sy.src/sy.sys/system/src/salve.c",
				"/D/workspace/U21/sy.src/sy.sys/system/src/can.c",
				"/D/workspace/U21/sy.src/sy.hmi/rttask/inc/wavep.h",
				"/D/workspace/U21/sy.src/sy.hmi/rttask/src/comtrade.c",
				"/D/workspace/U21/sy.src/sy.hmi/rttask/inc/rtcommon.h",
				"/D/workspace/U21/sy.release/sy.sys/sy6101L/inc/setting.h",
				"/D/workspace/Distribution_Network/sy.src/sy.slave/Makefile",
				"/D/workspace/Distribution_Network/sy.src/sy.slave/sy2101/Makefile",
				"/C/Users/wangzhichao/Desktop/wave/wave/comtrade/16949_20150701_100132_004.hdr",
				"/D/workspace/Distribution_Network/sy.src/vxworks.mk",
				"/D/workspace/Distribution_Network/sy.src/Makefile",
				"/D/SVN/Distribution_Network/sy.src/sy.slave/sy2102/app/src/appinit.c",
				"/D/5.Real/Zeitest/Distribution/config.xml",
				"/D/5.Real/Zeitest/Distribution/platform/config.xml",
				"/D/workspace/U21/sy.src/sy.sys/sy6201/Makefile",
				"/D/workspace/U21/sy.src/sy.sys/sy6101/app/Makefile",
				"/D/workspace/U21/sy.src/sy.hmi/Makefile",
				"/D/workspace/U21/sy.src/sy.hmi/rttask/src/event.c",
				"/D/workspace/U21/sy.src/sy.sys/system/src/ivt.c",
				"/D/workspace/U21/sy.release/sy.sys/system/inc/ivt.h",
				"/D/workspace/U21/sy.src/sy.hmi/rttask/src/sram.c",
				"/D/workspace/U21/sy.src/sy.hmi/lcd/inc/lcd.h",
				"/D/workspace/U21/sy.src/sy.hmi/rttask/inc/event.h",
				"/D/workspace/U21/sy.src/sy.hmi/rttask/inc/eventp.h",
				"/D/workspace/U21/sy.release/sy.sys/sy6101L/inc/dbg.h",
				"/E/apprentice/eclipse/algs4/src/algs4/PercolationStats.java",
				"/E/apprentice/eclipse/algs4/src/algs4/Percolation.java",
				"/D/workspace/U21/sy.src/sy.hmi/lcd/src/lcdbase.c",
				"/D/workspace/U21/sy.src/sy.hmi/lcd/src/lcdhome.c",
				"/D/workspace/U21/sy.src/sy.hmi/lcd/src/lcd.c",
				"/D/workspace/U21/sy.release/sy.sys/sy6101L/inc/dev.h",
				"/E/apprentice/eclipse/algs4/data/percolation/sedgewick60.txt",
				"/E/apprentice/eclipse/algs4/src/algs4/PercolationStat.java",
				"/E/Ryan/Sublime Text Build 3083/Data/Packages/User/Default (Windows).sublime-keymap",
				"/E/Ryan/Sublime Text Build 3083/Data/Packages/CTags/Default.sublime-mousemap",
				"/E/Ryan/Sublime Text Build 3083/Data/Packages/CTags/Default.sublime-keymap",
				"/D/workspace/U21/sy.src/sy.sys/sy6201/sys/src/sy6201.c",
				"/D/workspace/U21/sy.src/sy.hmi/rttask/src/rttask.c",
				"/D/workspace/U21/sy.src/sy.hmi/rttask/inc/sram.h",
				"/D/workspace/U21/sy.src/sy.hmi/rttask/inc/sramp.h",
				"/D/workspace/U21/sy.src/sy.hmi/rttask/inc/rtconst.h",
				"/D/workspace/U21/sy.src/sy.sys/sy6201/sys/Makefile",
				"/D/workspace/U21/sy.src/sy.sys/sy6201/app/Makefile",
				"/D/workspace/U21/sy.src/sy.sys/sy6101/sys/Makefile",
				"/D/workspace/U21/sy.src/sy.sys/sy6101/modules/Makefile",
				"/D/workspace/U21/sy.src/sy.sys/system/Makefile",
				"/C/Users/wangzhichao/Desktop/startup.txt",
				"/D/workspace/U21/sy.src/sy.sys/system/src/canovt.c",
				"/E/apprentice/eclipse/algs4/data/percolation/PercolationVisualizer.java",
				"/D/workspace/U21/sy.release/sy.sys/sy6101L/inc/master.h",
				"/D/workspace/U21/sy.release/sy.sys/system/inc/msgtype.h",
				"/D/workspace/U21/sy.src/sy.sys/system/src/parameter.c",
				"/D/workspace/U21/sy.release/sy.sys/system.16.04.06/inc/syslave.h",
				"/D/workspace/U21/sy.src/sy.sys/system/inc/ivt.h",
				"/D/workspace/U21/sy.src/sy.sys/system/src/locivt.c",
				"/D/workspace/U21/sy.release/sy.sys/system.16.04.06/inc/ivt.h",
				"/D/workspace/U21/sy.release/sy.sys/sy6101L/inc/sy6101.h",
				"/D/workspace/U21/sy.src/sy.sys/system/src/regsignal.c",
				"/D/workspace/U21/sy.src/sy.sys/sy6101/modules/src/hashtbl.c",
				"/D/workspace/U21/sy.release/sy.sys/sy6101L/inc/hashtbl.h",
				"/D/workspace/U21/sy.src/sy.sys/system/src/ovt.c",
				"/D/workspace/U21/sy.src/sy.sys/system/src/hbus.c",
				"/D/workspace/U21/sy.src/sy.sys/system/src/hbusovt.c",
				"/D/workspace/U21/sy.src/sy.hmi/iec103/inc/iec103asdu.h",
				"/D/workspace/U21/sy.src/sy.hmi/iec103/src/nr103link.c",
				"/D/workspace/U21/sy.release/sy.sys/system.16.04.06/inc/can.h",
				"/D/workspace/U21/sy.src/sy.hmi/iec103/src/nr103asdu.c",
				"/D/workspace/U21/sy.src/sy.hmi/lcd/inc/lcdaccoeff.h",
				"/D/workspace/U21/sy.src/sy.hmi/lcd/src/lcddebug.c",
				"/D/workspace/U21/sy.src/sy.hmi/lcd/inc/lcddebug.h",
				"/D/workspace/U21/sy.src/sy.hmi/iec103/src/iec103link.c",
				"/D/workspace/U21/sy.src/sy.sys/Makefile",
				"/D/workspace/U21/sy.src/sy.hmi/iec103/src/iec103asdu.c",
				"/E/Ryan/algs4partI-009/dataAndSource/algs4-data/tobe.txt",
				"/D/workspace/U21/sy.src/sy.sys/system/makeall",
				"/D/workspace/U21/sy.src/Makefile",
				"/D/workspace/U21/sy.src/sy.hmi/iec103/src/init103gs.c",
				"/D/workspace/U21/sy.src/sy.hmi/iec103/src/iec103.c",
				"/D/5.Real/Zeitest/UDC302_4t1/死区说明.txt",
				"/D/workspace/U21/sy.src/sy.hmi/lcd/src/lcdstatus.c",
				"/D/workspace/U21/sy.src/sy.hmi/lcd/src/lcdservice.c",
				"/D/workspace/U21/sy.src/sy.hmi/lcd/src/lcdpage.c",
				"/D/workspace/U21/sy.src/sy.hmi/iec103/src/testshow.c",
				"/D/workspace/U21/sy.src/sy.hmi/iec103/src/queue.c",
				"/D/workspace/U21/sy.src/sy.hmi/lcd/src/lcdversion.c",
				"/D/workspace/U21/sy.src/sy.hmi/lcd/src/lcdgrid.c",
				"/D/workspace/U21/sy.src/sy.hmi/lcd/inc/lcdbase.h",
				"/D/workspace/U21/sy.src/sy.hmi/lcd/src/lcdtest.c",
				"/D/workspace/U21/sy.src/sy.hmi/lcd/src/lcdorder.c",
				"/D/workspace/U21/sy.src/sy.hmi/lcd/src/lcddiagram.c",
				"/D/workspace/U21/sy.src/sy.hmi/lcd/src/lcddraw.c",
				"/D/workspace/U21/sy.src/sy.hmi/iec103/inc/iec103.h",
				"/D/workspace/U21/sy.src/sy.hmi/rttask/inc/sysntp.h",
				"/D/workspace/U21/sy.src/sy.hmi/rttask/src/sysntp.c",
				"/D/workspace/U21/sy.src/sy.sys/sy6101/modules/src/fd.c",
				"/D/3.platform resource/邱大为版本程序/6in1版本/ccc/system的inc/inc/bcomponent.h",
				"/D/workspace/U21/sy.release/sy.sys/system/inc/component.h",
				"/D/workspace/U21/sy.release/sy.sys/system.16.04.06/inc/component.h",
				"/E/apprentice/Computer/C programming/solutions/CPP/ch7/11.c",
				"/D/workspace/U21/sy.src/sy.hmi/lcd/src/lcdctrl.c",
				"/D/workspace/U21/sy.src/sy.hmi/lcd/src/lcdjoin.cpp",
				"/D/5.Real/Zeitest/UDC_DYSFZ/extr_UDC_DYSFZ/10/config.xml",
				"/E/apprentice/Computer/C programming/solutions/CPP/ch7/8.c",
				"/E/apprentice/Computer/C programming/solutions/CPP/ch7/9.c",
				"/D/workspace/U21/sy.src/sy.hmi/print/src/print.c",
				"/D/workspace/U21/sy.src/sy.hmi/print/src/printfunc.c",
				"/D/workspace/U21/sy.src/sy.hmi/print/inc/print.h",
				"/E/Ryan/Sublime Text Build 3083/Data/Packages/User/CscopeSublime.sublime-settings",
				"/E/Ryan/Sublime Text Build 3083/Data/Packages/User/CTags.sublime-settings",
				"/D/workspace/U21/sy.src/sy.hmi/print/src/printinit.c",
				"/E/VM/CentOS7.vmx",
				"/D/workspace/U21/sy.release/sy.sys/common.gnu/inc/linux/types.h",
				"/D/workspace/U21/sy.src/sy.hmi/ld.lst",
				"/D/workspace/U21_6IN1/sy.src/sy.hmi/rttask/src/sysntp.c",
				"/D/workspace/U21_6IN1/sy.src/sy.hmi/rttask/inc/sysntp.h",
				"/D/workspace/U21_6IN1/sy.release/sy.sys/common.sharc21469/inc/sharc21469.h",
				"/D/workspace/U21_4t1/sy.src/sy.hmi/rttask/src/sysntp.c",
				"/D/workspace/U21_6IN1/sy.release/sy.sys/common.gnu/inc/base/string.c",
				"/D/workspace/U21_4t1/sy.release/sy.sys/sy6101L/inc/sy6101.h",
				"/D/3.platform resource/邱大为版本程序/6in1版本/六统一hmi代码/print/makefile",
				"/D/workspace/U21_6IN1/sy.src/sy.hmi/rttask/src/event.c",
				"/D/workspace/U21_6IN1/sy.src/sy.hmi/rttask/src/comtrade.c",
				"/D/workspace/U21_6IN1/sy.src/sy.hmi/rttask/src/wave.c",
				"/D/workspace/U21_6IN1/sy.src/sy.hmi/rttask/src/rtcommon.c",
				"/D/workspace/U21_6IN1/sy.src/sy.hmi/rttask/src/.tags",
				"/E/Ryan/Sublime Text Build 3083/Data/Packages/Cscope/CscopeSublime.sublime-settings",
				"/E/Ryan/Sublime Text Build 3083/Data/Packages/CTags/CTags.sublime-settings"
			],
			"find":
			{
				"height": 36.0
			},
			"find_in_files":
			{
				"height": 90.0,
				"where_history":
				[
					"D:\\workspace\\U21\\sy.src\\sy.hmi\\iec103",
					"D:\\workspace\\U21\\sy.src\\sy.hmi\\lcd",
					"D:\\workspace\\U21\\sy.src",
					"D:\\workspace\\U21",
					"D:\\workspace\\U21\\sy.src\\sy.hmi\\lcd",
					"D:\\workspace\\U21\\sy.src\\sy.hmi\\iec103",
					"D:\\workspace\\U21\\sy.src\\sy.hmi\\lcd",
					"D:\\workspace\\U21\\sy.src\\sy.hmi\\iec103\\inc",
					"D:\\workspace\\U21\\sy.src\\sy.hmi\\iec103",
					"D:\\workspace\\U21\\sy.src\\sy.hmi\\iec103\\inc",
					"D:\\workspace\\U21\\sy.src\\sy.hmi\\iec103",
					"D:\\workspace\\U21\\sy.src\\sy.hmi\\lcd\\src",
					"D:\\workspace\\U21",
					"D:\\workspace\\U21\\sy.src\\sy.hmi\\lcd",
					"D:\\workspace\\U21\\sy.src",
					"D:\\workspace\\U21\\sy.src\\sy.hmi\\rttask",
					"D:\\workspace\\U21",
					"D:\\workspace\\U21\\sy.src\\sy.hmi\\rttask",
					"D:\\3.platform resource\\5试验fpk\\UDC-311AG_Ver1.19",
					"D:\\3.platform resource\\赵小伟版本程序\\u21 工程\\iec103",
					"D:\\workspace,D:\\3.platform resource\\赵小伟版本程序,D:\\3.platform resource\\邱大为版本程序",
					"D:\\workspace,D:\\3.platform resource\\赵小伟版本程序",
					"D:\\workspace\\U21_6IN1",
					"C:\\Users\\wangzhichao\\Desktop\\代码改动",
					"D:\\workspace\\U21_6IN1"
				]
			},
			"find_state":
			{
				"case_sensitive": false,
				"find_history":
				[
					"Error",
					"error",
					"B05",
					"p_ctrl",
					"p_event_cfg",
					"event",
					"Event",
					"event",
					"p_ctrl",
					"rttask_time_count",
					"eventTask",
					"current=hbus_bit_ivt[0]",
					"numberOfOpenSites",
					" +",
					"with_index_que",
					"para_size",
					"max_index",
					"p_cfg_start",
					"p_cfg",
					"msg sub_type is 9",
					"msg sub_type is 8",
					"msg sub_type is 13",
					"current_ivt",
					"cur_loc_addr",
					"this_type",
					"msg sub_type is 6",
					"D1 B9",
					"CF DF",
					"C2 B7",
					"B5 CD",
					"msg sub_type is 5",
					"msg sub_type is 4",
					"msg sub_type is 3",
					"sg sub_type is 3",
					"msg sub_type is 3",
					"sntpTask",
					"initSntpTimer",
					"send_sntp_timer_count",
					"wait_sntp_reply_timer_count",
					"wait_sntp_invalid_count",
					"send_sntp_timer_period",
					"send_sntp_timer_count",
					"para_addr",
					"middle_packet",
					"para_index",
					"index",
					"len",
					"para_part_len",
					"ref_para",
					"ordCanMsgProc",
					"msg",
					"m",
					"msg",
					"rmsg",
					"31",
					"32",
					"31",
					"49",
					"50",
					"g_lcd_draw_session",
					"accoef_crc_table",
					"result",
					"canMsgProc",
					"DataFields:",
					"printf(\"DataFields",
					"printf(\"title",
					"title:",
					"appNew",
					"put",
					"putSlave",
					"accoeff.ini",
					"offset",
					"p_103_data",
					"formGenDataElement",
					"p_tx_buf",
					"formGenDataElement",
					"procAsdu221",
					"f_zdb",
					"i",
					"I",
					"i",
					"p_datafield",
					"kod",
					"CT",
					"lcdShowStatus",
					"9",
					"gdd_type",
					"GDD",
					"gdd",
					"hmi.xml",
					"++",
					"recieve_counter",
					"++",
					"+",
					"++",
					"freeTcp",
					"recv_sntp_counter",
					"hmi.xml",
					"discount",
					"printWaveNof",
					"printWave",
					"sec",
					"cp->wait_sntp_invalid_period",
					" p_reply->referenceIdentifie",
					"_NTP_DEBUG",
					"_NTP_DBG",
					"initSoeProcess(cp)",
					"ret = initSoeProcess(cp)",
					"clear",
					"clearAllRealEventByMoniblk",
					"rttask.run_cnt type",
					"B10.rttask.run_cnt",
					"SNTP_DBG",
					"sntpTeask",
					"sntpTask",
					"INT8 buf",
					"0xff",
					"INF",
					"FUN",
					"printf(\"this is line %d  in file %s\\n\", __LINE__,  __FILE__)",
					"send",
					"&(brd->cpu.app_ver)",
					"EN_PROGRAM_VER",
					"&(brd->cpu.app_ver)",
					"EN_PROGRAM_VER,\nEN_PROGRAM_VER,\nEN_PROGRAM_VER,\nEN_PROGRAM_VER,\nEN_PROGRAM_VER,\nEN_PROGRAM_VER",
					"&(brd->cpu.app_ver)",
					"第1",
					"行：disable所指定的停止点，breakpoints为停止点号。如果什么都不指定，表示disable所有的停止点。简写命令是dis"
				],
				"highlight": true,
				"in_selection": false,
				"preserve_case": false,
				"regex": true,
				"replace_history":
				[
					"_NTP_DBF",
					"sntpTask",
					"LCD_PSD_DBG_MSG",
					"",
					"LCD_MAX_FACTOR_ADJUST",
					"crc_table_ini",
					"LCD_FILE_INI",
					"LCD_INI_BUFFER_SIZE",
					"LCD_INI_DEBUG",
					"INI_BUFFER_SIZE",
					"PRINTINFO",
					"crc32_calc_ini",
					"crc_table_ini",
					"BUFFER_SIZE",
					"printf",
					"U",
					"INT8",
					"INT32",
					"int",
					"unsigned int",
					"short",
					"char",
					"UINT",
					"INT8",
					"INT32",
					"UINT8",
					"INT8",
					"B7",
					"B6",
					"dec_ans",
					"",
					" ",
					",",
					" ",
					",",
					"",
					"swc_1_horgw1",
					"swc_2_horgw1",
					"swc_3_horgw1",
					"add",
					"set",
					" ",
					"",
					" ",
					"service",
					" "
				],
				"reverse": false,
				"show_context": true,
				"use_buffer2": true,
				"whole_word": false,
				"wrap": true
			},
			"incremental_find":
			{
				"height": 30.0
			},
			"input":
			{
				"height": 36.0
			},
			"menu_visible": true,
			"output.exec":
			{
				"height": 30.0
			},
			"output.find_results":
			{
				"height": 0.0
			},
			"pinned_build_system": "Packages/D/D.sublime-build",
			"replace":
			{
				"height": 66.0
			},
			"save_all_on_build": true,
			"select_file":
			{
				"height": 0.0,
				"last_filter": "",
				"selected_items":
				[
					[
						"",
						"sy.release\\sy.sys\\common.gnu\\inc\\cmd_confdefs.h"
					]
				],
				"width": 0.0
			},
			"select_project":
			{
				"height": 500.0,
				"last_filter": "",
				"selected_items":
				[
					[
						"",
						"D:\\workspace\\Distribution_Network\\distribution_network.sublime-project"
					]
				],
				"width": 380.0
			},
			"select_symbol":
			{
				"height": 392.0,
				"last_filter": "",
				"selected_items":
				[
				],
				"width": 520.0
			},
			"show_minimap": true,
			"show_open_files": false,
			"show_tabs": true,
			"side_bar_visible": true,
			"side_bar_width": 243.0,
			"status_bar_visible": true,
			"template_settings":
			{
			}
		},
		"new_window_width": 751.0
	},
	"windows":
	[
		{
			"auto_complete":
			{
				"selected_items":
				[
					[
						"__",
						"__LINE__"
					],
					[
						"in",
						"index"
					],
					[
						"st_",
						"st_val"
					],
					[
						"i",
						"item"
					],
					[
						"g",
						"g_event_que"
					],
					[
						"it",
						"item_size"
					],
					[
						"re",
						"read"
					],
					[
						"tmp",
						"tmp_read"
					],
					[
						"para",
						"para_num"
					],
					[
						"p",
						"p_ctrl"
					],
					[
						"pre",
						"pre_node"
					],
					[
						"ne",
						"needPrint"
					],
					[
						"INT",
						"INT8"
					],
					[
						"con",
						"convert2D"
					],
					[
						"res",
						"result"
					],
					[
						"r",
						"rmsg"
					],
					[
						"mc",
						"mcpu_addr"
					],
					[
						"gdd",
						"gdd_type"
					],
					[
						"p_s",
						"p_setting_value"
					],
					[
						"dat",
						"data_type"
					],
					[
						"w",
						"w_artc"
					],
					[
						"t",
						"tmp_tsk"
					],
					[
						"de",
						"define"
					],
					[
						"row",
						"row_num"
					],
					[
						"L",
						"LCD_MAX_FACTOR"
					],
					[
						"f",
						"f_accoeff"
					],
					[
						"n",
						"nfactor"
					],
					[
						"b",
						"buffer"
					],
					[
						"sec",
						"sec_factor"
					],
					[
						"IN",
						"INT8"
					],
					[
						"B",
						"BUFFER_SIZE"
					],
					[
						"fac",
						"factorOut"
					],
					[
						"f_f",
						"f_factor"
					],
					[
						"f_",
						"f_coeff"
					],
					[
						"sour",
						"source1"
					],
					[
						"print",
						"printf\tprintf …"
					],
					[
						"buf",
						"buffer"
					],
					[
						"fa",
						"factorOut"
					],
					[
						"l",
						"lcd_temp"
					],
					[
						"LCD_MAX",
						"LCD_MAX_FACTOR_ADJUST"
					],
					[
						"factor",
						"factor_temp"
					],
					[
						"cr",
						"crc_ini"
					],
					[
						"crc",
						"crc_ini"
					],
					[
						"c",
						"crc"
					],
					[
						"a",
						"accoeff"
					],
					[
						"S",
						"Section_Name"
					],
					[
						"se",
						"section"
					],
					[
						"s",
						"section"
					],
					[
						"section",
						"Section_Name"
					],
					[
						"K",
						"Key_Name"
					],
					[
						"st",
						"strcat"
					],
					[
						"d",
						"d_ptr"
					],
					[
						"max",
						"max_all"
					],
					[
						"arr",
						"arr1"
					],
					[
						"h",
						"head"
					],
					[
						"str",
						"strlen"
					],
					[
						"va",
						"value"
					],
					[
						"all",
						"allocp"
					],
					[
						"al",
						"allocbuf"
					],
					[
						"ma",
						"maxlines"
					],
					[
						"M",
						"MAXLINE"
					],
					[
						"bu",
						"buf_sign"
					],
					[
						"get",
						"getchar"
					],
					[
						"m",
						"MAXLINE　100"
					],
					[
						"mask",
						"mask_x"
					],
					[
						"inc",
						"include"
					],
					[
						"he",
						"hexa"
					],
					[
						"u",
						"uni"
					],
					[
						"H",
						"HEAD1"
					],
					[
						"ele",
						"ele_src"
					],
					[
						"ds",
						"dst"
					],
					[
						"res_b",
						"res_b"
					],
					[
						"D",
						"Distance_a"
					]
				]
			},
			"buffers":
			[
				{
					"file": "sy.src/sy.hmi/rttask/src/sysntp.c",
					"settings":
					{
						"buffer_size": 21682,
						"encoding": "UTF-8",
						"line_ending": "Windows"
					}
				},
				{
					"contents": "#include \"syslave.h\"\n#include \"dev.h\"\n\n#include \"hmicomm.h\"\n#include \"rtcommon.h\"\n#include \"eventp.h\"\n#include \"wavep.h\"\n#include \"led.h\"\n#include \"calc.h\"\n#include \"rttask.h\"\n\n/*私有的常量定义*/\n#define INCLUDE_EVENT_SEM\t\t/*事件队列使用互斥*/\n\nvoid clearRealEvent(EventType event_type, UINT32 client_no);\n\nLOCAL const INT8 *s_event_sram_name[] =\n{\n\t\"Trip\",\t\t\t\t/*动作事件*/\n\t\"Check\",\t\t\t/*自检事件*/\n\t\"Bi\",\t\t\t\t/*开关量变位*/\n\t\"Run\",\t\t\t\t/*运行记录*/\n\t\"ChChk_A\",\t\t\t/*通道自检*/\n\t\"ChChk_B\",\t\t\t/*通道自检*/\n\t\"ChChk_C\",\t\t\t/*通道自检*/\n\t\"ChChk_D\",\t\t\t/*通道自检*/\n\t\"ChSta_A\",\t\t\t/*通道统计*/\n\t\"ChSta_B\",\t\t\t/*通道统计*/\n\t\"ChSta_C\",\t\t\t/*通道统计*/\n\t\"ChSta_D\",\t\t\t/*通道统计*/\n\t\"Order\",\t\t\t/*控制命令记录*/\n\t\"Yx\"\t\t\t\t/*带时标的BI记录*/\n};\n\ntypedef enum\n{\n\tEN_EVENT_QUEUE_CONFIGURE_ERR,\n\tEN_EVENT_QUEUE_INIT_ERR,\n\tEN_EVENT_QUEUE_CREATE_SEMAPHORE_ERR,\n\tEN_EVENT_QUEUE_NUM_ERR,\n\tEN_EVENT_QUEUE_WRITE_INDEX_ERR,\n\tEN_EVENT_QUEUE_CLIENT_READ_INDEX_ERR,\n\tEN_EVENT_QUEUE_CLIENT_TMP_READ_INDEX_ERR,\n\tEN_EVENT_QUEUE_PARA_WRITE_INDEX_ERR,\n\tEN_EVENT_QUEUE_CHK_SRAM_ERR,\n\tEN_EVENT_NAME_IN_REF_TAB_ERR,\n\tEN_EVENT_GET_INDEX_CACHE_MEM_ERR,\n\tEN_EVENT_REF_TAB_PARA_INDEX_ERR,\n\tEN_EVENT_REF_TAB_PARA_NUM_ERR,\n\tEN_EVENT_REF_TAB_PARA_READY_INDEX_ERR,\n\tEN_EVENT_GET_PARA_READY_MEM_ERR,\n\tEN_EVENT_OPEN_SOE_READ_FD_ERR,\n\tEN_EVENT_SOE_KEY_REPEART,\n\tEN_EVENT_SOE_NOT_FIND_KEY,\n\tEN_EVENT_NUM_MUST_BE_EVEN_ERR\n} EVENT_UNIT_ERR_CODE;\n\nLOCAL const INT8 *s_error_msg[] =\n{\n\t\"%s event configure parameter err\\n\",\t\t\t\t\t\t\t/*0*/\n\t\"%s event queue initialize err\\n\",\t\t\t\t\t\t\t\t/*1*/\n\t\"%s event queue create semaphore err, errno=%x\\n\",\t\t\t\t/*2*/\n\t\"event queue num err,max=%d,now=%d\\n\",\t\t\t\t\t\t\t/*3*/\n\t\"event queue write index err,max=%d,now=%d,tmp=%d\\n\",\t\t\t/*4*/\n\t\"event queue client(%d) read index err,max=%d,now=%d\\n\",\t\t/*5*/\n\t\"event queue client(%d) temp read index err,max=%d,now=%d\\n\",\t/*6*/\n\t\"event queue para write index err,max=%d,now=%d\\n\",\t\t\t\t/*7*/\n\t\"%s event check sram err and initialize sram\\n\",\t\t\t\t/*8*/\n\t\"event name %s err in refer table:%s\\n\",\t\t\t\t\t\t/*9*/\n\t\"%s event get index que mem err\\n\",\t\t\t\t\t\t\t\t/*10*/\n\t\"the no:%d of refer table:%s para index(%d) err,max=%d\\n\",\t\t/*11*/\n\t\"the no:%d of refer table:%s para num(%d) err,max=%d\\n\",\t\t/*12*/\n\t\"the no:%d of refer table:%s para ready_index(%d) err,max=%d\\n\",/*13*/\n\t\"%s event get para ready mem err\\n\",\t\t\t\t\t\t\t/*14*/\n\t\"open soe read fd err,errno=%x\\n\",\t\t\t\t\t\t\t\t/*15*/\n\t\"soe(%s) key repeart,key=%x\\n\",\t\t\t\t\t\t\t\t\t/*16*/\n\t\"soe(%s) config err,not find key\\n\"\t\t\t\t\t\t\t\t/*17*/\n\t\"%s event num is not even\\n\"\t\t\t\t\t\t\t\t\t/*18*/\n};\n\ntypedef enum\n{\n\tEVENT_CLEAR_SRAM,\n\tEVENT_ITEM_INDEX_SRAM,\n\tEVENT_INDEX_QUE_IS_FULL\n} EVENT_LOG_CODE;\n\nLOCAL const INT8 *s_log_msg[] =\n{\n\t\"%s event clear sram\\n\",\t\t\t\t\t\t\t\t\t\t/*0*/\n\t\"%s event item index(%d) err\\n\",\t\t\t\t\t\t\t\t/*1*/\n\t\"%s event index queue is full and discard index(%d)\\n\"\t\t\t/*2*/\n};\n\n/*外部全局量*/\n\nEventQue g_event_que[EN_EVENT_TYPE_NUM];\n\n/*内部用宏定义*/\n\nLOCAL InVarCfg s_invar_cfg[] =\n{\n\t{\n\t\t\"chan_a_check_trigger type=b\", NULL,\n\t\t(CallBackTask)putChanChkEvent, NULL, NULL, NULL\n\t},\n\n\t{\n\t\t\"chan_b_check_trigger type=b\", NULL,\n\t\t(CallBackTask)putChanChkEvent, NULL, NULL, NULL\n\t},\n\n\t{\n\t\t\"chan_c_check_trigger type=b\", NULL,\n\t\t(CallBackTask)putChanChkEvent, NULL, NULL, NULL\n\t},\n\n\t{\n\t\t\"chan_d_check_trigger type=b\", NULL,\n\t\t(CallBackTask)putChanChkEvent, NULL, NULL, NULL\n\t},\n\n\t{\n\t\t\"lcd_del_his_event type=b\", NULL,\n\t\t(CallBackTask)delAllHisEvent, NULL, NULL, NULL\n\t},\n\n\t{\n\t\t\"iec103_del_his_event type=b\", NULL,\n\t\t(CallBackTask)delAllHisEvent, NULL, NULL, NULL\n\t},\n\n\t{\n\t\t\"lcd_signal_rst type=b\", NULL,\n\t\t(CallBackTask)signalResetProc, NULL, NULL, NULL\n\t},\n\n\t{\n\t\t\"iec103_signal_rst type=b\", NULL,\n\t\t(CallBackTask)signalResetProc, NULL, NULL, NULL\n\t},\n\n\t{\n\t\t\"iec61850_signal_rst type=b\", NULL,\n\t\t(CallBackTask)signalResetProc, NULL, NULL, NULL\n\t},\n\n\t{\n\t\t\"bin_in_signal_rst type=b\", NULL,\n\t\t(CallBackTask)signalResetProc, NULL, NULL, NULL\n\t},\n\n\t{\n\t\t\"opt_moniblk_input type=b\", NULL,\n\t\t(CallBackTask)NULL, NULL, NULL, NULL\n\t},\n\n\t{\n\t\t\"comm_test_event_trigger type=b\", NULL,\n\t\t(CallBackTask)genCommTestEventCallBack, NULL, NULL, NULL\n\t},\n\n\t{\n\t\t\"comm_test_event_index type=lu\", NULL,\n\t\t(CallBackTask)NULL, NULL, NULL, NULL\n\t},\n\n\t{\n\t\t\"rpt_updated type=c\", NULL,\n\t\t(CallBackTask)putOrderEvent, NULL, NULL, NULL\n\t}\n};\n\ntypedef enum\n{\n\tEN_EVENT_CONFIGURE_REF_TBL,\n\tEN_TRIP_REF_TBL,\n\tEN_TRIP_PARA_READY_REF_TBL,\n\tEN_TRIP_PARA_REF_TBL,\n\tEN_SELF_CHECK_REF_TBL,\n\tEN_BINCHG_REF_TBL,\n\tEN_RUN_REF_TBL,\n\tEN_RUN_PARA_REF_TBL,\n\tEN_CHAN_A_CHECK_REF_TBL,\n\tEN_CHAN_B_CHECK_REF_TBL,\n\tEN_CHAN_C_CHECK_REF_TBL,\n\tEN_CHAN_D_CHECK_REF_TBL,\n\tEN_CHAN_A_STAT_REF_TBL,\n\tEN_CHAN_B_STAT_REF_TBL,\n\tEN_CHAN_C_STAT_REF_TBL,\n\tEN_CHAN_D_STAT_REF_TBL,\n\tEN_YX_REF_TBL\n} EVENT_UNIT_REF_TBL;\n\n/*引用表名称定义*/\nLOCAL RefTblCfg s_ref_tbl_cfg[] =\n{\n\t{\n\t\t\"event_configure_table type=s\", NULL,\n\t\t(CallBackTask)eventConfigCallback, NULL, NULL, NULL\n\t},\n\n\t{\n\t\t\"trip_refer_table type=s\", NULL,\n\t\t(CallBackTask)tripRefTabCallback, NULL, NULL, NULL\n\t},\n\n\t{\n\t\t\"trip_para_ready_refer_table type=s\", NULL,\n\t\t(CallBackTask)tripParaReadyRefTabCallback, NULL, NULL, NULL\n\t},\n\n\t{\n\t\t\"trip_para_refer_table type=s\", NULL,\n\t\t(CallBackTask)tripParaRefTabCallback, NULL, NULL, NULL\n\t},\n\n\t{\n\t\t\"self_check_refer_table type=s\", NULL,\n\t\t(CallBackTask)checkRefTabCallback, NULL, NULL, NULL\n\t},\n\n\t{\n\t\t\"binchg_refer_table type=s\", NULL,\n\t\t(CallBackTask)biRefTabCallback, NULL, NULL, NULL\n\t},\n\n\t{\n\t\t\"run_refer_table type=s\", NULL,\n\t\t(CallBackTask)runRefTabCallback, NULL, NULL, NULL\n\t},\n\t{\n\t\t\"run_para_refer_table type=s\", NULL,\n\t\t(CallBackTask)runParaRefTabCallback, NULL, NULL, NULL\n\t},\n\n\t{\n\t\t\"chan_a_check_refer_table type=s\", NULL,\n\t\t(CallBackTask)chanChkRefTabCallback, NULL, NULL, NULL\n\t},\n\n\t{\n\t\t\"chan_b_check_refer_table type=s\", NULL,\n\t\t(CallBackTask)chanChkRefTabCallback, NULL, NULL, NULL\n\t},\n\n\t{\n\t\t\"chan_c_check_refer_table type=s\", NULL,\n\t\t(CallBackTask)chanChkRefTabCallback, NULL, NULL, NULL\n\t},\n\n\t{\n\t\t\"chan_d_check_refer_table type=s\", NULL,\n\t\t(CallBackTask)chanChkRefTabCallback, NULL, NULL, NULL\n\t},\n\n\t{\n\t\t\"chan_a_stat_refer_table type=s\", NULL,\n\t\t(CallBackTask)chanStatRefTabCallback, NULL, NULL, NULL\n\t},\n\n\t{\n\t\t\"chan_b_stat_refer_table type=s\", NULL,\n\t\t(CallBackTask)chanStatRefTabCallback, NULL, NULL, NULL\n\t},\n\n\t{\n\t\t\"chan_c_stat_refer_table type=s\", NULL,\n\t\t(CallBackTask)chanStatRefTabCallback, NULL, NULL, NULL\n\t},\n\n\t{\n\t\t\"chan_d_stat_refer_table type=s\", NULL,\n\t\t(CallBackTask)chanStatRefTabCallback, NULL, NULL, NULL\n\t},\n\n\t{\n\t\t\"yx_refer_table type=s\", NULL,\n\t\t(CallBackTask)yxRefTabCallback, NULL, NULL, NULL\n\t}\n};\n\nEvent *newEvent(Component *parent, const INT8 *name)\n{\n\tINT32 ret;\n\tEvent *cp;\n\n\tcp = (Event *) HOPEMALLOC(sizeof(Event));\n\tif (cp == NULL)\n\t{\n\t\tPRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_GET_COMPONENT_MEM_ERR]\n\t\t\t\t\t, name, errno);\n\t\treturn NULL;\n\t}\n\n\tcp->parent = parent;\n\tcp->name = name;\n\tcp->type_name = \"EVENT\";\n\tcp->init_component= NULL;\n\n\t//注册元件自身\n\tret = defineComponent((Component *)cp);\n\tif( ret != 0 ) \n\t{\n\t\tPRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_DEFINE_COMPONENT_ERR]\n\t\t\t\t\t  ,name);\n\t\treturn NULL;\n\t}\n\n\t//注册元件输入\n    ret = defineEventSignalIn(cp);\n    if (ret < 0)\n        return NULL;\n\t\n\t//注册元件输出\n    ret = defineEventSignalOut(cp);\n    if (ret < 0)\n        return NULL;\n\t\n\t//注册参数\n\tdefineParameter((Component *)cp, &cp->is_main_device_rly\n\t\t               ,\"is_main_device_rly type=cu option=1 default=0\");\n    defineParameter((Component *)cp,&cp->time_zone,\"time_zone type=l \");\n\n\t//注册引用表\n    ret = defineEventRefTbl(cp);\n    if (ret < 0)\n        return NULL;\n\n\t/*参数置初始值*/\n\tmemset(g_event_que, 0, sizeof(EventQue)*EN_EVENT_TYPE_NUM);\n\n\treturn cp;\n}\n\nINT32 defineEventSignalIn(Event *cp)\n{\n\tINT32 i,ret;\n\n\tfor (i=0; i<sizeof(s_invar_cfg)/sizeof(InVarCfg); i++)\n\t{\n\t\ts_invar_cfg[i].p_p_inval = (void **)&cp->p_in_val[i];\n\t\ts_invar_cfg[i].p_func_para = (void *)&s_invar_cfg[i];\n\t\ts_invar_cfg[i].p_parent = (void *)cp;\n\t\ts_invar_cfg[i].index = i;\n\t}\n\n\tfor (i=0; i<sizeof(s_invar_cfg)/sizeof(InVarCfg); i++)\n\t{\n\t\tif (s_invar_cfg[i].func == NULL)\n\t\t\tret = defineSignalIn( (Component *)cp\n\t\t\t\t\t\t,s_invar_cfg[i].p_p_inval, s_invar_cfg[i].desc);\n\t\telse\n\t\t\tret = defineSignalInWithCallback( (Component *)cp\n\t\t\t\t\t\t,s_invar_cfg[i].p_p_inval, s_invar_cfg[i].desc\n\t\t\t\t\t\t,s_invar_cfg[i].func, (void *)s_invar_cfg[i].p_func_para);\n\t\tif (ret != 0)\n\t\t{\n\t\t\tPRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_SIGNAL_DEFINE_SIGNAL_IN_ERR]\n\t\t\t\t\t\t,s_invar_cfg[i].desc);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t//遥控结构体的输入\n\tret = defineSignalInWithSize((Component *)cp\n\t\t\t\t\t\t\t\t,(void **)&cp->order_in_val\n\t\t\t\t\t\t        ,sizeof(CtrlRpt), \"ctrl_rpt type=p\");\n\tif (ret != 0)\n\t\tPRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_SIGNAL_DEFINE_SIGNAL_IN_ERR],\n\t\t\t\t\t\"order_content\");\n\t\n\treturn 0;\n}\n\nINT8 rttask_reset;\nFLOAT32 float_cnt=1234.56;\nINT8 bool_cnt=1;\nINT8 int8_cnt;\nINT16 int16_cnt;\nINT32 int32_cnt;\nINT32 defineEventSignalOut(Event *cp)\n{\n//\tdefineSignalOut((Component *)cp\n//\t\t\t\t\t\t,(void *)&test_que\n//\t\t\t\t\t\t,\"test_que type=c\");\n//\n\n\tdefineSignalOut((Component *)cp\n\t\t\t\t\t\t,(void *)&cp->del_event_state\n\t\t\t\t\t\t,\"delete_his_event type=b\");\n\tdefineSignalOut((Component *)cp\n\t\t\t\t\t\t,(void *)&cp->signal_reset_state\n\t\t\t\t\t\t,\"signal_reset type=b\");\n\n\tdefineSignalOut((Component *)cp\n\t\t\t\t\t\t,(void *)&cp->sys_restart\n\t\t\t\t\t\t,\"sys_restart type=b\");\n\n\tdefineSignalOut((Component *)cp\n\t\t\t\t\t\t,(void *)&cp->first_on\n\t\t\t\t\t\t,\"first_on type=b\");\n\n\tdefineSignalOut((Component *)NULL\n\t\t\t\t\t\t,(void *)&float_cnt\n\t\t\t\t\t\t,\"float_cnt type=f\");\n\tdefineSignalOut((Component *)NULL\n\t\t\t\t\t\t,(void *)&bool_cnt\n\t\t\t\t\t\t,\"bool_cnt type=b\");\n\tdefineSignalOut((Component *)NULL\n\t\t\t\t\t\t,(void *)&int8_cnt\n\t\t\t\t\t\t,\"int8_cnt type=c\");\n\tdefineSignalOut((Component *)NULL\n\t\t\t\t\t\t,(void *)&int16_cnt\n\t\t\t\t\t\t,\"int16_cnt type=i\");\n\tdefineSignalOut((Component *)NULL\n\t\t\t\t\t\t,(void *)&int32_cnt\n\t\t\t\t\t\t,\"int32_cnt type=l\");\n\n\treturn 0;\n}\n\nINT32 defineEventRefTbl(Event *cp)\n{\n\tINT32 i,ret;\n\n\tfor (i=0; i<sizeof(s_ref_tbl_cfg)/sizeof(RefTblCfg); i++)\n\t{\n\t\ts_ref_tbl_cfg[i].p_func_para = (void *)&s_ref_tbl_cfg[i];\n\t\ts_ref_tbl_cfg[i].p_parent = (void *)cp;\n\t\ts_ref_tbl_cfg[i].index = i;\n\t}\n\n\tfor (i=0; i<sizeof(s_ref_tbl_cfg)/sizeof(RefTblCfg); i++)\n\t{\n\t\tif (s_ref_tbl_cfg[i].func == NULL)\n\t\t\tret = defineParameter( (Component *)cp\n\t\t\t\t\t\t\t,(void *)&s_ref_tbl_cfg[i].p_tbl, s_ref_tbl_cfg[i].desc);\n\t\telse\n\t\t\tret = defineParameterWithCallback((Component *)cp\n\t\t\t\t\t\t\t\t\t\t,(void *)&s_ref_tbl_cfg[i].p_tbl\n\t\t\t\t\t\t\t\t\t\t,s_ref_tbl_cfg[i].desc, s_ref_tbl_cfg[i].func\n\t\t\t\t\t\t\t\t\t\t,s_ref_tbl_cfg[i].p_func_para);\n\t\tif (ret != 0)\n\t\t\tPRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_REF_TAB_DEFINE_PARAMETER_ERR]\n\t\t\t\t\t\t,s_ref_tbl_cfg[i].desc);\n\t}\n\n\treturn 0;\n}\n\n/*\n * 调用本插件应用程序中各个元件的计算复杂定值的，并将复杂定值计算的结果返回给管理CPU。\n */\nINT32 initEventStep1(Event *cp)\n{\n\tINT32 i;\n\tINT32 ret;\n\n\t/*检查引用表配置之间的关联关系是否正确，生成一些相关参数*/\n\tret = checkEventAllRefTabCfg(cp);\n\tif (ret != 0)\n\t\treturn -1;\n\n\tfor (i=0; i<EN_EVENT_TYPE_NUM; i++)\n\t{\n\t\t/*事件队列的存储空间配置参数读取成功，初始化队列*/\n\t\tif (g_event_que[i].read_cfg_ok == 1)\n\t\t{\n\t\t\tret = initEventQue(cp,i);\n\t\t\tif (ret != 0)\n\t\t\t{\n\t\t\t\tPRINTINFO(ALL_SHOW, s_error_msg[EN_EVENT_QUEUE_INIT_ERR]\n\t\t\t\t\t\t\t,s_event_sram_name[i]);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n * 调用本插件应用程序中各个元件的初始化函数，完成元件私有数据初始化、任务函数的注册\n */\nINT32 initEventStep2(Event *cp)\n{\n\tINT32 i;\n\tINT32 ret;\n\tSystemTime local_time;\n\t\n\n//#ifdef SRAM_GET_WITH_INT16\n\tcp->p_event_para_mem = HOPEMALLOC(MAX_EVENT_PARA_NUM * sizeof(INT32));\n\tif (cp->p_event_para_mem == NULL)\n\t{\n\t\tPRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_GET_MEM_ERR],\n\t\t\t\t\t\t\"event para temp\", errno);\n\t\treturn -1;\n\t}\n//#endif\n\n\tret = regScanEventCallBack(cp);\n\tif (ret != 0)\n\t\treturn -1;\n\n\tcp->module = selfModule();\n\n\tfor (i=0; i<EN_EVENT_TYPE_NUM; i++)\n\t{\n\t\t/*事件队列的存储空间配置参数读取成功，初始化队列*/\n\t\tif (g_event_que[i].read_cfg_ok == 1)\n\t\t{\n\t\t\tret = initEventQueSram(i);\n\t\t\tif (ret != 0)\n\t\t\t{\n\t\t\t\tPRINTINFO(ALL_SHOW, s_error_msg[EN_EVENT_QUEUE_INIT_ERR]\n\t\t\t\t\t\t\t,s_event_sram_name[i]);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*检查SRAM中保存的事件队列的一些值是否合法*/\n\t\t\t\tcheckEventQue(i);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*设置链接量中的无符号数据类型*/\n\tsetEventInVarSignedType(cp);\n\n//\tif (cp->p_soe_event_cfg != NULL)\n//\t{\n//\t\tret = initSoeProcess(cp);\n//\t\tif (ret < 0)\n//\t\t\treturn -1;\n//\t}\n\n\tret = addTask(2, (Task)eventTask, (void *)cp);\n\tif (ret != 0)\n\t{\n\t\tPRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_ADD_TASK_ERR], \"eventTask\");\n\t\treturn -1;\n\t}\n\n\t//等待1秒正式运行\n//\tcp->run_wait_count = 500 * rttask_run_freq / 1000 + 1;\n\tcp->chan_stat_exe_count = 60 * rttask_run_freq;\t/*1分钟*/\n\n\tgetLocalTime(&local_time);\n\tcp->last_day = local_time.day;\n\n\treturn 0;\n}\n\n//\tstatic int xxt=0;\nvoid eventTask(Event *cp)\n{\n#ifdef MEASURE_TASK_TIME\n\tUINT32 start_us;\n\n\tstart_us = getUsCnt();\n#endif\n\n//\tif(xxt==0)\n//\t\tbool_cnt = 0;\n//\tif(xxt==600)\n\t\tbool_cnt = 1;\n//\txxt++;\n//\tif(xxt>=1200)\n//\t{\n//\t\txxt=0;\n////\t\tprintf(\"--trip[0] addr=%x, val=%d\\n\",\n////\t\tcp->p_trip_event_cfg[0].p_invar, cp->p_trip_event_cfg[0].p_invar->value);\n//\t}\n//\tfloat_cnt++;\n//\tbool_cnt++;\n\tint8_cnt++;\n\tint16_cnt++;\n\tint32_cnt++;\n\t\n\tif(cp->first_on==0)\n\t\tcp->first_on = 1;\n\t\n\n\trttask_run_cnt++;\t// 系统监测心跳\n\tif ( rttask_time_count==0 )\n\t{\n\t\tcp->sys_restart = 0;\n\t\tg_sys_run_state = 1;\n\t}\n\telse\n\t{\n\t\trttask_time_count--;\n\t\tg_sys_run_state = 0;\n\t\tcp->sys_restart = 1;\n\t\teventWaitRunTask(cp);\n\n\t\treturn;\n\t}\n\n\t// 有同一点产生待排序的则写入SRAM\n\tsaveEventToSram(cp);\n\t\n\t// 通道统计报告每天形成\n\tcp->chan_stat_time_count++;\n\tif (cp->chan_stat_time_count >= cp->chan_stat_exe_count)\n\t{\n\t\tcp->chan_stat_time_count = 0;\n\t\tscanTimeDayChange(cp);\n\t}\n\n\t// 产生一种类型所有事件 或 四种类型所有事件\n\tif (cp->comm_gen_even_flag == 1)\n\t{\n\t\tputCommTestEvent(cp);\n\t}\n\n\tclearEventOutSignal(cp);\n\t\n//\tif(test_que==4)\n//\t{\n//\t    putEventIndexQue(EN_TRIP_EVENT,4,1);\n//\t    putEventIndexQue(EN_TRIP_EVENT,2,1);\n//\t    putEventIndexQue(EN_TRIP_EVENT,3,1);\n//\t    putEventIndexQue(EN_TRIP_EVENT,5,1);\n//\t    test_que = 0;\n//\t}\n//\tif(test_que==3)\n//\t{\n//\t    putEventIndexQue(EN_TRIP_EVENT,4,1);\n//\t    putEventIndexQue(EN_TRIP_EVENT,2,1);\n//\t    putEventIndexQue(EN_TRIP_EVENT,3,1);\n//\t    test_que = 0;\n//\t}\n//\tif(test_que==2)\n//\t{\n//\t    putEventIndexQue(EN_TRIP_EVENT,4,1);\n//\t    putEventIndexQue(EN_TRIP_EVENT,3,1);\n//\t    test_que = 0;\n//\t}\n//\tif(test_que==1)\n//\t{\n//\t    putEventIndexQue(EN_TRIP_EVENT,4,1);\n//\t    test_que = 0;\n//\t}\n\t\n\n#ifdef MEASURE_TASK_TIME\n\tmeasureTaskTime(EVENT_COMPONENT, start_us);\n#endif\n\n\treturn;\n}\n\nvoid eventWaitRunTask(Event *cp)\n{\n\ttraverseEventIndexQue(EN_RUN_EVENT, (InCallBackTask)putRunEvent\n\t\t\t\t\t\t\t\t, (void *)cp);\n\n\ttraverseEventIndexQue(EN_CHECK_EVENT, (InCallBackTask)putCheckEvent\n\t\t\t\t\t\t\t\t, (void *)cp);\n\n\treturn;\n}\n\nvoid saveEventToSram(Event *cp)\n{\n\t/*遍历历事件索引号队列按事件引用表次序产生事件*/\n\n\t// 参数准备好信号超时处理\n\tscanEventParaReadyTimeOut(cp);\n\n\ttraverseEventIndexQue(EN_TRIP_EVENT, (InCallBackTask)putTripEvent\n\t\t\t\t\t\t\t\t, (void *)cp);\n\n\ttraverseEventIndexQue(EN_RUN_EVENT, (InCallBackTask)putRunEvent\n\t\t\t\t\t\t\t\t, (void *)cp);\n\n\ttraverseEventIndexQue(EN_CHECK_EVENT, (InCallBackTask)putCheckEvent\n\t\t\t\t\t\t\t\t, (void *)cp);\n\n\ttraverseEventIndexQue(EN_BI_EVENT, (InCallBackTask)putBiEvent\n\t\t\t\t\t\t\t\t, (void *)cp);\n}\n\n/*\n * 事件参数索引不能大于其对应参数索引表的个数\n */\nINT32 checkEventCfgParaIndex(EventQue *p_event_que\n\t\t\t\t\t\t\t\t, WithParaEventCfg *p_cfg_start\n\t\t\t\t\t\t\t\t, RefTblCfg *p_ref_tab_cfg)\n{\n\tINT32 i,j;\n\tUINT16 max_index;\n\tWithParaEventCfg *p_cfg;\n\n\tmax_index = p_event_que->para_ref_tab_item_num;\n\tp_cfg = p_cfg_start;\n\tfor (i=0; i<p_event_que->event_ref_tab_item_num; i++)\n\t{\n\t\tif (p_cfg->para_num > MAX_EVENT_PARA_NUM)\n\t\t{\n\t\t\tPRINTINFO(ALL_SHOW, s_error_msg[EN_EVENT_REF_TAB_PARA_NUM_ERR]\n\t\t\t\t\t\t,i, p_ref_tab_cfg->desc, p_cfg->para_num\n\t\t\t\t\t\t,MAX_EVENT_PARA_NUM);\n\t\t\treturn -1;\n\t\t}\n\n\t\tfor (j=0; j<p_cfg->para_num; j++)\n\t\t{\n\t\t\tif (p_cfg->para_index[j] >= max_index)\n\t\t\t{\n\t\t\t\tPRINTINFO(ALL_SHOW, s_error_msg[EN_EVENT_REF_TAB_PARA_INDEX_ERR]\n\t\t\t\t\t\t\t,i, p_ref_tab_cfg->desc\n\t\t\t\t\t\t\t,p_cfg->para_index[j], max_index);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (p_cfg->phase_index >= max_index\n\t\t && p_cfg->phase_index != 0xffff)\n\t\t{\n\t\t\tPRINTINFO(ALL_SHOW, s_error_msg[EN_EVENT_REF_TAB_PARA_INDEX_ERR]\n\t\t\t\t\t\t,i, p_ref_tab_cfg->desc\n\t\t\t\t\t\t,p_cfg->phase_index, max_index);\n\t\t\treturn -1;\n\t\t}\n\n\t\tp_cfg++;\n\t}\n\n\tif (p_event_que->para_ready_tab_num == 0)\n\t\treturn 0;\n\n\tmax_index = p_event_que->para_ready_tab_num;\n\tp_cfg = p_cfg_start;\n\tfor (i=0; i<p_event_que->event_ref_tab_item_num; i++)\n\t{\n\t\tif (p_cfg->para_ready_index >= max_index\n\t\t && p_cfg->para_ready_index != 0xffff)\n\t\t{\n\t\t\tPRINTINFO(ALL_SHOW, s_error_msg[EN_EVENT_REF_TAB_PARA_READY_INDEX_ERR]\n\t\t\t\t\t\t\t,i, p_ref_tab_cfg->desc\n\t\t\t\t\t\t\t,p_cfg->para_ready_index, max_index);\n\t\t\treturn -1;\n\t\t}\n\t\tp_cfg++;\n\t}\n\n\treturn 0;\n}\n\n/*\n * 检查引用表配置之间的关联关系是正确,只有等所有引用表读入后才能比较\n */\nINT32 checkEventAllRefTabCfg(Event *cp)\n{\n\n\tINT32 ret,i;\n\n\tret = checkEventCfgParaIndex(&g_event_que[EN_TRIP_EVENT]\n\t\t\t\t\t\t\t\t,cp->p_trip_event_cfg\n\t\t\t\t\t\t\t\t,&s_ref_tbl_cfg[EN_TRIP_REF_TBL]);\n\tif (ret != 0)\n\t\treturn -1;\n\n\tret = checkEventCfgParaIndex(&g_event_que[EN_RUN_EVENT]\n\t\t\t\t\t\t\t\t,cp->p_run_event_cfg\n\t\t\t\t\t\t\t\t,&s_ref_tbl_cfg[EN_RUN_REF_TBL]);\n\tif (ret != 0)\n\t\treturn -1;\n\n\tfor (i=0; i<EN_EVENT_TYPE_NUM; i++)\n\t{\n\t\tif (g_event_que[i].event_ref_tab_item_num != 0\n\t\t && g_event_que[i].read_cfg_ok == 0)\n\t\t{\n\t\t\tPRINTINFO(ALL_SHOW, s_error_msg[EN_EVENT_QUEUE_CONFIGURE_ERR]\n\t\t\t\t\t\t,s_event_sram_name[i]);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nEventType getEventTypeFromName(INT8 *p_event_name)\n{\n\tINT32 i;\n\n\tif (p_event_name == NULL)\n\t\treturn 0;\n\n\tfor (i=0; i<EN_EVENT_TYPE_NUM; i++)\n\t\tif (strcmp(p_event_name, s_event_sram_name[i]) == 0)\n\t\t\tbreak;\n\n\treturn (i);\n}\n\n/*\n * 对于引用表,可以不配置,但是如果配置了这项，这项如果格式有错，\n * 提示信息并返回错误，初始化不通过\n */\n\n/*\n * 事件存储区配置引用表的回调函数\n * 格式：N项下列行,event_configure_table =\n * \"事件名称:存储事件数据的最大项数:存储参数区的最大项数\"\n * 每行代表一种事件类型的参数,事件名称，如下：\n *\n * \"Trip:\"\t动作事件配置\n * \"Warn:\"\t运行记录配置\n * \"Check:\"\t自检事件配置\n * \"Bi:\"\t开关量变位配置\n * \"ChChk:\"\t通道自检配置\n * \"ChSta:\"\t通道统计配置\n */\nINT32 eventConfigCallback(RefTblCfg *p_ref_tab_cfg)\n{\n\tINT32 i;\n\tINT32 ret;\n\tINT8 *p_str[3];\n\tEventType event_type;\n\tEvent *cp;\n\tRefParameterItems *p_ref_tab_item;\n\n\tcp = p_ref_tab_cfg->p_parent;\n\tp_ref_tab_item = p_ref_tab_cfg->p_tbl;\n\tif ( p_ref_tab_item == NULL)\n\t{\n\t\tPRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_REF_TAB_NOT_EXIT]\n\t\t\t\t\t\t\t,p_ref_tab_cfg->desc);\n\t\treturn -1;\n\t}\n\n\tif ( p_ref_tab_item->num == 0)\n\t{\n\t\tPRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_REF_TAB_NUM_ERR]\n\t\t\t\t,p_ref_tab_cfg->desc\n\t\t\t\t,p_ref_tab_item->num);\n\n\t\treturn -1;\n\t}\n\n\tfor (i=0; i<p_ref_tab_item->num; i++)\n\t{\n\t\tret = getSepStrFromRefTblItem(p_ref_tab_item->item[i]\n\t\t\t\t\t\t\t\t\t\t,':', p_str, 3);\n\t\tif (ret < 3)\n\t\t{\n\t\t\tPRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_REF_TAB_ITEM_FORMAT_ERR]\n\t\t\t\t\t\t\t\t,i, p_ref_tab_item->item[i]\n\t\t\t\t\t\t\t\t,p_ref_tab_cfg->desc);\n\t\t\treturn -1;\n\t\t}\n\t\tevent_type = getEventTypeFromName(p_str[0]);\n\t\tif (event_type >= EN_EVENT_TYPE_NUM)\n\t\t{\n\t\t\tPRINTINFO(ALL_SHOW, s_error_msg[EN_EVENT_NAME_IN_REF_TAB_ERR]\n\t\t\t\t\t\t,p_str[0], p_ref_tab_cfg->desc);\n\n\t\t\treturn -1;\n\t\t}\n\n//\t\tB01.event.event_configure_table = Trip:1024:64;\\\n//             \t\t                      Run:512:16;\\\n//                     \t\t              Check:1024:0;\\\n//                      \t\t          Bi:1024:0\n\t\tg_event_que[event_type].max_num = (UINT16)atoi(p_str[1]);\n\t\tg_event_que[event_type].para_que_max_num = (UINT16)atoi(p_str[2]);\n\t\tg_event_que[event_type].read_cfg_ok = 1;\n\t\t\n\t\t// 当SRAM要求INT16写入时（不支持INT8写入），此要求是必须的，\n\t\t// 否则，initEventQueSram函数中对 p_event_que->p_para_ctrl 的访问会出错\n\t\tif( g_event_que[event_type].max_num & 0x01 )\n\t\t{\n\t\t\tPRINTINFO(ALL_SHOW, s_error_msg[EN_EVENT_NUM_MUST_BE_EVEN_ERR]\n\t\t\t\t\t\t,p_str[0]);\n\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n * 跳闸事件引用表的回调函数\n * 格式:trip_refer_table =\n * \"跳闸事件信号名称:FUN:INF:录波用数字通道正常状态(一般0代表正常):录波用通道相别(最多两个字符):\n * 打印分组:参数配置:动作相别参数索引号:参数准备好变量索引\"\n */\nINT32 tripRefTabCallback(RefTblCfg *p_ref_tab_cfg)\n{\n\tINT32 i;\n\tINT32 ret;\n\tINT8 *p_str[9];\n\tUINT16 para_num=0;\n\tEvent *cp;\n\tRefParameterItems *p_ref_tab_item;\n\n\tcp = p_ref_tab_cfg->p_parent;\n\tp_ref_tab_item = p_ref_tab_cfg->p_tbl;\n\t/*引用表必须存在，内容可以为空*/\n\tif ( p_ref_tab_item == NULL)\n\t{\n\t\tPRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_REF_TAB_NOT_EXIT]\n\t\t\t\t\t\t\t, p_ref_tab_cfg->desc);\n\t\treturn -1;\n\t}\n\n\tif (p_ref_tab_item->num == 0)\n\t{\n\t\t/*PRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_REF_TAB_NUM_IS_ZERO],\n\t\t\t\t\t\ts_ref_tbl_cfg[EN_TRIP_REF_TBL].desc,\n\t\t\t\t\t\tcp->p_trip_refer_table->num);*/\n\t\treturn 0;\n\t}\n\n\tcp->p_trip_event_cfg = HOPEMALLOC(( p_ref_tab_item->num\n\t\t\t\t\t\t\t\t\t\t* sizeof(WithParaEventCfg)));\n\tif(cp->p_trip_event_cfg == NULL)\n\t{\n\t\tPRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_REF_TAB_PARSE_GET_MEM_ERR]\n\t\t\t\t\t, p_ref_tab_cfg->desc, errno);\n\t\treturn -1;\n\t}\n\n\tfor (i=0; i<p_ref_tab_item->num; i++)\n\t{\n\t\tret = getSepStrFromRefTblItem( p_ref_tab_item->item[i]\n\t\t\t\t\t\t\t\t\t\t,':', p_str, 9);\n\t\tif (ret < 9)\n\t\t{\n\t\t\tPRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_REF_TAB_ITEM_FORMAT_ERR]\n\t\t\t\t\t\t\t,i, p_ref_tab_item->item[i]\n\t\t\t\t\t\t\t,p_ref_tab_cfg->desc);\n\t\t\treturn -1;\n\t\t}\n\n\t\tret = linkSignalInWithPtr((Component *)cp\n\t\t\t\t,(void **)&(cp->p_trip_event_cfg[i].p_invar), p_str[0]);\n\n\t\tif (ret != 0)\n\t\t{\n\t\t\tPRINTINFO(ALL_SHOW\n\t\t\t\t\t\t, g_hmi_err_msg[EN_REF_TAB_ITEM_LINK_SIGNAL_IN_ERR]\n\t\t\t\t\t\t, i, p_str[0], p_ref_tab_cfg->desc);\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tif(p_str[1] && (p_str[1][0] == 'B'))\n\t\t{\n\t\t\tret = linkSignalInWithPtr((Component *)cp\n        \t                         , (void **)&(cp->p_trip_event_cfg[i].p_quality_invar)\n        \t                         , (INT8 *)p_str[1] );\n        \t                          \t\n        \tif (ret != 0)\n\t\t\t{\t\n//\t\t\t\tPRINTINFO(ALL_SHOW\n//\t\t\t\t\t, g_hmi_err_msg[EN_REF_TAB_ITEM_LINK_SIGNAL_IN_ERR]\n//\t\t\t\t\t, i, p_str[1], cp->p_trip_event_cfg[i].desc);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\t\t\n\t\t\tp_str[1] = NULL;\n        }\n        else\n        \tcp->p_trip_event_cfg[i].p_quality_invar = NULL;\n\n\t\tcp->p_trip_event_cfg[i].p_datafield = getSignalOutWithName(p_str[0]);\n\t\tif (cp->p_trip_event_cfg[i].p_datafield == NULL)\n\t\t{\n\t\t\tPRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_GET_DEVICE_SIGNAL_ERR]\n\t\t\t\t\t\t,i, p_str[0], p_ref_tab_cfg->desc);\n\t\t\treturn -1;\n\t\t}\n\n\t\tcp->p_trip_event_cfg[i].para_num = getUint16FromStrCfg(p_str[6]\n\t\t\t\t\t\t\t,&cp->p_trip_event_cfg[i].para_index[0]\n\t\t\t\t\t\t\t,MAX_EVENT_PARA_NUM);\n\t\tcp->p_trip_event_cfg[i].phase_index = (UINT16)atoi(p_str[7]);\n\t\tcp->p_trip_event_cfg[i].para_ready_index = (UINT16)atoi(p_str[8]);\n\t\tif (cp->p_trip_event_cfg[i].para_num > para_num)\n\t\t\tpara_num = cp->p_trip_event_cfg[i].para_num;\n\t}\n\n\tg_event_que[EN_TRIP_EVENT].event_ref_tab_item_num = p_ref_tab_item->num;\n\tg_event_que[EN_TRIP_EVENT].para_num = para_num;\n\n\treturn 0;\n}\n\n/*\n * 事件参数引用表的公用回调函数\n * 格式: 形如 引用表名称 =\n * \"参数名称\",\n * \"参数名称\"\n */\nINT32 eventParaRefTabCallback(RefTblCfg *p_ref_tab_cfg\n\t\t\t\t\t\t\t,EventParaCfg **p_p_para_cfg, UINT16 *ref_tab_num)\n{\n\tINT32 i;\n\tINT32 ret;\n\tINT8 *p_str[2];\n\tEventParaCfg *p_para_cfg;\n\tRefParameterItems *p_ref_tab_item;\n\tEvent *cp;\n\n\tcp = p_ref_tab_cfg->p_parent;\n\tp_ref_tab_item = p_ref_tab_cfg->p_tbl;\n\t*p_p_para_cfg = NULL;\n\t*ref_tab_num = 0;\n\t\n\tif (p_ref_tab_item == NULL)\n\t{\n\t\tPRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_REF_TAB_NOT_EXIT]\n\t\t\t\t\t\t,p_ref_tab_cfg->desc);\n\t\treturn 0;\n\t}\n\n\tif (p_ref_tab_item->num == 0)\n\t{\n\t\t/*PRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_REF_TAB_NUM_IS_ZERO],\n\t\t\t\t\tp_ref_tab_cfg->desc, p_ref_tab_info->num);*/\n\t\treturn 0;\n\t}\n\n\tp_para_cfg = HOPEMALLOC((p_ref_tab_item->num * sizeof(EventParaCfg)));\n\tif(p_para_cfg == NULL)\n\t{\n\t\tPRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_REF_TAB_PARSE_GET_MEM_ERR]\n\t\t\t\t\t,p_ref_tab_cfg->desc, errno);\n\t\treturn -1;\n\t}\n\n\tfor(i=0; i<p_ref_tab_item->num; i++)\n\t{\n\t\tret = getSepStrFromRefTblItem(p_ref_tab_item->item[i], ':', p_str, 1);\n\t\tif (ret < 1)\n\t\t{\n\t\t\tPRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_REF_TAB_ITEM_FORMAT_ERR],\n\t\t\t\t\t\t\ti, p_ref_tab_item->item[i], p_ref_tab_cfg->desc);\n\t\t\treturn -1;\n\t\t}\n\t\t/*printf(\"invar(%s):addr=%x\\n\", p_str[0],\n\t\t\t\t\t\t\t(UINT32)&(p_para_cfg[i].p_invar));*/\n\t\tret = linkSignalInWithPtr((Component *)cp,\n\t\t\t\t\t\t\t(void **)&(p_para_cfg[i].p_invar), p_str[0]);\n\t\tif (ret != 0)\n\t\t{\n\t\t\tPRINTINFO(ALL_SHOW,\n\t\t\t\t\t\tg_hmi_err_msg[EN_REF_TAB_ITEM_LINK_SIGNAL_IN_ERR],\n\t\t\t\t\t\ti, p_str[0], p_ref_tab_cfg->desc);\n\t\t\treturn -1;\n\t\t}\n\n\t\tp_para_cfg[i].p_datafield = getSignalOutWithName(p_str[0]);\n\t\tif (p_para_cfg[i].p_datafield == NULL)\n\t\t{\n\t\t\tPRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_GET_DEVICE_SIGNAL_ERR],\n\t\t\t\t\ti, p_str[0], p_ref_tab_cfg->desc);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t*p_p_para_cfg = p_para_cfg;\n\t*ref_tab_num = p_ref_tab_item->num;\n\n\treturn 0;\n}\n\n/*\n * 跳闸事件参数准备好引用表的回调函数\n * 格式: 引用表名称 =\n * \"参数名称\"\n */\nINT32 tripParaReadyRefTabCallback(RefTblCfg *p_ref_tab_cfg)\n{\n\tINT32 ret;\n\tEvent *cp;\n\n\tcp = p_ref_tab_cfg->p_parent;\n\tret = eventParaRefTabCallback(p_ref_tab_cfg\n\t\t\t\t\t\t\t,&cp->p_trip_para_ready_cfg\n\t\t\t\t\t\t\t,&g_event_que[EN_TRIP_EVENT].para_ready_tab_num);\n\treturn ret;\n}\n\n/*\n * 跳闸事件引用表的回调函数\n * 格式: 引用表名称 =\n * \"参数名称\"\n */\nINT32 tripParaRefTabCallback(RefTblCfg *p_ref_tab_cfg)\n{\n\tINT32 ret;\n\tEvent *cp;\n\n\tcp = p_ref_tab_cfg->p_parent;\n\tret = eventParaRefTabCallback(p_ref_tab_cfg\n\t\t\t\t\t\t\t,&cp->p_trip_para_cfg\n\t\t\t\t\t        ,&g_event_que[EN_TRIP_EVENT].para_ref_tab_item_num);\n\n\treturn ret;\n}\n\n/*\n * 运行、操作事件引用表的回调函数\n * 格式:引用表名称 =\n * \"跳闸事件名称:FUN:INF:参数个数/参数索引1/参数索引2\"\n * 参数的最大个数不能超过事件配置表里此类数据所配置的参数个数\n */\nINT32 runRefTabCallback(RefTblCfg *p_ref_tab_cfg)\n{\n\tUINT16 i;\n\tINT32 ret=0;\n\tINT8 *p_str[4];\n\tUINT16 para_num=0;\n\tEvent *cp;\n\tRefParameterItems *p_ref_tab_item;\n\n\tcp = p_ref_tab_cfg->p_parent;\n\tp_ref_tab_item = p_ref_tab_cfg->p_tbl;\n\t/*引用表必须存在，内容可以为空*/\n\tif ( p_ref_tab_item == NULL)\n\t{\n\t\tPRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_REF_TAB_NOT_EXIT]\n\t\t\t\t\t\t\t, p_ref_tab_cfg->desc);\n\t\treturn -1;\n\t}\n\n\tif ( p_ref_tab_item->num == 0)\n\t{\n\t\t/*PRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_REF_TAB_NUM_IS_ZERO],\n\t\t\t\t\t\ts_ref_tbl_cfg[EN_RUN_REF_TBL].desc,\n\t\t\t\t\t\tcp->p_run_refer_table->num);*/\n\t\treturn 0;\n\t}\n\n\tcp->p_run_event_cfg = HOPEMALLOC( p_ref_tab_item->num * \\\n\t\t\t\t\t\t\t\t\t\tsizeof(WithParaEventCfg));\n\tif (cp->p_run_event_cfg == NULL)\n\t{\n\t\tPRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_REF_TAB_PARSE_GET_MEM_ERR]\n\t\t\t\t\t        , p_ref_tab_cfg->desc, errno);\n\t\treturn -1;\n\t}\n\n\tfor (i=0; i<p_ref_tab_item->num; i++)\n\t{\n\t\tret = getSepStrFromRefTblItem( p_ref_tab_item->item[i]\n\t\t\t\t\t\t\t\t\t\t,':', p_str, 4);\n\t\tif (ret < 4)\n\t\t{\n\t\t\tPRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_REF_TAB_ITEM_FORMAT_ERR]\n\t\t\t\t\t\t\t,i, p_ref_tab_item->item[i]\n\t\t\t\t\t\t\t,p_ref_tab_cfg->desc);\n\t\t\treturn -1;\n\t\t}\n\n\t\tret = linkSignalInWithPtr((Component *)cp\n\t\t\t\t\t,(void **)&(cp->p_run_event_cfg[i].p_invar), p_str[0]);\n\t\tif (ret != 0)\n\t\t{\n\t\t\tPRINTINFO(ALL_SHOW\n\t\t\t\t\t\t,g_hmi_err_msg[EN_REF_TAB_ITEM_LINK_SIGNAL_IN_ERR]\n\t\t\t\t\t\t,i, p_str[0], p_ref_tab_cfg->desc);\n\t\t\treturn -1;\n\t\t}\n\n\t\tcp->p_run_event_cfg[i].p_datafield = getSignalOutWithName(p_str[0]);\n\t\tif (cp->p_run_event_cfg[i].p_datafield == NULL)\n\t\t{\n\t\t\tPRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_GET_DEVICE_SIGNAL_ERR],\n\t\t\t\t\t\ti, p_str[0], p_ref_tab_cfg->desc);\n\t\t\treturn -1;\n\t\t}\n\n\t\tcp->p_run_event_cfg[i].para_num = getUint16FromStrCfg(p_str[3],\n\t\t\t\t\t&cp->p_run_event_cfg[i].para_index[0],\n\t\t\t\t\tMAX_EVENT_PARA_NUM);\n\n\t\tif (cp->p_run_event_cfg[i].para_num > para_num)\n\t\t\tpara_num = cp->p_run_event_cfg[i].para_num;\n\n\t\tcp->p_run_event_cfg[i].phase_index = 0xffff;\n\t}\n\n\tg_event_que[EN_RUN_EVENT].event_ref_tab_item_num = p_ref_tab_item->num;\n\tg_event_que[EN_RUN_EVENT].para_num = para_num;\n\n\treturn 0;\n}\n\nINT32 runParaRefTabCallback(RefTblCfg *p_ref_tab_cfg)\n{\n\tINT32 ret;\n\tEvent *cp;\n\n\tcp = p_ref_tab_cfg->p_parent;\n\tret =  eventParaRefTabCallback(p_ref_tab_cfg\n\t\t\t\t, &cp->p_run_para_cfg\n\t\t\t\t, &g_event_que[EN_RUN_EVENT].para_ref_tab_item_num);\n\treturn ret;\n}\n\n/*\n * 事件引用表的公用回调函数\n * 格式: 形如 引用表名称 =\n * \"参数名称:FUN:INF:录波用正常状态(一般0代表正常)\",\n * \"参数名称:FUN:INF:录波用正常状态(一般0代表正常)\"\n */\nINT8 eventRefTabCallback(RefTblCfg *p_ref_tab_cfg\n\t\t\t\t\t\t, NoParaEventCfg **p_p_event_cfg, UINT16 *ref_tab_num )\n{\n\tUINT16 i;\n\tINT32 ret,var_is_out;\n\tINT8 *p_str[5];\n\tRefParameterItems *p_ref_tab_item;\n\tNoParaEventCfg *p_event_cfg;\n\tEvent *cp;\n\tDataFields *p_datafield;\n\n\tcp = p_ref_tab_cfg->p_parent;\n\t*p_p_event_cfg = NULL;\n\tp_ref_tab_item = p_ref_tab_cfg->p_tbl;\n\n\t/*引用表必须存在，内容可以为空*/\n\tif (p_ref_tab_item == NULL)\n\t{\n\t\tPRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_REF_TAB_NOT_EXIT]\n\t\t\t\t\t\t\t, p_ref_tab_cfg->desc);\n\t\treturn -1;\n\t}\n\n\tif (p_ref_tab_item->num == 0)\n\t{\n\t\t/*PRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_REF_TAB_NUM_IS_ZERO],\n\t\t\t\t\tp_ref_tab_cfg->desc, p_ref_tab_info->num);*/\n\t\treturn 0;\n\t}\n\n\tp_event_cfg = HOPEMALLOC((p_ref_tab_item->num * sizeof(NoParaEventCfg)));\n\tif(p_event_cfg == NULL)\n\t{\n\t\tPRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_REF_TAB_PARSE_GET_MEM_ERR]\n\t\t\t\t\t,p_ref_tab_cfg->desc, errno);\n\t\treturn -1;\n\t}\n\n\tfor(i=0; i<p_ref_tab_item->num; i++)\n\t{\n\t\tret = getSepStrFromRefTblItem(p_ref_tab_item->item[i]\n\t\t\t\t\t\t\t\t\t\t,':', p_str, 5);\n\t\tif (ret < 5)\n\t\t{\n\t\t\tPRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_REF_TAB_ITEM_FORMAT_ERR]\n\t\t\t\t\t\t\t,i, p_ref_tab_item->item[i]\n\t\t\t\t\t\t\t,p_ref_tab_cfg->desc);\n\t\t\treturn -1;\n\t\t}\n\n\t\t// YX需要判断开入、开出，其他引用表不判断\n\t\tif((UINT32)(p_ref_tab_cfg->func)==(UINT32)yxRefTabCallback)\n\t\t{\n\t\t\tp_datafield = getSignalOutWithName(p_str[0]);\n\t\t\tif(p_datafield)\n\t\t\t\tvar_is_out = 1;\n\t\t\telse\n\t\t\t{\n\t\t\t\tp_datafield = getSignalInWithName(p_str[0]);\n\t\t\t\tif(p_datafield==NULL)\n\t\t\t\t{\n\t\t\t\t\tPRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_GET_DEVICE_SIGNAL_ERR]\n\t\t\t\t\t\t\t,i, p_str[0], p_ref_tab_cfg->desc);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tvar_is_out = 0;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tvar_is_out = 1;\n\t\t\n\t\tif(var_is_out)\n\t\t{\n\t\t\tret = linkSignalInWithPtr((Component *)cp\n\t\t\t\t\t\t\t\t\t,(void **)&(p_event_cfg[i].p_invar), p_str[0]);\n\t\t\tif (ret != 0)\n\t\t\t{\n\t\t\t\tPRINTINFO(ALL_SHOW\n\t\t\t\t\t\t\t\t,g_hmi_err_msg[EN_REF_TAB_ITEM_LINK_SIGNAL_IN_ERR]\n\t\t\t\t\t\t\t\t,i, p_str[0], p_ref_tab_cfg->desc);\n\t\t\t\treturn -1;\n\t\t\t}\n        \t\n\t\t\tp_event_cfg[i].p_datafield = getSignalOutWithName(p_str[0]);\n\t\t\tif (p_event_cfg[i].p_datafield == NULL)\n\t\t\t{\n\t\t\t\tPRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_GET_DEVICE_SIGNAL_ERR]\n\t\t\t\t\t\t\t,i, p_str[0], p_ref_tab_cfg->desc);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tret = linkIndirectSignalInWithPtrWithCallback((Component *)cp\n\t\t\t\t\t\t\t\t\t,(void **)&(p_event_cfg[i].p_invar), p_str[0],NULL,NULL);\n//\t\t\tret = linkSignalInWithOtherSigIn((void **)&(p_event_cfg[i].p_invar), p_str[0]);\n\t\t\tif (ret != 0)\n\t\t\t{\n\t\t\t\tPRINTINFO(ALL_SHOW\n\t\t\t\t\t\t\t\t,g_hmi_err_msg[EN_REF_TAB_ITEM_LINK_SIGNAL_IN_ERR]\n\t\t\t\t\t\t\t\t,i, p_str[0], p_ref_tab_cfg->desc);\n\t\t\t\treturn -1;\n\t\t\t}\n        \t\n\t\t\tp_event_cfg[i].p_datafield = getSignalInWithName(p_str[0]);\n\t\t\tif (p_event_cfg[i].p_datafield == NULL)\n\t\t\t{\n\t\t\t\tPRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_GET_DEVICE_SIGNAL_ERR]\n\t\t\t\t\t\t\t,i, p_str[0], p_ref_tab_cfg->desc);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(p_str[1] && (p_str[1][0] == 'B'))\n\t\t{\n\t\t\tret = linkSignalInWithPtr((Component *)cp\n        \t                         , (void **)&p_event_cfg[i].p_quality_invar\n        \t                         , (INT8 *)p_str[1] );\n        \t                          \t\n        \tif (ret != 0)\n\t\t\t{\t\n\t\t\t\tPRINTINFO(ALL_SHOW\n\t\t\t\t\t, g_hmi_err_msg[EN_REF_TAB_ITEM_LINK_SIGNAL_IN_ERR]\n\t\t\t\t\t, i, p_str[1], p_ref_tab_cfg->desc);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\t\t\n\t\t\tp_str[1] = NULL;\n        }\n        else\n        \tp_event_cfg[i].p_quality_invar = NULL;\n\t}\n\n\t*p_p_event_cfg = p_event_cfg;\n\t*ref_tab_num = p_ref_tab_item->num;\n\n\treturn 0;\n}\n\nINT32 checkRefTabCallback(RefTblCfg *p_ref_tab_cfg)\n{\n\tEvent *cp;\n\n\tcp = p_ref_tab_cfg->p_parent;\n\treturn ( eventRefTabCallback(p_ref_tab_cfg\n\t\t\t\t\t, &cp->p_check_event_cfg\n\t\t\t\t\t, &g_event_que[EN_CHECK_EVENT].event_ref_tab_item_num) );\n}\n\nINT32 biRefTabCallback(RefTblCfg *p_ref_tab_cfg)\n{\n\tEvent *cp;\n\n\tcp = p_ref_tab_cfg->p_parent;\n\treturn ( eventRefTabCallback(p_ref_tab_cfg\n\t\t\t\t\t, &cp->p_bi_event_cfg\n\t\t\t\t\t, &g_event_que[EN_BI_EVENT].event_ref_tab_item_num) );\n}\n\nINT32 yxRefTabCallback(RefTblCfg *p_ref_tab_cfg)\n{\n\tEvent *cp;\n\n\tcp = p_ref_tab_cfg->p_parent;\n\treturn ( eventRefTabCallback(p_ref_tab_cfg\n\t\t\t\t\t, &cp->p_yx_event_cfg\n\t\t\t\t\t, &g_event_que[EN_YX_EVENT].event_ref_tab_item_num) );\n}\n\n//INT32 soeRefTabCallback(RefTblCfg *p_ref_tab_cfg)\n//{\n//\tUINT16 i;\n//\tINT32 ret;\n//\tINT8 *p_str[5];\n//\tRefParameterItems *p_ref_tab_item;\n//\tSoeEventCfg *p_event_cfg;\n//\tEvent *cp;\n//\n//\tcp = p_ref_tab_cfg->p_parent;\n//\tp_ref_tab_item = p_ref_tab_cfg->p_tbl;\n//\t/*引用表可以不存在，且内容可以为空*/\n//\tif (p_ref_tab_item == NULL || p_ref_tab_item->num == 0)\n//\t{\n//\t\t/*PRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_REF_TAB_NUM_IS_ZERO],\n//\t\t\t\t\tp_ref_tab_cfg->desc, p_ref_tab_info->num);*/\n//\t\treturn 0;\n//\t}\n//\n//\tp_event_cfg = HOPEMALLOC((p_ref_tab_item->num * sizeof(SoeEventCfg)));\n//\tif(p_event_cfg == NULL)\n//\t{\n//\t\tPRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_REF_TAB_PARSE_GET_MEM_ERR]\n//\t\t\t\t\t, p_ref_tab_cfg->desc, errno);\n//\t\treturn -1;\n//\t}\n//\n//\tfor (i=0; i<p_ref_tab_item->num; i++)\n//\t{\n//\t\tret = getSepStrFromRefTblItem(p_ref_tab_item->item[i]\n//\t\t\t\t\t\t\t\t\t\t,':', p_str, 1);\n//\t\tif (ret < 1)\n//\t\t{\n//\t\t\tPRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_REF_TAB_ITEM_FORMAT_ERR]\n//\t\t\t\t\t\t\t,i, p_ref_tab_item->item[i]\n//\t\t\t\t\t\t\t,p_ref_tab_cfg->desc);\n//\t\t\treturn -1;\n//\t\t}\n//\n//\t\tp_event_cfg[i].p_datafield = getSignalOutWithName(p_str[0]);\n//\t\tif (p_event_cfg[i].p_datafield == NULL)\n//\t\t{\n//\t\t\tPRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_GET_DEVICE_SIGNAL_ERR]\n//\t\t\t\t\t\t,i, p_str[0], p_ref_tab_cfg->desc);\n//\t\t\treturn -1;\n//\t\t}\n//\n//\t\tstrcpy(p_event_cfg[i].name, p_str[0]);\n//\t}\n//\n//\tcp->p_soe_event_cfg = p_event_cfg;\n//\tg_event_que[EN_YX_EVENT].event_ref_tab_item_num = p_ref_tab_item->num;\n//\n//\treturn 0;\n//}\n\nINT32 chanChkRefTabCallback(RefTblCfg *p_ref_tab_cfg)\n{\n\tINT32 ret;\n\tINT32 event_type;\n\tUINT32 chan_no;\n\tEvent *cp;\n\n\tcp = p_ref_tab_cfg->p_parent;\n\tchan_no = p_ref_tab_cfg->index-EN_CHAN_A_CHECK_REF_TBL;\n\tif (chan_no >= EVENT_MAX_CHAN_NUM)\n\t\treturn 0;\n\n\tevent_type = EN_CHAN_A_CHK_EVENT + chan_no;\n\tret = eventParaRefTabCallback(p_ref_tab_cfg\n\t\t\t\t\t\t, &cp->p_chan_chk_cfg[chan_no]\n\t\t\t\t\t\t, &g_event_que[event_type].event_ref_tab_item_num);\n\n\tif (g_event_que[event_type].event_ref_tab_item_num > MAX_CHAN_PARA_NUM)\n\t{\n\t\tPRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_REF_TAB_NUM_OVER_MAX]\n\t\t\t\t\t, p_ref_tab_cfg->desc\n\t\t\t\t\t, g_event_que[event_type].event_ref_tab_item_num\n\t\t\t\t\t, MAX_CHAN_PARA_NUM);\n\t\treturn -1;\n\t}\n\n\tif (ret == 0)\n\t\tg_event_que[event_type].para_num = \\\n\t\t\t\tg_event_que[event_type].event_ref_tab_item_num;\n\n\treturn ret;\n}\n\nINT32 chanStatRefTabCallback(RefTblCfg *p_ref_tab_cfg)\n{\n\tINT32 ret;\n\tINT32 event_type;\n\tUINT32 chan_no;\n\tEvent *cp;\n\n\tcp = p_ref_tab_cfg->p_parent;\n\tchan_no = p_ref_tab_cfg->index-EN_CHAN_A_STAT_REF_TBL;\n\tif (chan_no >= EVENT_MAX_CHAN_NUM)\n\t\treturn 0;\n\n\tevent_type = EN_CHAN_A_STAT_EVENT + chan_no;\n\tret = eventParaRefTabCallback(p_ref_tab_cfg\n\t\t\t\t\t\t, &cp->p_chan_stat_cfg[chan_no]\n\t\t\t\t\t\t, &g_event_que[event_type].event_ref_tab_item_num);\n\n\tif (g_event_que[event_type].event_ref_tab_item_num > MAX_CHAN_PARA_NUM)\n\t{\n\t\tPRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_REF_TAB_NUM_OVER_MAX]\n\t\t\t\t\t, p_ref_tab_cfg->desc\n\t\t\t\t\t, g_event_que[event_type].event_ref_tab_item_num\n\t\t\t\t\t, MAX_CHAN_PARA_NUM);\n\t\treturn -1;\n\t}\n\n\tif (ret == 0)\n\t\tg_event_que[event_type].para_num = \\\n\t\t\t\tg_event_que[event_type].event_ref_tab_item_num;\n\n\treturn ret;\n}\n\nINT32 regScanEventCallBack(Event *cp)\n{\n\tINT32 i;\n\tINT32 ret;\n\n\tfor (i=0; i<s_ref_tbl_cfg[EN_TRIP_REF_TBL].p_tbl->num; i++)\n\t{\n\t\tret = insertIvtCallBack((void *)cp->p_trip_event_cfg[i].p_invar\n\t\t\t\t\t\t\t\t,(InCallBackTask)putEventIndexQue\n\t\t\t\t\t\t\t\t,(void *)EN_TRIP_EVENT, i);\n\t\tif (ret != 0)\n\t\t{\n\t\t\tPRINTINFO(ALL_SHOW\n\t\t\t\t\t\t,g_hmi_err_msg[EN_REF_TAB_ITEM_INSERT_IVT_ERR]\n\t\t\t\t\t\t,i, NULL, s_ref_tbl_cfg[EN_TRIP_REF_TBL].desc);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t//注册参数准备好回调函数\n\tif (s_ref_tbl_cfg[EN_TRIP_PARA_READY_REF_TBL].p_tbl != NULL)\n\t{\n\t\tfor (i=0; i<s_ref_tbl_cfg[EN_TRIP_PARA_READY_REF_TBL].p_tbl->num; i++)\n\t\t{\n\t\t\tret = insertIvtCallBack((void *)cp->p_trip_para_ready_cfg[i].p_invar\n\t\t\t\t\t\t\t\t\t,(InCallBackTask)ProcEventParaReady\n\t\t\t\t\t\t\t\t\t,(void *)EN_TRIP_EVENT, i);\n\t\t\tif (ret != 0)\n\t\t\t{\n\t\t\t\tPRINTINFO(ALL_SHOW\n\t\t\t\t\t\t\t,g_hmi_err_msg[EN_REF_TAB_ITEM_INSERT_IVT_ERR]\n\t\t\t\t\t\t\t,i, NULL, s_ref_tbl_cfg[EN_TRIP_PARA_READY_REF_TBL].desc);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i=0; i<s_ref_tbl_cfg[EN_RUN_REF_TBL].p_tbl->num; i++)\n\t{\n\t\tret = insertIvtCallBack((void *)cp->p_run_event_cfg[i].p_invar\n\t\t\t\t\t\t\t,(InCallBackTask)putEventIndexQue\n\t\t\t\t\t\t\t,(void *)EN_RUN_EVENT, i);\n\t\tif (ret != 0)\n\t\t{\n\t\t\tPRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_REF_TAB_ITEM_INSERT_IVT_ERR]\n\t\t\t\t\t\t,i, NULL, s_ref_tbl_cfg[EN_RUN_REF_TBL].desc);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfor (i=0; i<s_ref_tbl_cfg[EN_SELF_CHECK_REF_TBL].p_tbl->num; i++)\n\t{\n\t\tret = insertIvtCallBack((void *)cp->p_check_event_cfg[i].p_invar\n\t\t\t\t\t\t\t,(InCallBackTask)putEventIndexQue\n\t\t\t\t\t\t\t,(void *)EN_CHECK_EVENT, i);\n\t\tif (ret != 0)\n\t\t{\n\t\t\tPRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_REF_TAB_ITEM_INSERT_IVT_ERR]\n\t\t\t\t\t\t,i, NULL, s_ref_tbl_cfg[EN_SELF_CHECK_REF_TBL].desc);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfor (i=0; i<s_ref_tbl_cfg[EN_BINCHG_REF_TBL].p_tbl->num; i++)\n\t{\n\t\tret = insertIvtCallBack((void *)cp->p_bi_event_cfg[i].p_invar\n\t\t\t\t\t\t\t,(InCallBackTask)putEventIndexQue\n\t\t\t\t\t\t\t,(void *)EN_BI_EVENT, i);\n\t\tif (ret != 0)\n\t\t{\n\t\t\tPRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_REF_TAB_ITEM_INSERT_IVT_ERR]\n\t\t\t\t\t\t,i, NULL, s_ref_tbl_cfg[EN_BINCHG_REF_TBL].desc);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfor (i=0; i<s_ref_tbl_cfg[EN_YX_REF_TBL].p_tbl->num; i++)\n\t{\n\t\tret = insertCanIvtCallBack((void *)cp->p_yx_event_cfg[i].p_invar\n\t\t\t\t\t\t\t,(InCallBackTask)putYxEvent\n\t\t\t\t\t\t\t,(void *)cp, i);\n\t\tif (ret != 0)\n\t\t{\n\t\t\tPRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_REF_TAB_ITEM_INSERT_IVT_ERR]\n\t\t\t\t\t\t,i, NULL, s_ref_tbl_cfg[EN_YX_REF_TBL].desc);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid showSignalDesc(DataFields *p_datafield)\n{\n\tprintf(\"%s,%d,%d,%f,%f\\n\",p_datafield->name, p_datafield->type, p_datafield->is_unsigned\n\t\t\t,p_datafield->u_value.float64.norm[0], p_datafield->u_value.float64.norm[1]);\n}\n\nvoid setOneTypeEventInVarSignedType( RefParameterItems *p_ref_tab_item\n                              , EventParaCfg *p_event_para_cfg)\n{\n\tINT32 i;\n\n\tif (p_ref_tab_item != NULL)\n\t{\n\t\tfor (i=0; i<p_ref_tab_item->num; i++)\n\t\t{\n\t\t\tSET_INVAL_SIGNED_TYPE(p_event_para_cfg->p_invar\n\t\t\t\t\t\t\t\t, p_event_para_cfg->p_datafield)\n\t\t\tp_event_para_cfg++;\n\t\t}\n\t}\n\n}\n\nvoid setEventInVarSignedType(Event *cp)\n{\n\tINT32 i;\n\n\tsetOneTypeEventInVarSignedType(s_ref_tbl_cfg[EN_TRIP_PARA_REF_TBL].p_tbl\n\t\t\t\t\t\t\t\t  , cp->p_trip_para_cfg);\n\tsetOneTypeEventInVarSignedType(s_ref_tbl_cfg[EN_RUN_PARA_REF_TBL].p_tbl\n\t\t\t\t\t\t\t\t  , cp->p_run_para_cfg);\n\n\tfor (i=0; i<EVENT_MAX_CHAN_NUM; i++)\n\t{\n\t\tsetOneTypeEventInVarSignedType(s_ref_tbl_cfg[EN_CHAN_A_CHECK_REF_TBL+i].p_tbl\n\t\t\t\t\t\t\t\t\t  , cp->p_chan_chk_cfg[i]);\n\t\tsetOneTypeEventInVarSignedType(s_ref_tbl_cfg[EN_CHAN_A_STAT_REF_TBL+i].p_tbl\n\t\t\t\t\t\t\t\t\t  , cp->p_chan_stat_cfg[i]);\n\t}\n\n\treturn;\n}\n\nINT32 createEventQue(Event *cp,EventType event_type, UINT16 item_size\n\t\t\t\t\t\t, UINT16 with_para, UINT16 para_size\n\t\t\t\t\t\t, UINT16 with_index_que)\n{\n\tEventQue *p_event_que;\n\tUINT32 mem_size,data_size;\n\tINT32 ret;\n\n\tif (event_type >= EN_EVENT_TYPE_NUM)\n\t\treturn -1;\n\n\tp_event_que = &g_event_que[event_type];\n\n\tp_event_que->item_size = item_size;\n\tp_event_que->with_para = with_para;\n\tp_event_que->para_size = para_size;\n\tif (p_event_que->para_size != 0)\n\t\tp_event_que->para_data_size = para_size - sizeof(ParaNode);\n\tp_event_que->with_index_que = with_index_que;\n\n#ifdef INCLUDE_EVENT_SEM\n#if (OS_TYPE == VXWORKS)\n\tp_event_que->sem = hpSemBCreate(SEM_Q_PRIORITY, SEM_FULL);\n\tif (p_event_que->sem == NULL)\n\t{\n\t\tPRINTINFO(ALL_SHOW, s_error_msg[EN_EVENT_QUEUE_CREATE_SEMAPHORE_ERR]\n\t\t\t\t\t, s_event_sram_name[EN_TRIP_EVENT], errno);\n\t\treturn -1;\n\t}\n#endif\n#endif\n\n\tif (p_event_que->with_index_que == 1)\n\t{\n\t\tmem_size = (p_event_que->event_ref_tab_item_num + 1) * \\\n\t\t\t\t\t\tsizeof(EventIndexItem);\n\t\tp_event_que->index_que.p_item = HOPEMALLOC(mem_size);\n\t\tif(p_event_que->index_que.p_item == NULL)\n\t\t{\n\t\t\tPRINTINFO(ALL_SHOW, s_error_msg[EN_EVENT_GET_INDEX_CACHE_MEM_ERR]\n\t\t\t\t\t\t, s_event_sram_name[event_type]);\n\t\t\treturn -1;\n\t\t}\n\n\t\tinitEventIndexQue(p_event_que);\n\t}\n\n\tif (p_event_que->para_ready_tab_num > 0)\n\t{\n\t\tret = createEventParaReady(event_type);\n\t\tif (ret != 0)\n\t\t\treturn -1;\n\t}\n\n\tdata_size = p_event_que->item_size * p_event_que->max_num;\n\tmem_size = sizeof(QueCtrl) + data_size + sizeof(EventParaCtrl) + \\\n\t\t\t\tp_event_que->para_size * p_event_que->para_que_max_num;\n\n\tret = declareSramMem((INT8 *)cp->name,(INT8 *)s_event_sram_name[event_type], mem_size);\n\tif (ret != 0)\n\t{\n\t\tPRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_DECLARE_SRAM_ERR]\n\t\t\t\t\t, s_event_sram_name[event_type]);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nINT32 initEventQueSram(EventType event_type)\n{\n\tEventQue *p_event_que;\n\tUINT32 mem_state,data_size;\n\tINT8 *p_mem,*p_save;\n\n\tif (event_type >= EN_EVENT_TYPE_NUM)\n\t\treturn -1;\n\n\tp_mem = (INT8 *)getSramMem((INT8 *)s_event_sram_name[event_type]\n\t\t\t\t\t\t, &mem_state);\n\n\tif (p_mem == NULL)\n\t{\n\t\tPRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_GET_SRAM_ERR]\n\t\t\t\t\t,s_event_sram_name[event_type]);\n\t\treturn -1;\n\t}\n\n\tp_event_que = &g_event_que[event_type];\n\tdata_size = p_event_que->item_size * p_event_que->max_num;\n\tp_save = p_mem;\n\tif (mem_state == 1)\t/*检查内存配置是否与原来配置相同*/\n\t{\n\t\tp_event_que->p_ctrl = (QueCtrl *) p_mem;\n\t\tif (p_event_que->p_ctrl->max_num == p_event_que->max_num\n\t\t && p_event_que->p_ctrl->para_num == p_event_que->para_num)\n\n\t\t{\n\t\t\tp_mem += sizeof(QueCtrl);\n\t\t\tp_event_que->p_item = p_mem;\n\t\t\tp_mem += data_size;\n\t\t\tif (p_event_que->with_para == 1)\n\t\t\t{\n\t\t\t\tp_event_que->p_para_ctrl = (EventParaCtrl *)p_mem;\n\t\t\t\tp_mem += sizeof(EventParaCtrl);\n\t\t\t\tp_event_que->p_para = p_mem;\n\t\t\t\tif (p_event_que->p_para_ctrl->max_num\n\t\t\t\t\t!= p_event_que->para_que_max_num)\n\t\t\t\t\tmem_state = 0;\t/*参数改变,重新初始化SRAM*/\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tmem_state = 0;\t/*参数改变,重新初始化SRAM*/\n\t}\n\n\t/*mem_state == 1,SRAM原来分配过,并且参数没有改变*/\n\t/*参数改变或SRAM是第一次分配,重新初始化SRAM*/\n\tif (mem_state == 0)\n\t{\n\t\tp_mem = p_save;\n\t\tp_event_que->p_ctrl = (QueCtrl *) p_mem;\n\t\tp_mem += sizeof(QueCtrl);\n\t\tp_event_que->p_ctrl->max_num = p_event_que->max_num;\n\t\tp_event_que->p_ctrl->para_num = p_event_que->para_num;\n\t\tp_event_que->p_item = p_mem;\n\t\tp_mem += data_size;\n\t\tif (p_event_que->with_para == 1)\n\t\t{\n\t\t\tp_event_que->p_para_ctrl = (EventParaCtrl *)p_mem;\n\t\t\tp_mem += sizeof(EventParaCtrl);\n\t\t\tp_event_que->p_para_ctrl->max_num = p_event_que->para_que_max_num;\n\t\t\tp_event_que->p_para = p_mem;\n\t\t}\n\t\tclearEventQue(event_type);\n\t}\n\n\treturn 0;\n}\n\n/*\n * p_que->p_item[0]为头结点\n */\nvoid initEventIndexQue(EventQue *p_event_que)\n{\n\tINT32 i;\n\tEventIndexQue *p_que;\n\n\tif (p_event_que->with_index_que != 1)\n\t\treturn;\n\n\tp_que = &p_event_que->index_que;\n\tif (p_que->p_item == NULL)\n\t\treturn;\n\n\tfor (i=0; i<p_event_que->event_ref_tab_item_num; i++)\n\t\tp_que->p_item[i].next = i+1;\n\n\tp_que->p_item[0].next = EVENT_INVALID_INDEX;\n\tp_que->free = 1;\n\tp_que->p_item[p_event_que->event_ref_tab_item_num].next = \\\n\t\tEVENT_INVALID_INDEX;\n}\n\nvoid clearEventParaReady(EventQue *p_event_que)\n{\n\tINT32 i;\n\n\tfor (i=0;i<p_event_que->max_num;i++)\n\t{\n\t\tp_event_que->p_event_time_count[i] = 0;\n\t}\n\n\tfor (i=0;i<p_event_que->para_ready_tab_num;i++)\n\t{\n\t\tp_event_que->p_para_ready[i].que_index = 0xffff;\n\t}\n}\n\nINT32 createEventParaReady(EventType event_type)\n{\n\tEventQue *p_event_que;\n\tUINT32 mem_size;\n\tUINT8 *p_data;\n\n\tif (event_type >= EN_EVENT_TYPE_NUM)\n\t\treturn -1;\n\tp_event_que = &g_event_que[event_type];\n\n\tmem_size = p_event_que->para_ready_tab_num * sizeof(ParaReadyIndex) + \\\n\t\t\t\t\tp_event_que->max_num * sizeof(UINT16);\n\tp_data = HOPEMALLOC(mem_size);\n\tif (p_data == NULL)\n\t{\n\t\tPRINTINFO(ALL_SHOW, s_error_msg[EN_EVENT_GET_PARA_READY_MEM_ERR],\n\t\t\t\t\ts_event_sram_name[event_type]);\n\t\treturn -1;\n\t}\n\tp_event_que->p_para_ready = (ParaReadyIndex*)p_data;\n\tp_data += p_event_que->para_ready_tab_num * sizeof(ParaReadyIndex);\n\tp_event_que->p_event_time_count = (UINT16*)p_data;\n\n\tclearEventParaReady(p_event_que);\n\n\treturn 0;\n}\n\nvoid clearEventQue(EventType event_type)\n{\n\tINT32 i;\n\tEventQue *p_event_que;\n\tQueCtrl *p_ctrl;\n\tINT8 *p_int8_para;\n\tParaNode *p_para;\n\n\tif (event_type >= EN_EVENT_TYPE_NUM)\n\t\treturn;\n\tp_event_que = &g_event_que[event_type];\n\n#ifdef INCLUDE_EVENT_SEM\n#if (OS_TYPE == VXWORKS)\n\tsemTake(p_event_que->sem, WAIT_FOREVER);\n#endif\n#endif\n\n\tp_ctrl = p_event_que->p_ctrl;\n\tp_ctrl->num = 0;\n\tp_ctrl->write = 0;\n\tp_ctrl->tmp_write = 0;\n\tp_ctrl->no = 0;\n\tfor (i=0; i<MAX_CLIENT_NUM; i++)\n\t{\n\t\tp_ctrl->read[i] = 0;\n\t\tp_ctrl->tmp_read[i] = 0;\n\t}\n\n\tif (p_event_que->with_para == 1)\n\t{\n\t\tp_event_que->p_para_ctrl->write = 0;\n\t\tp_int8_para = p_event_que->p_para;\n\t\tfor (i=0; i<p_event_que->para_que_max_num; i++)\n\t\t{\n\t\t\tp_para = (ParaNode *) p_int8_para;\n\t\t\tp_para->p_event = NULL;\n\t\t\tp_int8_para += p_event_que->para_size;\n\t\t}\n\t}\n\n#ifdef INCLUDE_EVENT_SEM\n#if (OS_TYPE == VXWORKS)\n\tsemGive(p_event_que->sem);\n#endif\n#endif\n\n\tPRINTINFO((LOG_SHOW), s_log_msg[EVENT_CLEAR_SRAM], s_event_sram_name[event_type]);\n\treturn;\n}\n\n/*\n * 由于从SRAM中读取的值,需要检查存储数据的合法性，如读写指针值的范围等\n */\nINT32 checkEventQueCtrl(QueCtrl *p_ctrl)\n{\n\tINT32 i;\n\tINT32 err=0;\n\n\tif (p_ctrl->num > p_ctrl->max_num)\n\t{\n\t\tPRINTINFO(ALL_SHOW, s_error_msg[EN_EVENT_QUEUE_NUM_ERR]\n\t\t\t\t\t, p_ctrl->max_num, p_ctrl->num);\n\t\terr = -1;\n\t}\n\n\tif (p_ctrl->write >= p_ctrl->max_num\n\t || p_ctrl->tmp_write >= p_ctrl->max_num)\n\t{\n\t\tPRINTINFO(ALL_SHOW, s_error_msg[EN_EVENT_QUEUE_WRITE_INDEX_ERR]\n\t\t\t\t\t, p_ctrl->max_num, p_ctrl->write, p_ctrl->tmp_write);\n\t\terr = -1;\n\t}\n\n\tfor (i=0; i<MAX_CLIENT_NUM; i++)\n\t{\n\t\tif (p_ctrl->read[i] >= p_ctrl->max_num)\n\t\t{\n\t\t\tPRINTINFO(ALL_SHOW, s_error_msg[EN_EVENT_QUEUE_CLIENT_READ_INDEX_ERR]\n\t\t\t\t\t\t, i, p_ctrl->max_num, p_ctrl->read[i]);\n\t\t\terr = -1;\n\t\t}\n\n\t\tif (p_ctrl->tmp_read[i] >= p_ctrl->max_num)\n\t\t{\n\t\t\tPRINTINFO(ALL_SHOW, s_error_msg[EN_EVENT_QUEUE_CLIENT_TMP_READ_INDEX_ERR]\n\t\t\t\t\t\t, i, p_ctrl->max_num, p_ctrl->tmp_read[i]);\n\t\t\terr = -1;\n\t\t}\n\t}\n\n\treturn (err);\n}\n\nvoid checkEventQue(EventType event_type)\n{\n\tINT32 err=0;\n\tEventQue *p_event_que;\n\tEventParaCtrl *p_para_ctrl;\n\tQueCtrl *p_ctrl;\n\tUINT16 dif_num;\n\n\tif (event_type >= EN_EVENT_TYPE_NUM)\n\t\treturn;\n\n\tp_event_que = &g_event_que[event_type];\n\terr = checkEventQueCtrl(p_event_que->p_ctrl);\n\n\t//参数未准备好的信号直接入事件队列\n\tif (event_type == EN_TRIP_EVENT)\n\t{\n\t\tp_ctrl = p_event_que->p_ctrl;\n\t\tif (p_ctrl->write != p_ctrl->tmp_write)\n\t\t{\n\t\t\tDIFF_CYCLE_QUE_INDEX(dif_num, p_ctrl->tmp_write\n\t\t\t\t\t\t\t\t\t\t, p_ctrl->max_num, p_ctrl->write);\n\t\t\tp_ctrl->num += dif_num;\n\t\t\tp_ctrl->write = p_ctrl->tmp_write;\n\t\t}\n\n\t\t/*参数准备好超时时间,100ms*/\n\t\tp_event_que->para_ready_time_out_count = \\\n\t\t\t\t\t\tTRIP_PARA_READY_TIME_OUT*rttask_run_freq/1000;\n\t}\n\n\tif (p_event_que->with_para != 1)\n\t\treturn;\n\n\tp_para_ctrl = p_event_que->p_para_ctrl;\n\tif (p_para_ctrl->write > p_para_ctrl->max_num)\n\t{\n\t\tPRINTINFO(ALL_SHOW, s_error_msg[EN_EVENT_QUEUE_PARA_WRITE_INDEX_ERR],\n\t\t\t\t\tp_para_ctrl->max_num, p_para_ctrl->write);\n\t\terr = -1;\n\t}\n\n\tif (err != 0)\n\t{\n\t\tclearEventQue(event_type);\n\t\tPRINTINFO((LOG_SHOW), s_error_msg[EN_EVENT_QUEUE_CHK_SRAM_ERR]\n\t\t\t\t\t\t,s_event_sram_name[event_type]);\n\t}\n\n\treturn;\n}\n\nINT32 initEventQue(Event *cp,EventType event_type)\n{\n\tUINT16 item_size,with_para=0;\n\tUINT16 para_size,para_num;\n\tUINT16 with_index_que;\n\tINT32 ret;\n\n\tpara_size = 0;\n\tif (event_type >= EN_EVENT_TYPE_NUM)\n\t\treturn  -1;\n\n\t/*para_num由引用表读入*/\n\tpara_num = g_event_que[event_type].para_num;\n\tswitch (event_type)\n\t{\n\tcase EN_TRIP_EVENT:\t\t\t/*动作事件*/\n\t\titem_size =  sizeof(TripEventIn);\n\t\tif (para_num != 0)\n\t\t{\n\t\t\twith_para = 1;\n\t\t\tpara_size = sizeof(TripPara) + (para_num - 1) * sizeof(FLOAT32);\n\t\t}\n\t\twith_index_que = 1;\t\t/*需要同时产生事件的序号排序队列*/\n\t\tbreak;\n\tcase EN_RUN_EVENT:\t\t\t/*运行记录*/\n\t\titem_size =  sizeof(ParaEventIn);\n\t\tif (para_num != 0)\n\t\t{\n\t\t\twith_para = 1;\n\t\t\tpara_size = sizeof(OptEventPara) + (para_num - 1) * \\\n\t\t\t\t\t\t\t\t\t\t\tsizeof(INT32);\n\t\t}\n\t\twith_index_que = 1;\t\t/*需要同时产生事件的序号排序队列*/\n\t\tbreak;\n\tcase EN_CHECK_EVENT:\t\t\t/*自检事件*/\n\tcase EN_BI_EVENT:\t\t\t\t/*开关量变位*/\n\t\titem_size =  sizeof(NoParaEvent);\n\t\twith_para = 0;\n\t\twith_index_que = 1;\t\t/*需要同时产生事件的序号排序队列*/\n\t\tbreak;\n\tcase EN_YX_EVENT:\n\t\titem_size =  sizeof(NoParaEvent);\n\t\twith_para = 0;\n\t\twith_index_que = 0;\t\t/*不支持按引用表中的点的序号从小到大排序*/\n\t\tbreak;\n\tcase EN_CHAN_A_CHK_EVENT:\t\t/*通道自检*/\n\tcase EN_CHAN_B_CHK_EVENT:\n\tcase EN_CHAN_C_CHK_EVENT:\n\tcase EN_CHAN_D_CHK_EVENT:\n\t\tif (para_num < 2)\n\t\t\tpara_num = 2;\n\t\titem_size =  sizeof(ChanChkEventIn) + (para_num - 2) * sizeof(INT16);\n\t\titem_size = ((item_size + 3) / 4) * 4;\n\t\twith_para = 0;\n\t\twith_index_que = 0;\t\t/*无同时产生事件的序号排序队列*/\n\t\tbreak;\n\tcase EN_CHAN_A_STAT_EVENT:\t\t/*通道统计*/\n\tcase EN_CHAN_B_STAT_EVENT:\n\tcase EN_CHAN_C_STAT_EVENT:\n\tcase EN_CHAN_D_STAT_EVENT:\n\t\tif (para_num < 1)\n\t\t\tpara_num = 1;\n\t\titem_size =  sizeof(ChanStatEventIn) + (para_num - 1) * sizeof(INT32);\n\t\twith_para = 0;\n\t\twith_index_que = 0;\t\t/*无同时产生事件的序号排序队列*/\n\t\tbreak;\n\tcase EN_ORDER_EVENT:\n\t\titem_size = sizeof(OrderEvent);\n\t\twith_para = 0;\n\t\twith_index_que = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tret = createEventQue(cp, event_type, item_size, with_para, para_size\n\t\t\t\t\t\t\t\t,with_index_que);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tg_event_que[event_type].write_flag = 0;\n\tg_event_que[event_type].new_item_num = 0;\n\n\treturn 0;\n}\n\n/*\n * 事件索引序号入序号号索引队列，非递减排序,\n * p_index_que->p_item[0]为头结点\n */\nvoid putEventIndexQue(EventType event_type, UINT16 index, UINT8 st_val,UINT8 old_val,INT32 s,INT32 ms)\n{\n\tEventQue *p_event_que;\n\tEventIndexQue *p_index_que;\n\tUINT16 free_last,node,pre_node;\n\nprintf(\"[%s, %d]:\\n\", __FUNCTION__, __LINE__);\nprintf(\"event type=%d,index=%d,st_val=%d,g_sys_run_state=%d, rttask_time_count=%d\\n\", \nevent_type, index, st_val,g_sys_run_state,rttask_time_count);\n//\tprintf(\"event type=%d,index=%d,st_val=%d,g_sys_run_state=%d, rttask_time_count=%d\\n\", \n//\tevent_type, index, st_val,g_sys_run_state,rttask_time_count);\n\t//\t等待I/O初始态初始化完成\n\tif (g_sys_run_state == 0 && event_type != EN_RUN_EVENT\n\t && event_type != EN_CHECK_EVENT)\n\t\treturn;\n\n\tif (event_type > EN_RUN_EVENT) /*对带有序号的事件队列有效*/\n\t\treturn;\n\n//\tif (event_type == EN_RUN_EVENT && st_val == 0)\n//\t\treturn;\n\n\tp_event_que = &g_event_que[event_type];\n\n\tif (index >= p_event_que->event_ref_tab_item_num)\n\t{\n\t\tPRINTINFO((LOG_SHOW), s_log_msg[EVENT_ITEM_INDEX_SRAM]\n\t\t\t\t\t, s_event_sram_name[event_type], index);\n\t\treturn;\n\t}\n\n\tp_index_que = &p_event_que->index_que;\n\tif (p_index_que->free == EVENT_INVALID_INDEX)\n\t{\n\t\tPRINTINFO((LOG_SHOW), s_log_msg[EVENT_INDEX_QUE_IS_FULL]\n\t\t\t\t\t\t, s_event_sram_name[event_type], index);\n\t\treturn;\n\t}\n\n\tfree_last = p_index_que->free;\n\tp_index_que->free = p_index_que->p_item[free_last].next;\n\n\tpre_node = 0;\n\tnode = p_index_que->p_item[0].next;\n\twhile(node != EVENT_INVALID_INDEX &&\n\t\t\tp_index_que->p_item[node].index < index)\n\t{\n\t\tpre_node = node;\n\t\tnode = p_index_que->p_item[node].next;\n\t}\n\tp_index_que->p_item[free_last].index = index;\n\tp_index_que->p_item[free_last].st_val = st_val;\n\tp_index_que->p_item[free_last].old_val = old_val;\n\tp_index_que->p_item[free_last].next = p_index_que->p_item[pre_node].next;\n\tp_index_que->p_item[pre_node].next = free_last;\n\n\treturn;\n}\n\n/*\n * 编历事件索引号队列,对于每个节点以参数arg调用函数func,\n * 最后删除处理过的事件索引号队列\n */\nvoid traverseEventIndexQue(EventType event_type, InCallBackTask func,\n\t\t\t\t\t\t\t\tvoid *arg)\n{\n\tEventIndexQue *p_index_que;\n\tUINT16 free,node,pre_node;\n//\tint i;\nINT8 needPrint = 0;\t\t\t\t//需要打印\n\nif (EN_CHECK_EVENT == event_type) \n{\n\tneedPrint = 1;\n\t// printf(\"[func %s ,line %d]: traverse check event\\n\", __FUNCTION__, __LINE__);\n}\nif (EN_RUN_EVENT == event_type) \n{\n\tneedPrint = 1;\n\t// printf(\"[func %s ,line %d]: traverse run event\\n\", __FUNCTION__, __LINE__);\n}\n\n\tp_index_que = &g_event_que[event_type].index_que;\n\n\tnode = p_index_que->p_item[0].next;\n\tif (node == EVENT_INVALID_INDEX)\n\t\treturn;\n\n\tpre_node = 0;\n\twhile (node != EVENT_INVALID_INDEX)\n\t{\nif (1 == needPrint)\nprintf(\"[func %s, line %d]: node is %d, next_node is %d\\n\", __FUNCTION__, __LINE__, node, p_index_que->p_item[node].next);\n\t\tfunc(arg, p_index_que->p_item[node].index, p_index_que->p_item[node].st_val,\n\t\t\tp_index_que->p_item[node].old_val,0,0);\n\t\tpre_node = node;\n\t\tnode = p_index_que->p_item[node].next;\n\t}\n\n\t/*删除处理过的节点*/\n\t//if (pre_node != 0)\n\t{\n\t\tfree = p_index_que->free;\n\t\tp_index_que->p_item[pre_node].next = free;\n\t\tp_index_que->free = p_index_que->p_item[0].next;\n\n\t\tp_index_que->p_item[0].next = EVENT_INVALID_INDEX;\n\t}\n\t\n//\tprintf(\"run ---after: type=%d,free=%d\\n\",event_type,p_index_que->free);\n//\tfor(i=0;i<6;i++)\n//\t{\n//\t\tprintf(\"[%d]:idx=%d,next=%d\\n\",i,p_index_que->p_item[i].index,p_index_que->p_item[i].next);\n//\t}\nif (1 == needPrint)\n{\n\tputchar('\\n');\n\tputchar('\\n');\n\tputchar('\\n');\n}\n\n\treturn;\n}\n\n// 报告写入到SRAM \nvoid putEventQue(EventQue *p_event_que, INT8 *p_data)\n{\n\tINT32\ti;\n\tQueCtrl *p_ctrl;\n\tUINT16 write;\n\tINT8 *p_item;\n\n\tp_ctrl = p_event_que->p_ctrl;\n\n\tGET_CYCLE_QUE_INDEX_INC(write, p_ctrl->write, p_event_que->max_num)\n\nprintf(\"write is %d while p_ctrl->write is %d\\n\", write, p_ctrl->write);\n\n#ifdef INCLUDE_EVENT_SEM\n#if (OS_TYPE == VXWORKS)\n\tsemTake(p_event_que->sem, wait_sem_time);\n#endif\n#endif\n\n\tfor (i=0; i<MAX_CLIENT_NUM; i++)\n\t{\n\t\tif (p_ctrl->read[i] == write)\n\t\t\tCYCLE_QUE_INDEX_INC(p_ctrl->read[i], p_event_que->max_num)\n\t\tif (p_ctrl->tmp_read[i] == write)\n\t\t\tCYCLE_QUE_INDEX_INC(p_ctrl->tmp_read[i], p_event_que->max_num)\n\t}\n\n\t/*若已满，则在写值前数目递减1，删除一个事件，以防止数据写不完整后掉电，事件信息不完整*/\n\tif (p_event_que->p_ctrl->num >= p_event_que->max_num)\n\t\tp_event_que->p_ctrl->num --;\n\n\tp_event_que->write_flag = 1;\n\tp_item = p_event_que->p_item + p_ctrl->write * p_event_que->item_size;\n\tSRAM_CPY(p_item, p_data, p_event_que->item_size);\n\tp_event_que->write_flag = 0;\n\n#ifdef INCLUDE_EVENT_SEM\n#if (OS_TYPE == VXWORKS)\n\tsemGive(p_event_que->sem);\n#endif\n#endif\n\n\tp_event_que->p_ctrl->write = write;\n\tp_event_que->p_ctrl->num++;\n\n\tp_event_que->new_item_num++;\n\n\treturn;\n}\n\n// mode=1 为提供给如IEC103送后台报文全部送完毕后，再确认。\n// 防止中途通信断开后，二次连接多送一遍的情况\nINT32 getRealEventQue(EventQue *p_event_que, UINT32 client_no,\n\t\t\t\t\t\tINT8 *p_data, INT32 mode)\n{\n\tQueCtrl *p_ctrl;\n\tUINT16 read;\n\tINT8 *p_item;\n\n\tif (client_no >= MAX_CLIENT_NUM)\n\t\treturn -1;\n\n\tp_ctrl = p_event_que->p_ctrl;\n\tread = p_ctrl->read[client_no];\n\tif (read == p_ctrl->write)\n\t\treturn -1;\n\n\tif (mode == EN_RTTASK_READ_MODE_ACK)\n\t{\n\t\tread = p_ctrl->tmp_read[client_no];\n\t\tif (read == p_ctrl->write)\n\t\t\tread = p_ctrl->read[client_no];\n\t}\n\tp_item = (p_event_que->p_item + read * p_event_que->item_size);\n\n#ifdef INCLUDE_EVENT_SEM\n#if (OS_TYPE == VXWORKS)\n\tif (semTake(p_event_que->sem, wait_sem_time) == ERROR)\n\t\treturn -1;\n#endif\n#endif\n\n\tSRAM_CPY(p_data, p_item, p_event_que->item_size);\n\n\tCYCLE_QUE_INDEX_INC(read, p_event_que->max_num)\n\n\tif (mode == EN_RTTASK_READ_MODE_NO_ACK)\n\t{\n\t\tp_ctrl->read[client_no] = read;\n\t}\n\telse if (mode == EN_RTTASK_READ_MODE_ACK)\n\t{\n\t\tp_ctrl->tmp_read[client_no] = read;\n\t}\n\n#ifdef INCLUDE_EVENT_SEM\n#if (OS_TYPE == VXWORKS)\n\tsemGive(p_event_que->sem);\n#endif\n#endif\n\n\treturn 0;\n}\n\nLOCAL UINT16 qGetProc(Event *cp, InVar *p_quality_invar)\n{\n\tUINT8 tran_val = 0;\n\t\n\tif(p_quality_invar)\n\t{\n\t\tGET_INVAL_VAL(&tran_val, p_quality_invar);\n\t}\n\n\tif(*(cp->p_in_val[EN_OPT_MONIBLK_IN]))\n\t\treturn tran_val | GOOSE_Q_RX_TEST;\n\telse\n\t\treturn tran_val;\n\t\n\treturn 0;\n}\n\n//#ifdef SRAM_GET_WITH_INT16\nvoid putTripEvent(Event *cp, UINT16 index, UINT8 st_val, UINT8 old_val)\n{\n\tLOCAL UINT16 s_phase_bit_num[] = {0,1,1,2,1,2,2,3};\n\n\tINT32\ti;\n\tQueCtrl *p_ctrl;\n\tUINT16 write,para_no,num;\n\tTripEventIn event,*p_item;\n\tTripPara *p_para;\n\tWithParaEventCfg *p_event_cfg;\n\tUINT16 para_num,para_index,para_ok=0;\n\tEventParaCfg *p_para_cfg;\n\tParaReadyIndex *p_para_ready;\n\tUINT8 phase;\n\tInVar *p_invar;\n\n\tif (index >= g_event_que[EN_TRIP_EVENT].event_ref_tab_item_num)\n\t{\n\t\tPRINTINFO((LOG_SHOW), s_log_msg[EVENT_ITEM_INDEX_SRAM],\n\t\t\t\t\ts_event_sram_name[EN_TRIP_EVENT], index);\n\t\treturn;\n\t}\n\n\tp_event_cfg = &(cp->p_trip_event_cfg[index]);\n\tif (DESC_EVENT_VISIBLE(p_event_cfg->p_datafield)==0)\n\t\treturn;\n\nprintf(\"[%s, %d]: will record trip event\\n\", __FUNCTION__, __LINE__);\n\tp_ctrl = g_event_que[EN_TRIP_EVENT].p_ctrl;\n\tevent.st_val = st_val;\n//\tGET_BIT_INVAL_VAL(&event.st_val,\n//\t\t\t\t\t\tcp->p_trip_event_cfg[index].p_invar);\n\t//只0->1的沿记录参数\n\tif ((event.st_val & 0x01) == 1)\n\t{\n\t\tif (cp->is_main_device_rly == 1)\n\t\t{\n\t\t\tphase = s_phase_bit_num[(event.st_val >> 1) & 0x7];\n\t\t\tif (phase < p_event_cfg->phase_num)\n\t\t\t\treturn;\n\t\t\tp_event_cfg->phase_num = phase;\n\t\t}\n\t\tpara_num = p_event_cfg->para_num;\n\t}\n\telse\n\t{\n\t\tpara_num = 0;\n\t\tif (cp->is_main_device_rly == 1)\n\t\t\tp_event_cfg->phase_num = 0;\n\t}\n\n\tGET_EVENT_TIME(event.t);\n\tevent.no = p_ctrl->no;\t\t\t/*事件序号*/\n\n\tevent.st_no = index;\t\t/*相对于事件引用表的排序号，从0开始*/\n//\tevent.st_val = st_val;\t/*状态值*/\n\tevent.para_num = 0;\t/*参数个数*/\n\t\n\tevent.q = qGetProc(cp, p_event_cfg->p_quality_invar);\t\t\t\t/*品质位*/\n\tevent.fan = g_sram_fan; \t\t/*故障序号*/\n\tevent.fault_no = g_sram_fault_head_que.p_ctrl->no;\t/*整组报告序号*/\n\tFAULT_RELATIVE_TIME(event.ret_ms);\t/*相对时间,相对于本次故障启动时的时间*/\n\n\tif (p_event_cfg->para_ready_index >= g_event_que[EN_TRIP_EVENT].para_ready_tab_num)\n\t\tpara_ok = 1;\n\t/*写入参数*/\n\tif (para_ok == 1)\n\t{\n\t\tif (para_num != 0)\n\t\t{\n\t\t\tfor (i=0; i<para_num; i++)\n\t\t\t{\n\t\t\t\tpara_index = p_event_cfg->para_index[i];\n\t\t\t\t//if (para_index < g_event_que[EN_RUN_EVENT].para_ref_tab_item_num)\n\t\t\t\tp_para_cfg = &cp->p_trip_para_cfg[para_index];\n\t\t\t\t/*GET_INVAL_REAL_VAL(&cp->p_event_para_mem[i], p_para_cfg->p_invar,\n\t\t\t\t\t\t\t\tp_para_cfg->p_datafield);*/\n\t\t\t\tp_invar = p_para_cfg->p_invar;\n\t\t\t\tif( (p_invar->comm.comm_way==HBUS1_WAY || p_invar->comm.comm_way==HBUS2_WAY) && (p_invar->comm.is_nrt==0) && (p_invar->comm.type!=BITS_TYPE) )\n\t\t\t\t\tformFaultInfoDataFromWaveBuf((FLOAT32*)&cp->p_event_para_mem[i], p_invar);\n\t\t\t\telse\n\t\t\t\t\tGET_INVAL_VAL(&cp->p_event_para_mem[i], p_invar);\n\t\t\t}\n\t\t}\n\n\t\tif (p_event_cfg->phase_index != 0xffff)\n\t\t{\n\t\t\tpara_index = p_event_cfg->phase_index;\n\t\t\tGET_BIT_INVAL_VAL(&phase,\n\t\t\t\tcp->p_trip_para_cfg[para_index].p_invar);\n\t\t\tevent.st_val |= (phase << 1);\n\t\t}\n\t}\n\n\tGET_CYCLE_QUE_INDEX_INC(write, p_ctrl->tmp_write,\n\t\t\t\t\t\t\t\tg_event_que[EN_TRIP_EVENT].max_num)\n\n#ifdef INCLUDE_EVENT_SEM\n#if (OS_TYPE == VXWORKS)\n\tsemTake(g_event_que[EN_TRIP_EVENT].sem, wait_sem_time);\n#endif\n#endif\n\n\tfor (i=0; i<MAX_CLIENT_NUM; i++)\n\t{\n\t\tif (p_ctrl->read[i] == write)\n\t\t\tCYCLE_QUE_INDEX_INC(p_ctrl->read[i], g_event_que[EN_TRIP_EVENT].max_num)\n\t\tif (p_ctrl->tmp_read[i] == write)\n\t\t\tCYCLE_QUE_INDEX_INC(p_ctrl->tmp_read[i],\n\t\t\t\t\t\t\t\t\tg_event_que[EN_TRIP_EVENT].max_num)\n\t}\n\n\tg_event_que[EN_TRIP_EVENT].write_flag = 1;\n\t/*在写值前数目递减1，删除一个事件，以防止数据写不完整后掉电，事件信息不完整*/\n\tif (p_ctrl->tmp_write >= p_ctrl->write)\n\t\tnum = p_ctrl->tmp_write - p_ctrl->write;\n\telse\n\t\tnum = g_event_que[EN_TRIP_EVENT].max_num - p_ctrl->write + p_ctrl->tmp_write;\n\tif (p_ctrl->num + num >= g_event_que[EN_TRIP_EVENT].max_num)\n\t\t\tp_ctrl->num --;\n\n\tp_item = (TripEventIn *) (g_event_que[EN_TRIP_EVENT].p_item + \\\n\t\t\t\t\t\tp_ctrl->tmp_write * g_event_que[EN_TRIP_EVENT].item_size);\n\n\t/*得到一个空闲参数块*/\n\tif (para_num != 0)\n\t{\n\t\tpara_no = g_event_que[EN_TRIP_EVENT].p_para_ctrl->write;\n\t\tp_para = (TripPara *) (g_event_que[EN_TRIP_EVENT].p_para + \\\n\t\t\t\t\t\t\t\tpara_no * g_event_que[EN_TRIP_EVENT].para_size);\n\t\tif (p_para->p_event != NULL && p_para->p_event->para_no == para_no)\n\t\t\tp_para->p_event->para_no = EVENT_PARA_INVALID_IDX;\n\n\t\tif (para_ok == 1)\n\t\t{\n\t\t\tSRAM_CPY(p_para->val, cp->p_event_para_mem,\n\t\t\t\t\t\tpara_num*sizeof(INT32));\n\t\t\tevent.para_is_ready = 1;\n\t\t\tevent.para_num = para_num;\n\t\t\tif (p_ctrl->tmp_write != p_ctrl->write)\n\t\t\t\tpara_ok = 0;\n\t\t}\n\t\telse\t//等待参数准备好\n\t\t{\n\t\t\tevent.para_is_ready = 0;\n\t\t\tp_para_ready =\n\t\t\t\t&g_event_que[EN_TRIP_EVENT].p_para_ready[p_event_cfg->para_ready_index];\n\t\t\tp_para_ready->event_index = index;\n\t\t\tp_para_ready->que_index = p_ctrl->tmp_write;\n\t\t\tp_para_ready->p_event = p_item;\n\t\t\tg_event_que[EN_TRIP_EVENT].p_event_time_count[p_para_ready->que_index ] = \\\n\t\t\t\t\t\t\tg_event_que[EN_TRIP_EVENT].para_ready_time_out_count;\n#ifdef INCLUDE_EVENT_PARA_READY_DEBUG\n\t\t\tprintf(\"ready=%d,temp=%d,t=%d\\n\",p_event_cfg->para_ready_index,\n\t\t\t\t\tp_ctrl->tmp_write,\n\t\t\t\t\tg_event_que[EN_TRIP_EVENT].p_event_time_count[p_para_ready->que_index]);\n#endif\n\t\t}\n\t\tp_para->p_event = p_item;\n\t\tGET_CYCLE_QUE_INDEX_INC(g_event_que[EN_TRIP_EVENT].p_para_ctrl->write,\n\t\t\t\t\t\t\t\t\tpara_no,\n\t\t\t\t\t\t\t\t\tg_event_que[EN_TRIP_EVENT].para_que_max_num)\n\t\tevent.para_no = para_no;\t/*指向动作时故障参数区的索引,参数值个数可配置*/\n\t}\n\telse\n\t{\n\t\tevent.para_no = EVENT_PARA_INVALID_IDX;\n\t\tevent.para_is_ready = 1;\n\t\tif (p_ctrl->tmp_write != p_ctrl->write)\n\t\t\tpara_ok = 0;\n\t\telse\n\t\t\tpara_ok = 1;\n\t}\n\n\tSRAM_CPY(p_item, &event, g_event_que[EN_TRIP_EVENT].item_size);\n\n\tg_event_que[EN_TRIP_EVENT].write_flag = 0;\n\n#ifdef INCLUDE_EVENT_SEM\n#if (OS_TYPE == VXWORKS)\n\tsemGive(g_event_que[EN_TRIP_EVENT].sem);\n#endif\n#endif\n\n\tp_ctrl->tmp_write = write;\n\tif (para_ok == 1)\n\t{\n\t\tp_ctrl->write = write;\n\t\tp_ctrl->num++;\n\t\tg_event_que[EN_TRIP_EVENT].new_item_num++;\n\t}\n#ifdef INCLUDE_EVENT_PARA_READY_DEBUG\n\tprintf(\"temp=%d,wt=%d,para=%d\\n\", p_ctrl->tmp_write, p_ctrl->write,event.para_num);\n#endif\n\tp_ctrl->no++;\n\tp_ctrl->no &= EVENT_MAX_BIT_MASK;\n\treturn;\n}\n//#else\n//void putTripEvent(Event *cp, UINT16 index, UINT8 st_val)\n//{\n//\tINT32\ti;\n//\tQueCtrl *p_ctrl;\n//\tUINT16 write,para_no,num;\n//\tTripEventIn *p_item;\n//\tTripPara *p_para=NULL;\n//\tWithParaEventCfg *p_event_cfg;\n//\tUINT16 para_num,para_index;\n//\tEventParaCfg *p_para_cfg;\n//\n//\tif (index >= g_event_que[EN_TRIP_EVENT].event_ref_tab_item_num)\n//\t{\n//\t\tPRINTINFO((LOG_SHOW), s_log_msg[EVENT_ITEM_INDEX_SRAM],\n//\t\t\t\t\ts_event_sram_name[EN_TRIP_EVENT], index);\n//\t\treturn;\n//\t}\n//\n//\tp_event_cfg = &(cp->p_trip_event_cfg[index]);\n//\tif (DESC_EVENT_VISIBLE(p_event_cfg->p_datafield)==0)\n//\t\treturn;\n//\n//\tprintf(\"++++++++putTripEvent: %s:index=%d\\n\", s_event_sram_name[EN_TRIP_EVENT], index);\n//\tp_ctrl = g_event_que[EN_TRIP_EVENT].p_ctrl;\n//\n//\tGET_CYCLE_QUE_INDEX_INC(write, p_ctrl->write, g_event_que[EN_TRIP_EVENT].max_num)\n//\n//\tp_event_cfg = &(cp->p_trip_event_cfg[index]);\n//\tpara_num = p_event_cfg->para_num;\n//\n//#ifdef INCLUDE_EVENT_SEM\n//#if (OS_TYPE == VXWORKS)\n//\tsemTake(g_event_que[EN_TRIP_EVENT].sem, wait_sem_time);\n//#endif\n//#endif\n//\n//\tfor (i=0; i<MAX_CLIENT_NUM; i++)\n//\t{\n//\t\tif (p_ctrl->read[i] == write)\n//\t\t\tCYCLE_QUE_INDEX_INC(p_ctrl->read[i], g_event_que[EN_TRIP_EVENT].max_num)\n//\t\tif (p_ctrl->tmp_read[i] == write)\n//\t\t\tCYCLE_QUE_INDEX_INC(p_ctrl->tmp_read[i],\n//\t\t\t\t\t\t\t\t\tg_event_que[EN_TRIP_EVENT].max_num)\n//\t}\n//\n//\tg_event_que[EN_TRIP_EVENT].write_flag = 1;\n//\t/*得到一个空闲参数块*/\n//\tif (para_num != 0)\n//\t{\n//\t\tpara_no = g_event_que[EN_TRIP_EVENT].p_para_ctrl->write;\n//\t\tp_para = (TripPara *) (g_event_que[EN_TRIP_EVENT].p_para + \\\n//\t\t\t\t\t\t\t\tpara_no * g_event_que[EN_TRIP_EVENT].para_size);\n//\t\tif (p_para->p_event != NULL && p_para->p_event->para_no == para_no)\n//\t\t\tp_para->p_event->para_no = EVENT_PARA_INVALID_IDX;\n//\n//\t\t/*写入参数*/\n//\t\tfor (i=0; i<para_num; i++)\n//\t\t{\n//\t\t\tpara_index = p_event_cfg->para_index[i];\n//\t\t\t//if (para_index < g_event_que[EN_RUN_EVENT].para_ref_tab_item_num)\n//\t\t\tp_para_cfg = &cp->p_trip_para_cfg[para_index];\n//\t\t\t/*GET_INVAL_REAL_VAL(&p_para->val[i], p_para_cfg->p_invar,\n//\t\t\t\t\t\t\tp_para_cfg->p_datafield);*/\n//\t\t\tGET_INVAL_VAL(&p_para->val[i], p_para_cfg->p_invar);\n//\t\t}\n//\t}\n//\telse\n//\t\tpara_no = EVENT_PARA_INVALID_IDX;\n//\n//\t/*在写值前数目递减1，删除一个事件，以防止数据写不完整后掉电，事件信息不完整*/\n//\tif (p_ctrl->tmp_write >= p_ctrl->write)\n//\t\tnum = p_ctrl->tmp_write - p_ctrl->write;\n//\telse\n//\t\tnum = g_event_que[EN_TRIP_EVENT].max_num - p_ctrl->write + p_ctrl->tmp_write;\n//\n//\tif (p_ctrl->num + num >= g_event_que[EN_TRIP_EVENT].max_num)\n//\t\tp_ctrl->num --;\n//\n//\tp_item = (TripEventIn *) (g_event_que[EN_TRIP_EVENT].p_item + \\\n//\t\t\t\t\t\t\tp_ctrl->write * g_event_que[EN_TRIP_EVENT].item_size);\n//\n//\tGET_EVENT_TIME(p_item->t);\n//\n//\tp_item->no = p_ctrl->no;\t\t\t/*事件序号*/\n//\tp_ctrl->no++;\n//\tp_ctrl->no &= EVENT_MAX_BIT_MASK;\n//\n//\tp_item->st_no = index;\t\t/*相对于事件引用表的排序号，从0开始*/\n//\tGET_BIT_INVAL_VAL(&p_item->st_val,\n//\t\t\t\t\tcp->p_trip_event_cfg[index].p_invar); /*状态值*/\n//\tp_item->para_num = para_num;\t/*参数个数*/\n//\tp_item->q = 0;\t\t\t\t/*品质位*/\n//\tp_item->fan = g_sram_fan; \t\t/*故障序号*/\n//\tp_item->fault_no = g_sram_fault_head_que.p_ctrl->no;\t/*整组报告序号*/\n//\n//\tFAULT_RELATIVE_TIME(p_item->ret_ms);\t/*相对时间,相对于本次故障启动时的时间*/\n//\n//\tif (para_no != EVENT_PARA_INVALID_IDX)\n//\t{\n//\t\tp_para->p_event = p_item;\n//\t\tGET_CYCLE_QUE_INDEX_INC(g_event_que[EN_TRIP_EVENT].p_para_ctrl->write,\n//\t\t\t\t\t\t\t\tpara_no,\n//\t\t\t\t\t\t\t\tg_event_que[EN_TRIP_EVENT].para_que_max_num)\n//\t}\n//\tp_item->para_no = para_no;\t/*指向动作时故障参数区的索引,参数值个数可配置*/\n//\n//\tg_event_que[EN_TRIP_EVENT].write_flag = 0;\n//\n//#ifdef INCLUDE_EVENT_SEM\n//#if (OS_TYPE == VXWORKS)\n//\tsemGive(g_event_que[EN_TRIP_EVENT].sem);\n//#endif\n//#endif\n//\n//\tp_ctrl->write = write;\n//\tp_ctrl->num++;\n//\n//\tg_event_que[EN_TRIP_EVENT].new_item_num++;\n//\t\n//\tprintf(\"++++++++ p_ctrl->num=%d, write=%d\\n\", p_ctrl->num, p_ctrl->write);\n//\t\n//\treturn;\n//}\n//#endif\n\nvoid ProcEventParaReady(EventType event_type, UINT16 index, UINT8 st_val,UINT8 old_val,INT32 s,INT32 ms)\n{\n\tINT32\ti;\n\tEventQue *p_event_que;\n\tQueCtrl *p_ctrl;\n\tEventParaCfg *p_para_cfg;\n\tWithParaEventCfg *p_event_cfg;\n\tParaReadyIndex *p_para_ready;\n\tUINT16 para_num,para_index;\n\tTripPara *p_para;\n\tTripEventIn *p_item;\n\tUINT16 write,tmp_write,num,phase_int16=0;\n\tUINT8 phase=0;\n\tEvent *cp;\n\tInVar *p_invar;\n\n\tif (st_val == 0)\n\t\treturn;\n\n\tp_event_que = &g_event_que[EN_TRIP_EVENT];\n\tif (index >= p_event_que->para_ready_tab_num)\n\t\treturn;\n\n\tp_para_ready = &p_event_que->p_para_ready[index];\n\t// p_para_ready->event_index项应先由 TRIP条目先形成时写入，再等待参数有效\n\tif (p_para_ready->que_index == 0xffff ||\n\t\tp_para_ready->event_index >= p_event_que->event_ref_tab_item_num)\n\t\treturn;\n\n\tcp = getGpEvent();\n\t// p_para_ready->p_event 也先由 TRIP条目先形成时写入\n\tp_event_cfg = &(cp->p_trip_event_cfg[p_para_ready->event_index]);\n\tp_item = p_para_ready->p_event;\n\n\tif (p_event_cfg->phase_index != 0xffff)\n\t{\n\t\tpara_index = p_event_cfg->phase_index;\n\t\tGET_BIT_INVAL_VAL(&phase,\n\t\t\tcp->p_trip_para_cfg[para_index].p_invar);\n\t\tphase_int16 = phase;\n\t\tphase_int16 <<= 9;\n\t}\n\t//参数块有可能被其他新事件占用\n\tif (p_item->para_no != EVENT_PARA_INVALID_IDX)\n\t{\n\t\tpara_num = p_event_cfg->para_num;\n\n\t\tfor (i=0; i<para_num; i++)\n\t\t{\n\t\t\tpara_index = p_event_cfg->para_index[i];\n\t\t\tp_para_cfg = &cp->p_trip_para_cfg[para_index];\n\t\t\t/*GET_INVAL_REAL_VAL(&cp->p_event_para_mem[i],\n\t\t\t\t\t\t\t\tp_para_cfg->p_invar, p_para_cfg->p_datafield);*/\n\t\t\tp_invar = p_para_cfg->p_invar;\n\t\t\tif( (p_invar->comm.comm_way==HBUS1_WAY || p_invar->comm.comm_way==HBUS2_WAY) && (p_invar->comm.is_nrt==0) && (p_invar->comm.type!=BITS_TYPE) )\n\t\t\t\tformFaultInfoDataFromWaveBuf((FLOAT32*)&cp->p_event_para_mem[i], p_invar);\n\t\t\telse\n\t\t\t\tGET_INVAL_VAL(&cp->p_event_para_mem[i], p_invar);\n\n\t\t}\n\n\t\tp_para = (TripPara *) (p_event_que->p_para + \\\n\t\t\t\t\t\t\t\t\tp_item->para_no * p_event_que->para_size);\n\t\tSRAM_CPY(p_para->val, cp->p_event_para_mem,\n\t\t\t\t\t\t\tpara_num * sizeof(INT32));\n\t\t//SRAM必须按照16BIT宽度操作\n\n\t\tpara_index = *((UINT16 *)&p_item->st_val);\n\t\tpara_index |= para_num;\n\t\tpara_index |= phase_int16;\n\t\t*((UINT16 *)&p_item->st_val) = para_index;\n\t}\n\telse\n\t{\n\t\tif (p_event_cfg->phase_index != 0xffff)\n\t\t{\n\t\t\tpara_index = *((UINT16 *)&p_item->st_val);\n\t\t\tpara_index |= phase_int16;\n\t\t\t*((UINT16 *)&p_item->st_val) = para_index;\n\t\t}\n\t}\n\n\tp_item->para_is_ready = 1;\n\tp_ctrl = p_event_que->p_ctrl;\n\twrite = p_ctrl->write;\n#ifdef INCLUDE_EVENT_PARA_READY_DEBUG\n\tprintf(\"ready:%d,wt=%d\\n\",index,write);\n#endif\n\tif (p_para_ready->que_index != write)\n\t{\n\t\tp_para_ready->que_index = 0xffff;\n\t\treturn;\n\t}\n\n\tp_para_ready->que_index = 0xffff;\n\tnum = 0;\n\tCYCLE_QUE_INDEX_INC(write, p_event_que->max_num)\n\tnum ++;\n\ttmp_write = p_event_que->p_ctrl->tmp_write;\n\twhile (write != tmp_write)\n\t{\n\t\tp_item = (TripEventIn *) (p_event_que->p_item + \\\n\t\t\t\t\t\t\t\t\twrite * p_event_que->item_size);\n\t\tif (p_item->para_is_ready != 1)\n\t\t\tbreak;\n\n\t\tCYCLE_QUE_INDEX_INC(write, p_event_que->max_num)\n\t\tnum ++;\n\t}\n\n\tp_ctrl->num += num;\n\tp_event_que->new_item_num += num;\n\tp_ctrl->write = write;\n\n\treturn;\n}\n\nvoid scanEventParaReadyTimeOut(Event *cp)\n{\n\tEventQue *p_event_que;\n\tQueCtrl *p_ctrl;\n\tUINT16 tmp_write,write,para_ok=0,index;\n\tTripEventIn *p_item;\n\n\tp_event_que = &g_event_que[EN_TRIP_EVENT];\n\tp_ctrl = p_event_que->p_ctrl;\n\twrite = p_ctrl->write;\n\ttmp_write = p_ctrl->tmp_write;\n\n\tif (write == tmp_write)\n\t\treturn;\n\n\twhile (write != tmp_write)\n\t{\n\t\tp_item = (TripEventIn *) (p_event_que->p_item + \\\n\t\t\t\t\t\t\twrite * p_event_que->item_size);\n\t\tif (p_item->para_is_ready == 0 &&\n\t\t\t--p_event_que->p_event_time_count[write] == 0)\n\t\t{\n\t\t\tp_item->para_is_ready = 1;\n\t\t\tpara_ok = 1;\n\t\t\tindex = cp->p_trip_event_cfg[p_item->st_no].para_ready_index;\n\t\t\tp_event_que->p_para_ready[index].que_index = 0xffff;\n#ifdef INCLUDE_EVENT_PARA_READY_DEBUG\n\t\t\tprintf(\"ready %d time out,wt=%d\\n\",index, write);\n#endif\n\t\t}\n\t\tCYCLE_QUE_INDEX_INC(write, p_event_que->max_num)\n\t}\n\n\tif (para_ok == 0)\n\t\treturn;\n\n\tpara_ok = 0;\n\twrite = p_ctrl->write;\n\twhile (write != tmp_write)\n\t{\n\t\tp_item = (TripEventIn *) (p_event_que->p_item + \\\n\t\t\t\t\t\t\t\t\twrite * p_event_que->item_size);\n\t\tif (p_item->para_is_ready != 1)\n\t\t\tbreak;\n\n\t\tCYCLE_QUE_INDEX_INC(write, p_event_que->max_num)\n\t\tpara_ok ++;\n\t}\n\n\tp_ctrl->num += para_ok;\n\tp_event_que->new_item_num += para_ok;\n\tp_ctrl->write = write;\n\n\treturn;\n}\n\n// mode: 1-使用tmp_read，否则使用read\nINT32 getRealTripEvent(UINT32 client_no, EventData *p_data, INT32 mode)\n{\n\tQueCtrl *p_ctrl;\n\tUINT16 read,para_no;\n\tTripEventIn *p_item;\n\tINT8 *p_para;\n\tWithParaEventCfg *p_event_cfg;\n\tEvent *cp;\n\n\tif (client_no >= MAX_CLIENT_NUM)\n\t\treturn -1;\n\n\tp_ctrl = g_event_que[EN_TRIP_EVENT].p_ctrl;\n\tread = p_ctrl->read[client_no];\n\tif (read == p_ctrl->write)\n\t\treturn -1;\n\n\tcp = getGpEvent();\n\tif (mode == EN_RTTASK_READ_MODE_ACK)\n\t{\n\t\tread = p_ctrl->tmp_read[client_no];\n\t\tif (read == p_ctrl->write)\n\t\t\tread = p_ctrl->read[client_no];\n\t}\n\n\tp_item = (TripEventIn *) (g_event_que[EN_TRIP_EVENT].p_item + \\\n\t\t\t\t\t\t\tread * g_event_que[EN_TRIP_EVENT].item_size);\n#ifdef INCLUDE_EVENT_SEM\n#if (OS_TYPE == VXWORKS)\n\tif (semTake(g_event_que[EN_TRIP_EVENT].sem, wait_sem_time) == ERROR)\n\t\treturn -1;\n#endif\n#endif\n\n\tSRAM_CPY((void *)&p_data->data, p_item, sizeof(TripEventIn));\n\n\t//p_event_cfg = &(cp->p_trip_event_cfg[p_item->st_no]);\n\tp_event_cfg = &(cp->p_trip_event_cfg[p_data->data.trip.st_no]);\n\t//p_data->para_num = p_event_cfg->para_num;\n\tp_data->para_num = p_item->para_num;\n\tp_data->type = EN_TRIP_EVENT;\n\n\t/*读出参数*/\n\tpara_no = p_item->para_no;\n\tif (para_no < g_event_que[EN_TRIP_EVENT].para_que_max_num)\n\t{\n\t\tp_para = (g_event_que[EN_TRIP_EVENT].p_para + sizeof(ParaNode) + \\\n\t\t\t\t\tpara_no * g_event_que[EN_TRIP_EVENT].para_size);\n\t\tmemcpy(p_data->data.trip.para_no, p_event_cfg->para_index,\n\t\t\t\t(p_data->para_num << 1));\n\t\tSRAM_CPY(p_data->data.trip.val, p_para, (p_data->para_num << 2));\n\t}\n\telse\n\t{\n\t\tp_data->data.trip.para_num = 0;\n\t\tp_data->para_num = 0;\n\t}\n\n\tCYCLE_QUE_INDEX_INC(read, g_event_que[EN_TRIP_EVENT].max_num)\n\tif (mode == EN_RTTASK_READ_MODE_NO_ACK)\n\t{\n\t\tp_ctrl->read[client_no] = read;\n\t}\n\telse if (mode == EN_RTTASK_READ_MODE_ACK)\n\t{\n\t\tp_ctrl->tmp_read[client_no] = read;\n\t}\n\n#ifdef INCLUDE_EVENT_SEM\n#if (OS_TYPE == VXWORKS)\n\tsemGive(g_event_que[EN_TRIP_EVENT].sem);\n#endif\n#endif\n\n\treturn 0;\n}\n\nINT32 getHisTripEvent(UINT16 read, EventData *p_data)\n{\n\tUINT16 para_no;\n\tTripEventIn *p_item;\n\tINT8 *p_para;\n\tWithParaEventCfg *p_event_cfg;\n\tEvent *cp;\n\n\tcp = getGpEvent();\n\tp_item = (TripEventIn *) (g_event_que[EN_TRIP_EVENT].p_item + \\\n\t\t\t\t\t\t\tread * g_event_que[EN_TRIP_EVENT].item_size);\n\n#ifdef INCLUDE_EVENT_SEM\n#if (OS_TYPE == VXWORKS)\n\tif (semTake(g_event_que[EN_TRIP_EVENT].sem, wait_sem_time) == ERROR)\n\t\treturn -1;\n#endif\n#endif\n\n\tSRAM_CPY((void *)&p_data->data, p_item, sizeof(TripEventIn));\n\tp_event_cfg = &(cp->p_trip_event_cfg[p_data->data.trip.st_no]);\n\t//p_data->para_num = p_event_cfg->para_num;\n\tp_data->para_num = p_item->para_num;\n\n\t/*读出参数*/\n\tpara_no = p_item->para_no;\n\tif (para_no < g_event_que[EN_TRIP_EVENT].para_que_max_num)\n\t{\n\t\tp_para = (g_event_que[EN_TRIP_EVENT].p_para + sizeof(ParaNode) + \\\n\t\t\t\t\tpara_no * g_event_que[EN_TRIP_EVENT].para_size);\n\t\tmemcpy(p_data->data.trip.para_no, p_event_cfg->para_index,\n\t\t\t\t(p_data->para_num << 1));\n\t\tSRAM_CPY(p_data->data.trip.val, p_para, (p_data->para_num << 2));\n\t}\n\telse\n\t{\n\t\tp_data->data.trip.para_num = 0;\n\t\tp_data->para_num = 0;\n\t}\n\n#ifdef INCLUDE_EVENT_SEM\n#if (OS_TYPE == VXWORKS)\n\tsemGive(g_event_que[EN_TRIP_EVENT].sem);\n#endif\n#endif\n\n\treturn 0;\n}\n\n//#ifdef SRAM_GET_WITH_INT16\nvoid putRunEvent(Event *cp, UINT16 index, UINT8 st_val, UINT8 old_val)\n{\n\tINT32\ti;\n\tQueCtrl *p_ctrl;\n\tUINT16 write,para_no;\n\tParaEventIn event,*p_item;\n\tOptEventPara *p_para;\n\tUINT16 para_num,para_index,para_size;\n\tWithParaEventCfg *p_event_cfg;\n\tEventParaCfg *p_para_cfg;\n\tInVar *p_invar;\n\n//\tprintf(\"---putRunEvent,index=%d,st_val=%d\\n\",index,st_val);\n\tif (index >= g_event_que[EN_RUN_EVENT].event_ref_tab_item_num)\n\t{\n\t\tPRINTINFO((LOG_SHOW), s_log_msg[EVENT_ITEM_INDEX_SRAM],\n\t\t\t\t\ts_event_sram_name[EN_RUN_EVENT], index);\n\t\treturn;\n\t}\n\n\tp_event_cfg = &(cp->p_run_event_cfg[index]);\n\tif (DESC_EVENT_VISIBLE(p_event_cfg->p_datafield)==0)\n\t\treturn;\n\nprintf(\"[%s, %d]: will record run event\\n\", __FUNCTION__, __LINE__);\nprintf(\"---putRunEvent,index = %d, st_val = %d, old_value = %d\\n\", index, st_val, old_val);\nprintf(\"the index indicates the offset from reft able\\n\");\n\n\tp_ctrl = g_event_que[EN_RUN_EVENT].p_ctrl;\n\tpara_num = p_event_cfg->para_num;\n\n\tGET_EVENT_TIME(event.t);\n\n\tevent.no = p_ctrl->no;\t\t\t/*事件序号*/\n\n\tevent.st_no = index;\t\t\t/*相对于事件引用表的排序号，从0开始*/\n\tevent.st_val = st_val;\t\t/*状态值*/\nprintf(\"---putRunEvent, event.no = %d\\n\", p_ctrl->no);\n//\tGET_BIT_INVAL_VAL(&event.st_val,\n//\t\t\t\t\t\tcp->p_run_event_cfg[index].p_invar);\n\tif (event.st_val != 0)\n\t\tevent.st_val = 1;\n\n\tevent.para_num = para_num;\t/*参数个数*/\nprintf(\"[%s, %d]: para_num is %d\\n\", __FUNCTION__, __LINE__, para_num);\n\t/*写入参数*/\n\tfor (i=0; i<para_num; i++)\n\t{\n\t\tpara_index = p_event_cfg->para_index[i];\n\t\t//if (para_index < g_event_que[EN_RUN_EVENT].para_ref_tab_item_num)\n\t\tp_para_cfg = &cp->p_run_para_cfg[para_index];\n\t\t/*GET_INVAL_REAL_VAL(&cp->p_event_para_mem[i], p_para_cfg->p_invar,\n\t\t\t\t\t\t\t\tp_para_cfg->p_datafield);*/\n\t\tp_invar = p_para_cfg->p_invar;\n\t\tif( (p_invar->comm.comm_way==HBUS1_WAY || p_invar->comm.comm_way==HBUS2_WAY) && (p_invar->comm.is_nrt==0) && (p_invar->comm.type!=BITS_TYPE) )\n\t\t{\nprintf(\"[%s, %d]\\n\", __FUNCTION__, __LINE__);\n\t\t\tformFaultInfoDataFromWaveBuf((FLOAT32*)&cp->p_event_para_mem[i], p_invar);\n\t\t}\n\t\telse\n\t\t{\nprintf(\"[%s, %d]\\n\", __FUNCTION__, __LINE__);\n\t\t\tGET_INVAL_VAL(&cp->p_event_para_mem[i], p_invar);\n\t\t}\n\t}\n\tpara_size = para_num * sizeof(INT32);\n\n\tGET_CYCLE_QUE_INDEX_INC(write, p_ctrl->write, g_event_que[EN_RUN_EVENT].max_num)\n#ifdef INCLUDE_EVENT_SEM\n#if (OS_TYPE == VXWORKS)\n\tsemTake(g_event_que[EN_RUN_EVENT].sem, wait_sem_time);\n#endif\n#endif\n\nprintf(\"write is %d while p_ctrl->write is %d\\n\", write, p_ctrl->write);\n\tfor (i=0; i<MAX_CLIENT_NUM; i++)\n\t{\n\t\tif (p_ctrl->read[i] == write)\n\t\t\tCYCLE_QUE_INDEX_INC(p_ctrl->read[i], g_event_que[EN_RUN_EVENT].max_num)\n\t\tif (p_ctrl->tmp_read[i] == write)\n\t\t\tCYCLE_QUE_INDEX_INC(p_ctrl->tmp_read[i]\n\t\t\t\t\t\t\t\t\t, g_event_que[EN_RUN_EVENT].max_num)\n\t}\n\n\tg_event_que[EN_RUN_EVENT].write_flag = 1;\n\t/*在写值前数目递减1，删除一个事件，以防止数据写不完整后掉电，事件信息不完整*/\n\tif (p_ctrl->num >= g_event_que[EN_RUN_EVENT].max_num)\n\t\tp_ctrl->num --;\n\n\tp_item = (ParaEventIn *) (g_event_que[EN_RUN_EVENT].p_item + \\\n\t\t\t\t\t\t\tp_ctrl->write * g_event_que[EN_RUN_EVENT].item_size);\n\n\t/*得到一个空闲参数块*/\n\tif (para_num != 0)\n\t{\n\t\tpara_no = g_event_que[EN_RUN_EVENT].p_para_ctrl->write;\n\t\tp_para = (OptEventPara *) (g_event_que[EN_RUN_EVENT].p_para + \\\n\t\t\t\t\t\t\t\tpara_no * g_event_que[EN_RUN_EVENT].para_size);\n\t\tif (p_para->p_event != NULL && p_para->p_event->para_no == para_no)\n\t\t\tp_para->p_event->para_no = EVENT_PARA_INVALID_IDX;\n\n\t\tSRAM_CPY(p_para->val, cp->p_event_para_mem, para_size);\n\t\tp_para->p_event = p_item;\n\t\tGET_CYCLE_QUE_INDEX_INC(g_event_que[EN_RUN_EVENT].p_para_ctrl->write,\n\t\t\t\t\t\t\t\tpara_no,\n\t\t\t\t\t\t\t\tg_event_que[EN_RUN_EVENT].para_que_max_num)\n\t\tevent.para_no = para_no;\t/*指向动作时故障参数区的索引,参数值个数可配置*/\n\t}\n\telse\n\t\tevent.para_no = EVENT_PARA_INVALID_IDX;\n\tSRAM_CPY(p_item, &event, g_event_que[EN_RUN_EVENT].item_size);\nprintf(\"item_size is %d and sizeofParaEvent is %d\\n\", g_event_que[EN_RUN_EVENT].item_size, sizeof(ParaEventIn));\nprintf(\"事件序号: %d\\n\",event.no);\nprintf(\"引用表排序号: %d\\n\", event.st_no);\nprintf(\"状态值: %d\\n\", event.st_val);\nprintf(\"参数个数: %d\\n\", event.para_num);\nprintf(\"参数索引: %d\\n\", event.para_no);\n\n\tg_event_que[EN_RUN_EVENT].write_flag = 0;\n\n#ifdef INCLUDE_EVENT_SEM\n#if (OS_TYPE == VXWORKS)\n\tsemGive(g_event_que[EN_RUN_EVENT].sem);\n#endif\n#endif\n\n\tp_ctrl->write = write;\n\tp_ctrl->num++;\n\n\tg_event_que[EN_RUN_EVENT].new_item_num++;\n\tp_ctrl->no++;\n\tp_ctrl->no &= EVENT_MAX_BIT_MASK;\n\n\treturn;\n}\n//#else\n//void putRunEvent(Event *cp, UINT16 index, UINT8 st_val)\n//{\n//\tINT32\ti;\n//\tQueCtrl *p_ctrl;\n//\tUINT16 write,para_no;\n//\tParaEventIn *p_item;\n//\tOptEventPara *p_para=NULL;\n//\tUINT16 para_num,para_index;\n//\tWithParaEventCfg *p_event_cfg;\n//\tEventParaCfg *p_para_cfg;\n//\n//\tif (index >= g_event_que[EN_RUN_EVENT].event_ref_tab_item_num)\n//\t{\n//\t\tPRINTINFO((LOG_SHOW), s_log_msg[EVENT_ITEM_INDEX_SRAM],\n//\t\t\t\t\ts_event_sram_name[EN_RUN_EVENT], index);\n//\t\treturn;\n//\t}\n//\n//\tp_ctrl = g_event_que[EN_RUN_EVENT].p_ctrl;\n//\n//\tGET_CYCLE_QUE_INDEX_INC(write, p_ctrl->write, g_event_que[EN_RUN_EVENT].max_num)\n//\n//\tp_event_cfg = &(cp->p_run_event_cfg[index]);\n//\tpara_num = p_event_cfg->para_num;\n//\n//#ifdef INCLUDE_EVENT_SEM\n//#if (OS_TYPE == VXWORKS)\n//\tsemTake(g_event_que[EN_RUN_EVENT].sem, wait_sem_time);\n//#endif\n//#endif\n//\n//\tfor (i=0; i<MAX_CLIENT_NUM; i++)\n//\t{\n//\t\tif (p_ctrl->read[i] == write)\n//\t\t\tCYCLE_QUE_INDEX_INC(p_ctrl->read[i], g_event_que[EN_RUN_EVENT].max_num)\n//\t\tif (p_ctrl->tmp_read[i] == write)\n//\t\t\tCYCLE_QUE_INDEX_INC(p_ctrl->tmp_read[i],\n//\t\t\t\t\t\t\t\t\tg_event_que[EN_RUN_EVENT].max_num)\n//\t}\n//\n//\tg_event_que[EN_RUN_EVENT].write_flag = 1;\n//\t/*得到一个空闲参数块*/\n//\tif (para_num != 0)\n//\t{\n//\t\tpara_no = g_event_que[EN_RUN_EVENT].p_para_ctrl->write;\n//\t\tp_para = (OptEventPara *) (g_event_que[EN_RUN_EVENT].p_para + \\\n//\t\t\t\t\t\t\t\tpara_no * g_event_que[EN_RUN_EVENT].para_size);\n//\t\tif (p_para->p_event != NULL && p_para->p_event->para_no == para_no)\n//\t\t\tp_para->p_event->para_no = EVENT_PARA_INVALID_IDX;\n//\n//\t\t/*写入参数*/\n//\t\tfor (i=0; i<para_num; i++)\n//\t\t{\n//\t\t\tpara_index = p_event_cfg->para_index[i];\n//\t\t\t//if (para_index < g_event_que[EN_RUN_EVENT].para_ref_tab_item_num)\n//\t\t\tp_para_cfg = &cp->p_run_para_cfg[para_index];\n//\t\t\t/*GET_INVAL_REAL_VAL(&p_para->val[i], p_para_cfg->p_invar,\n//\t\t\t\t\t\t\t\t\tp_para_cfg->p_datafield);*/\n//\t\t\tGET_INVAL_VAL(&p_para->val[i], p_para_cfg->p_invar);\n//\t\t}\n//\t}\n//\telse\n//\t\tpara_no = EVENT_PARA_INVALID_IDX;\n//\n//\t/*在写值前数目递减1，删除一个事件，以防止数据写不完整后掉电，事件信息不完整*/\n//\tif (p_ctrl->num >= g_event_que[EN_RUN_EVENT].max_num)\n//\t\tp_ctrl->num --;\n//\n//\tp_item = (ParaEventIn *) (g_event_que[EN_RUN_EVENT].p_item + \\\n//\t\t\t\t\t\t\tp_ctrl->write * g_event_que[EN_RUN_EVENT].item_size);\n//\n//\tGET_EVENT_TIME(p_item->t);\n//\n//\tp_item->no = p_ctrl->no;\t\t\t/*事件序号*/\n//\tp_ctrl->no++;\n//\tp_ctrl->no &= EVENT_MAX_BIT_MASK;\n//\n//\tp_item->st_no = index;\t\t\t/*相对于事件引用表的排序号，从0开始*/\n//\t/*p_item->st_val = st_val;*/\t\t/*状态值*/\n//\t/*GET_BIT_INVAL_VAL(&p_item->st_val,\n//\t\t\t\t\t\tcp->p_run_event_cfg[index].p_invar);*/\n//\n//\t/*做报告时，有可能数值类型为char,因此只要发生，值认为1*/\n//\tp_item->st_val = 1;\n//\tp_item->para_num = para_num;\t/*参数个数*/\n//\n//\tif (para_num != 0)\n//\t{\n//\t\tp_para->p_event = p_item;\n//\t\tGET_CYCLE_QUE_INDEX_INC(g_event_que[EN_RUN_EVENT].p_para_ctrl->write\n//\t\t\t\t\t\t\t\t, para_no\n//\t\t\t\t\t\t\t\t, g_event_que[EN_RUN_EVENT].para_que_max_num)\n//\t}\n//\tp_item->para_no = para_no;\t/*指向动作时故障参数区的索引,参数值个数可配置*/\n//\n//\tg_event_que[EN_RUN_EVENT].write_flag = 0;\n//\n//#ifdef INCLUDE_EVENT_SEM\n//#if (OS_TYPE == VXWORKS)\n//\tsemGive(g_event_que[EN_RUN_EVENT].sem);\n//#endif\n//#endif\n//\n//\tp_ctrl->write = write;\n//\tp_ctrl->num++;\n//\n//\tg_event_que[EN_RUN_EVENT].new_item_num++;\n//\treturn;\n//}\n//#endif\n\nINT32 getRealRunEvent(UINT32 client_no, EventData *p_data, INT32 mode)\n{\n\tQueCtrl *p_ctrl;\n\tUINT16 read,para_no;\n\tParaEventIn *p_item;\n\tINT8 *p_para;\n\tWithParaEventCfg *p_event_cfg;\n\tEvent *cp;\n\n\tif (client_no >= MAX_CLIENT_NUM)\n\t\treturn -1;\n\n\tp_ctrl = g_event_que[EN_RUN_EVENT].p_ctrl;\n\tread = p_ctrl->read[client_no];\n\tif (read == p_ctrl->write)\n\t\treturn -1;\n\n\tcp = getGpEvent();\n\tif (mode == EN_RTTASK_READ_MODE_ACK)\n\t{\n\t\tread = p_ctrl->tmp_read[client_no];\n\t\tif (read == p_ctrl->write)\n\t\t\tread = p_ctrl->read[client_no];\n\t}\n\n\tp_item = (ParaEventIn *) (g_event_que[EN_RUN_EVENT].p_item + \\\n\t\t\t\t\t\t\tread * g_event_que[EN_RUN_EVENT].item_size);\n\n#ifdef INCLUDE_EVENT_SEM\n#if (OS_TYPE == VXWORKS)\n\tif (semTake(g_event_que[EN_RUN_EVENT].sem, wait_sem_time) == ERROR)\n\t\treturn -1;\n#endif\n#endif\n\n\tSRAM_CPY((void *)&p_data->data, p_item, sizeof(ParaEventIn));\n\n\tp_event_cfg = &(cp->p_run_event_cfg[p_data->data.run.st_no]);\n\t//p_data->para_num = p_event_cfg->para_num;\n\tp_data->para_num = p_item->para_num;\n\tp_data->type = EN_RUN_EVENT;\n\n\t/*读出参数*/\n\tpara_no = p_item->para_no;\n\tif (para_no < g_event_que[EN_RUN_EVENT].para_que_max_num)\n\t{\n\t\tp_para = (g_event_que[EN_RUN_EVENT].p_para + sizeof(ParaNode) + \\\n\t\t\t\t\tpara_no * g_event_que[EN_RUN_EVENT].para_size);\n\t\tmemcpy(p_data->data.run.para_no, p_event_cfg->para_index,\n\t\t\t\t\t\t(p_data->para_num << 1));\n\t\tSRAM_CPY(p_data->data.run.val, p_para, (p_data->para_num << 2));\n\t}\n\telse\n\t{\n\t\tp_data->data.run.para_num = 0;\n\t\tp_data->para_num = 0;\n\t}\n\n\tCYCLE_QUE_INDEX_INC(read, g_event_que[EN_RUN_EVENT].max_num)\n\tif (mode == EN_RTTASK_READ_MODE_NO_ACK)\n\t{\n\t\tp_ctrl->read[client_no] = read;\n\t}\n\telse if (mode == EN_RTTASK_READ_MODE_ACK)\n\t{\n\t\tp_ctrl->tmp_read[client_no] = read;\n\t}\n\n#ifdef INCLUDE_EVENT_SEM\n#if (OS_TYPE == VXWORKS)\n\tsemGive(g_event_que[EN_RUN_EVENT].sem);\n#endif\n#endif\n\n\treturn 0;\n}\n\nINT32 getHisRunEvent(UINT16 read, EventData *p_data)\n{\n\tUINT16 para_no;\n\tParaEventIn *p_item;\n\tINT8 *p_para;\n\tWithParaEventCfg *p_event_cfg;\n\tEvent *cp;\n\n\tcp = getGpEvent();\n\tp_item = (ParaEventIn *) (g_event_que[EN_RUN_EVENT].p_item + \\\n\t\t\t\t\t\t\tread * g_event_que[EN_RUN_EVENT].item_size);\n#ifdef INCLUDE_EVENT_SEM\n#if (OS_TYPE == VXWORKS)\n\tif (semTake(g_event_que[EN_RUN_EVENT].sem, wait_sem_time) == ERROR)\n\t\treturn -1;\n#endif\n#endif\n\n\tSRAM_CPY((void *)&p_data->data, p_item, sizeof(ParaEventIn));\n\tp_event_cfg = &(cp->p_run_event_cfg[p_data->data.run.st_no]);\n\t//p_data->para_num = p_event_cfg->para_num;\n\tp_data->para_num = p_item->para_num;\n\n\t/*读出参数*/\n\tpara_no = p_item->para_no;\n\tif (para_no < g_event_que[EN_RUN_EVENT].para_que_max_num)\n\t{\n\t\tp_para = (g_event_que[EN_RUN_EVENT].p_para + sizeof(ParaNode) + \\\n\t\t\t\t\tpara_no * g_event_que[EN_RUN_EVENT].para_size);\n\t\tmemcpy(p_data->data.run.para_no, p_event_cfg->para_index,\n\t\t\t\t\t(p_data->para_num << 1));\n\t\tSRAM_CPY(p_data->data.run.val, p_para, (p_data->para_num << 2));\n\t}\n\telse\n\t{\n\t\tp_data->data.run.para_num = 0;\n\t\tp_data->para_num = 0;\n\t}\n\n#ifdef INCLUDE_EVENT_SEM\n#if (OS_TYPE == VXWORKS)\n\tsemGive(g_event_que[EN_RUN_EVENT].sem);\n#endif\n#endif\n\n\treturn 0;\n}\n\nvoid putCheckEvent(Event *cp, UINT16 index, UINT8 st_val, UINT8 old_val)\n{\n\tNoParaEvent event;\n\n\tif (index >= g_event_que[EN_CHECK_EVENT].event_ref_tab_item_num)\n\t{\n\t\tPRINTINFO((LOG_SHOW), s_log_msg[EVENT_ITEM_INDEX_SRAM],\n\t\t\t\t\ts_event_sram_name[EN_CHECK_EVENT], index);\n\t\treturn;\n\t}\n\n\tif (DESC_EVENT_VISIBLE(cp->p_check_event_cfg[index].p_datafield)==0)\n\t\treturn;\n\n\tGET_EVENT_TIME(event.t);\n\nprintf(\"[%s, %d]: will record check event\\n\", __FUNCTION__, __LINE__);\nprintf(\"index = %d, st_val = %d, old_val = %d\\n\", index, st_val, old_val);\n\n\tevent.no = g_event_que[EN_CHECK_EVENT].p_ctrl->no;\t\t/*事件序号*/\n\tevent.st_no = index;\t\t\t\t\t/*相对于事件引用表的排序号，从0开始*/\n\tevent.st_val = st_val;\t\t\t\t\t/*状态值*/\n//\tGET_BIT_INVAL_VAL(&event.st_val,\n//\t\t\t\t\t\tcp->p_check_event_cfg[index].p_invar);\n\tevent.valid = 0;\t\t\t\t\t\t\t/*pack,四字节边界对齐*/\n\tevent.q = qGetProc(cp, cp->p_check_event_cfg[index].p_quality_invar);\t\t\t\t\t\t\t/*品质位*/\n\nprintf(\"事件序号: %d\\n\",event.no);\nprintf(\"引用表排序号: %d\\n\", event.st_no);\nprintf(\"状态值: %d\\n\", event.st_val);\nprintf(\"品质: %#x\\n\", event.q);\n\n\tputEventQue(&g_event_que[EN_CHECK_EVENT], (INT8 *)&event);\n\tg_event_que[EN_CHECK_EVENT].p_ctrl->no++;\n\tg_event_que[EN_CHECK_EVENT].p_ctrl->no &= EVENT_MAX_BIT_MASK;\n\n\treturn;\n}\n\nvoid putBiEvent(Event *cp, UINT16 index, UINT8 st_val,UINT8 old_val)\n{\n\tNoParaEvent event;\n\n\tif (index >= g_event_que[EN_BI_EVENT].event_ref_tab_item_num)\n\t{\n\t\tPRINTINFO((LOG_SHOW), s_log_msg[EVENT_ITEM_INDEX_SRAM],\n\t\t\t\t\ts_event_sram_name[EN_BI_EVENT], index);\n\t\treturn;\n\t}\n\n\tif (DESC_EVENT_VISIBLE(cp->p_bi_event_cfg[index].p_datafield)==0)\n\t\treturn;\n\n\tGET_EVENT_TIME(event.t);\n\nprintf(\"[%s, %d]: will record bi event\\n\", __FUNCTION__, __LINE__);\n\tevent.no = g_event_que[EN_BI_EVENT].p_ctrl->no;\t\t/*事件序号*/\n\tevent.st_no = index;\t\t\t\t\t/*相对于事件引用表的排序号，从0开始*/\n\tevent.st_val = st_val;\t\t\t\t\t/*状态值*/\n\tevent.old_val=old_val;\n//\tGET_BIT_INVAL_VAL(&event.st_val,\n//\t\t\t\t\t\t\tcp->p_bi_event_cfg[index].p_invar);\n\tevent.valid = 0;\t\t\t\t\t\t\t/*pack,四字节边界对齐*/\n\tevent.q = qGetProc(cp, cp->p_bi_event_cfg[index].p_quality_invar);\t\t\t\t\t\t\t/*品质位*/\n\n\tputEventQue(&g_event_que[EN_BI_EVENT], (INT8 *)&event);\n\tg_event_que[EN_BI_EVENT].p_ctrl->no++;\n\tg_event_que[EN_BI_EVENT].p_ctrl->no &= EVENT_MAX_BIT_MASK;\n\n\treturn;\n}\n\nvoid putYxEvent(Event *cp, UINT16 index, UINT8 st_val, UINT8 old_val, UINT32 sec, UINT16 ms)\n{\n\tNoParaEvent event;\n\n\tif (g_sys_run_state == 0)\n\t\treturn;\n\n\tif (index >= g_event_que[EN_YX_EVENT].event_ref_tab_item_num)\n\t{\n\t\tPRINTINFO((LOG_SHOW), s_log_msg[EVENT_ITEM_INDEX_SRAM],\n\t\t\t\t\ts_event_sram_name[EN_YX_EVENT], index);\n\t\treturn;\n\t}\n\n\tif (DESC_EVENT_VISIBLE(cp->p_yx_event_cfg[index].p_datafield)==0)\n\t\treturn;\n\n//\tGET_EVENT_TIME(event.t);\n\tevent.t.sec = sec;\n\tevent.t.us = ms*1000;\n\n\tevent.no = g_event_que[EN_YX_EVENT].p_ctrl->no;\t\t/*事件序号*/\n\tevent.st_no = index;\t\t\t\t\t/*相对于事件引用表的排序号，从0开始*/\n\tevent.st_val = st_val;\t\t\t\t\t/*状态值*/\n\tevent.old_val = old_val;\n//\tGET_BIT_INVAL_VAL(&event.st_val,\n//\t\t\t\t\t\t\tcp->p_bi_event_cfg[index].p_invar);\n\tevent.q = qGetProc(cp, cp->p_yx_event_cfg[index].p_quality_invar);\t\t\t\t\t\t\t/*品质位*/\n\n//\tprintf(\"--event yx: index=%d, st_val=%d, no=%d,sec=%d, ms=%d\\n\", \n//\t\t\tindex, st_val, g_event_que[EN_YX_EVENT].p_ctrl->no, sec, ms);\n\tputEventQue(&g_event_que[EN_YX_EVENT], (INT8 *)&event);\n\tg_event_que[EN_YX_EVENT].p_ctrl->no++;\n\tg_event_que[EN_YX_EVENT].p_ctrl->no &= EVENT_MAX_BIT_MASK;\n\n\treturn;\n}\n//\n//void putSoeEvent(Event *cp, SoeItem *item)\n//{\n//\tNoParaEvent event;\n//\tUINT16 key,index;\n//\n//\t//printf(\"s=%d,ms=%d\\n\", item->sec, item->ms);\n//\tkey = (item->board_addr << 8) | item->no;\n//\tindex = searchSoeIndexTable(cp->p_soe_index_table, key);\n//\tif (index == 0xffff)\n//\t{\n//\t\tPRINTINFO((LOG_SHOW), s_log_msg[EVENT_ITEM_INDEX_SRAM],\n//\t\t\t\t\ts_event_sram_name[EN_YX_EVENT], index);\n//\t\treturn;\n//\t}\n//\n//\tif (DESC_EVENT_VISIBLE(cp->p_soe_event_cfg[index].p_datafield)==0)\n//\t\treturn;\n//\n//\tevent.t.sec = item->sec;\n//\tevent.t.us = item->ms * 1000;\n//\n//\tevent.no = g_event_que[EN_YX_EVENT].p_ctrl->no;\t\t/*事件序号*/\n//\tevent.st_no = index;\t\t\t\t\t/*相对于事件引用表的排序号，从0开始*/\n//\tevent.st_val = item->st_val & 0x03;\t\t/*状态值*/\n//\tevent.valid = 0;\t\t\t\t\t\t/*pack,四字节边界对齐*/\n//\tevent.q = 0;\t\t\t\t\t\t\t/*品质位*/\n//\n//\tputEventQue(&g_event_que[EN_YX_EVENT], (INT8 *)&event);\n//\tg_event_que[EN_YX_EVENT].p_ctrl->no++;\n//\tg_event_que[EN_YX_EVENT].p_ctrl->no &= EVENT_MAX_BIT_MASK;\n//\n//\treturn;\n//}\n\nvoid putNoParaEvent(EventType event_type, UINT16 index, UINT8 st_val)\n{\n\tNoParaEvent event;\n\n\tif (index >= g_event_que[event_type].event_ref_tab_item_num)\n\t{\n\t\tPRINTINFO((LOG_SHOW), s_log_msg[EVENT_ITEM_INDEX_SRAM],\n\t\t\t\t\ts_event_sram_name[event_type], index);\n\t\treturn;\n\t}\n\n\tGET_EVENT_TIME(event.t);\n\n\tevent.no = g_event_que[event_type].p_ctrl->no;\t\t/*事件序号*/\n\tevent.st_no = index;\t\t\t\t\t/*相对于事件引用表的排序号，从0开始*/\n\tevent.st_val = st_val;\t\t\t\t\t/*状态值*/\n\tevent.valid = 0;\t\t\t\t\t\t/*pack,四字节边界对齐*/\n\tevent.q = 0;\t\t\t\t\t\t\t/*品质位*/\n\n\tputEventQue(&g_event_que[event_type], (INT8 *)&event);\n\tg_event_que[event_type].p_ctrl->no++;\n\tg_event_que[event_type].p_ctrl->no &= EVENT_MAX_BIT_MASK;\n\t\n\treturn;\n}\n\nINT32 putChanChkEvent(InVarCfg *p_invar_cfg)\n{\n\tINT32\ti;\n\tChanChkEvent event;\n\tEventType event_type;\n\tEventParaCfg *p_chan_chk_cfg;\n\tUINT32 chan_no;\n\tUINT32 in_var_index;\n\tEvent *cp;\n\n\tif (g_sys_run_state == 0)\t//等待I/O初始态初始化完成\n\t\treturn 0;\n\n\tin_var_index = p_invar_cfg->index;\n\tif (in_var_index < EN_CHAN_A_CHECK_TRIGGER)\n\t\treturn 0;\n\n\tcp = (Event *)p_invar_cfg->p_parent;\n\tchan_no = in_var_index - EN_CHAN_A_CHECK_TRIGGER;\n\t/*判断上升沿*/\n\t//GET_BIT_INVAL_VAL(&state, cp->p_chan_chk);\n\t/*state = *(cp->p_in_val[in_var_index]);\n\tif (state == 1)*/\n//\t{\n//\t}\n\n\tif (chan_no >= EVENT_MAX_CHAN_NUM)\n\t\treturn 0;\n\n\tevent_type = EN_CHAN_A_CHK_EVENT + chan_no;\n\tp_chan_chk_cfg = cp->p_chan_chk_cfg[chan_no];\n\tGET_EVENT_TIME(event.t);\n\tevent.no = g_event_que[event_type].p_ctrl->no++;\n\tg_event_que[event_type].p_ctrl->no &= EVENT_MAX_BIT_MASK;\n\tfor (i=0; i<g_event_que[event_type].event_ref_tab_item_num; i++)\n\t{\n\t\t/*GET_INVAL_REAL_VAL(&event.val[i], p_chan_chk_cfg->p_invar,\n\t\t\t\t\t\t\t\tp_chan_chk_cfg->p_datafield);*/\n\t\tGET_INVAL_VAL(&event.val[i], p_chan_chk_cfg->p_invar);\n\t\tp_chan_chk_cfg++;\n\t}\n\n\tputEventQue(&g_event_que[event_type], (INT8 *)&event);\n\n\treturn 0;\n}\n\nvoid scanTimeDayChange(Event *cp)\n{\n\tSystemTime local_time;\n\tUINT32 i;\n\n\tgetLocalTime(&local_time);\n\tif (cp->last_day != local_time.day)\n\t{\n\t\tfor (i=0; i<EVENT_MAX_CHAN_NUM; i++)\n\t\t\tputChanStatEvent(cp,i);\n\n\t\tcp->last_day = local_time.day;\n\t}\n\n\treturn;\n}\n\nINT32 putChanStatEvent(Event *cp,UINT32 chan_no)\n{\n\tINT32\ti;\n\tChanStatEvent event;\n\tEventType event_type;\n\tEventParaCfg *p_chan_stat_cfg;\n\n\tif (chan_no >= EVENT_MAX_CHAN_NUM)\n\t\treturn 0;\n\n\tevent_type = EN_CHAN_A_STAT_EVENT + chan_no;\n\tif (g_event_que[event_type].read_cfg_ok != 1)\n\t\treturn 0;\n\n\tp_chan_stat_cfg = cp->p_chan_stat_cfg[chan_no];\n\tGET_EVENT_TIME(event.t);\n\tevent.no = g_event_que[event_type].p_ctrl->no++;\n\tg_event_que[event_type].p_ctrl->no &= EVENT_MAX_BIT_MASK;\n\tfor (i=0; i<g_event_que[event_type].event_ref_tab_item_num; i++)\n\t{\n\t\t/*GET_INVAL_REAL_VAL(&event.val[i], p_chan_stat_cfg->p_invar,\n\t\t\t\t\t\t\tp_chan_stat_cfg->p_datafield)*/\n\t\tGET_INVAL_VAL(&event.val[i], p_chan_stat_cfg->p_invar)\n\t\tp_chan_stat_cfg++;\n\t}\n\n\tputEventQue(&g_event_que[event_type], (INT8 *)&event);\n\n\treturn 0;\n}\n\nINT32 putOrderEvent(InVarCfg *p_invar_cfg)\n{\n\tOrderEvent event;\n\tEvent *cp;\n\n\tif (g_sys_run_state == 0)\n\t\treturn 0;\n\n\tif (g_event_que[EN_ORDER_EVENT].read_cfg_ok != 1)\n\t\treturn 0;\n\n\tcp = p_invar_cfg->p_parent;\n\n\tGET_EVENT_TIME(event.t);\n\tevent.no = g_event_que[EN_ORDER_EVENT].p_ctrl->no++;\n\tg_event_que[EN_ORDER_EVENT].p_ctrl->no &= EVENT_MAX_BIT_MASK;\n\tmemcpy(&event.inf, cp->order_in_val, sizeof(CtrlRpt));\n\tputEventQue(&g_event_que[EN_ORDER_EVENT], (INT8 *)&event);\n\n\treturn 0;\n}\n\nINT32 deleteHisEvent(EventType event_type)\n{\n\tQueCtrl *p_ctrl;\n\n\tif (event_type >= EN_EVENT_TYPE_NUM)\n\t\treturn -1;\n\tp_ctrl = g_event_que[event_type].p_ctrl;\n\n\tp_ctrl->num = 0;\n\tg_event_que[event_type].p_ctrl->no = 0;\n\n\treturn 0;\n}\n\nINT32 delAllHisEvent(InVarCfg *p_invar_cfg)\n{\n\tINT32 i,j;\n\tINT8 state;\n\tUINT32 in_var_index;\n\tEvent *cp;\n\n\tin_var_index = p_invar_cfg->index;\n\t/*判断上升沿*/\n\t//GET_BIT_INVAL_VAL(&state, cp->p_del_event_inval);\n\tif (in_var_index >= EN_TOTAL_EVENT_IN_VAL_NUM)\n\t\treturn 0;\n\n\tcp = p_invar_cfg->p_parent;\n\tstate = *(cp->p_in_val[in_var_index]);\n\n\tif (state)\n\t{\n\t\tfor (i=0; i<EN_EVENT_TYPE_NUM; i++)\n\t\t{\n\t\t\tif (i != EN_RUN_EVENT)\n\t\t\t{\n\t\t\t\tdeleteHisEvent(i);\n\t\t\t\tfor(j=0; j<MAX_CLIENT_NUM; j++)\n\t\t\t\t\tclearRealEvent(i, j);\n\t\t\t}\n\t\t}\n\n\t\tcp->del_event_state = 1;\n\t\tcp->del_event_count = rttask_run_freq;\t/*1秒钟*/\n\t}\n\n\treturn 0;\n}\n\nvoid clearRunRpt(void)\n{\n\tINT32 j;\n\t\n\tdeleteHisEvent(EN_RUN_EVENT);\n\tfor(j=0; j<MAX_CLIENT_NUM; j++)\n\t\tclearRealEvent(EN_RUN_EVENT, j);\n\t\n\treturn;\n}\n\nvoid clearNewEventNum(void)\n{\n\tg_event_que[EN_TRIP_EVENT].new_item_num = 0;\n\tg_event_que[EN_CHECK_EVENT].new_item_num = 0;\n\tg_event_que[EN_BI_EVENT].new_item_num = 0;\n\n\treturn;\n}\n\nINT32 signalResetProc(InVarCfg *p_invar_cfg)\n{\n\tUINT8 state;\n\tUINT32 in_var_index;\n\tEvent *cp;\n\n\tif (g_sys_run_state == 0)\n\t\treturn 0;\n\n\tin_var_index = p_invar_cfg->index;\n\t/*判断上升沿*/\n\t//GET_BIT_INVAL_VAL(&state, cp->p_signal_reset_inval);\n\tif (in_var_index >= EN_TOTAL_EVENT_IN_VAL_NUM)\n\t\treturn 0;\n\n\tcp = p_invar_cfg->p_parent;\n\tstate = *(cp->p_in_val[in_var_index]);\n\n\tif (state == 0)\n\t\treturn 0;\n\n\tsignalResetLed(getGpLed());\n\n\t/*信号已复归*/\n\tg_sram_not_reseted_wave_exist = 0;\n\n\tcp->signal_reset_state = 1;\n\tcp->signal_reset_count = 200 * rttask_run_freq / 1000 + 1;\n\n\treturn 0;\n}\n\nvoid clearEventOutSignal(Event *cp)\n{\n\tif (cp->del_event_state == 1)\n\t{\n\t\tif (cp->del_event_count-- == 0)\n\t\t\tcp->del_event_state = 0;\n\t}\n\n\tif (cp->signal_reset_state == 1)\n\t{\n\t\tif (cp->signal_reset_count-- == 0)\n\t\t\tcp->signal_reset_state = 0;\n\t}\n\n\treturn;\n}\n\nvoid putCommTestEvent(Event *cp)\n{\n\tWithParaEventCfg *p_event_cfg = NULL;\n\tNoParaEventCfg *p_event_no_para_cfg = NULL;\n\tUINT32 sec, ms;\n\tDataFields\t*p_datafield;\n\t\n\tswitch (cp->comm_gen_event_type)\n\t{\n\tcase EN_TRIP_EVENT:\t\t\t\t/*动作事件*/\n\t\tp_event_cfg = &(cp->p_trip_event_cfg[cp->comm_gen_event_index]);\n\t\tif(0 != p_event_cfg->p_invar->value)\n\t\t{\n\t\tputTripEvent(cp, cp->comm_gen_event_index, 0, 1);\n\t\t\tputTripEvent(cp, cp->comm_gen_event_index, 1, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tputTripEvent(cp, cp->comm_gen_event_index, 1, 0);\n\t\t\tputTripEvent(cp, cp->comm_gen_event_index, 0, 1);\n\t\t}\n\t\tbreak;\n\tcase EN_RUN_EVENT:\t\t\t\t/*运行记录*/\n\t\tp_event_cfg = &(cp->p_run_event_cfg[cp->comm_gen_event_index]);\n\t\tif(0 != p_event_cfg->p_invar->value)\n\t\t{\n\t\tputRunEvent(cp, cp->comm_gen_event_index, 0, 1);\n\t\t\tputRunEvent(cp, cp->comm_gen_event_index, 1, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tputRunEvent(cp, cp->comm_gen_event_index, 1, 0);\n\t\t\tputRunEvent(cp, cp->comm_gen_event_index, 0, 1);\n\t\t}\n\t\tbreak;\n\tcase EN_CHECK_EVENT:\t\t\t/*自检事件*/\n\t\tp_event_no_para_cfg = &(cp->p_check_event_cfg[cp->comm_gen_event_index]);\n\t\tif(0 != p_event_no_para_cfg->p_invar->value)\n\t\t{\n\t\tputCheckEvent(cp, cp->comm_gen_event_index, 0, 1);\n\t\t\tputCheckEvent(cp, cp->comm_gen_event_index, 1, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tputCheckEvent(cp, cp->comm_gen_event_index, 1, 0);\n\t\t\tputCheckEvent(cp, cp->comm_gen_event_index, 0, 1);\n\t\t}\n\t\tbreak;\n\tcase EN_BI_EVENT:\t\t\t\t/*开关量变位*/\n\t\tp_event_no_para_cfg = &(cp->p_bi_event_cfg[cp->comm_gen_event_index]);\n\t\tif(0 != p_event_no_para_cfg->p_invar->value)\n\t\t{\n\t\tputBiEvent(cp, cp->comm_gen_event_index, 0, 1);\n\t\t\tputBiEvent(cp, cp->comm_gen_event_index, 1, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tputBiEvent(cp, cp->comm_gen_event_index, 1, 0);\n\t\t\tputBiEvent(cp, cp->comm_gen_event_index, 0, 1);\n\t\t}\n\t\tbreak;\n\tcase EN_YX_EVENT:\n\t\tp_event_no_para_cfg = &(cp->p_yx_event_cfg[cp->comm_gen_event_index]);\n\t\tgetSysTime(&sec, &ms);\n\n\t\tp_datafield = p_event_no_para_cfg->p_datafield;\n\t\tif(p_datafield->bit_num==2)\t// 双点\n\t\t{\n\t\t\tif(2 == p_event_no_para_cfg->p_invar->value)\n\t\t\t{\n\t\t\t\tputYxEvent(cp, cp->comm_gen_event_index, 1, 2, sec, ms);\n\t\t\t\tputYxEvent(cp, cp->comm_gen_event_index, 2, 1, sec, ms);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputYxEvent(cp, cp->comm_gen_event_index, 2, 1, sec, ms);\n\t\t\t\tputYxEvent(cp, cp->comm_gen_event_index, 1, 2, sec, ms);\n\t\t\t}\n\t\t}\n\t\telse\t\t\t\t\t\t// 否则单点\n\t\t{\n\t\t\tif(0 != p_event_no_para_cfg->p_invar->value)\n\t\t\t{\n\t\t\t\t{\n\t\t\t\t\tputYxEvent(cp, cp->comm_gen_event_index, 0, 1, sec, ms);\n\t\t\t\t\tputYxEvent(cp, cp->comm_gen_event_index, 1, 0, sec, ms);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputYxEvent(cp, cp->comm_gen_event_index, 1, 0, sec, ms);\n\t\t\t\tputYxEvent(cp, cp->comm_gen_event_index, 0, 1, sec, ms);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (cp->comm_gen_even_flag == 0)\n\t\treturn;\n\tcp->comm_gen_event_index++;\n\tif (cp->comm_gen_event_index >=\n\t\t\tg_event_que[cp->comm_gen_event_type].event_ref_tab_item_num)\n\t{\n\t\tcp->comm_gen_event_index = 0;\n\t\tif (cp->comm_gen_all_event_flag == 0)\n\t\t\tcp->comm_gen_even_flag = 0;\n\t\telse \t/*模拟所有类型的事件*/\n\t\t{\n\t\t\tcp->comm_gen_event_type++;\n\t\t\tif (cp->comm_gen_event_type > EN_BI_EVENT)\n\t\t\t\tcp->comm_gen_even_flag = 0;\n\t\t}\n\t}\n\n\treturn;\n}\n\nINT32 genCommTestEventCallBack(InVarCfg *p_invar_cfg)\n{\n\tINT8 state;\n\tUINT32 test_index;\n\tUINT16 index;\n\tEventType event_type;\n\tEvent *cp;\n\n\tcp = p_invar_cfg->p_parent;\n\t/*判断上升沿*/\n\tstate = *(cp->p_in_val[EN_COMM_TEST_EVENT_TRIGGER]);\n\tif (state == 0)\n\t\treturn 0;\n\n\ttest_index = *((UINT32*)cp->p_in_val[EN_COMM_TEST_EVENT_INDEX]);\n\tevent_type = ((test_index >> 24) & 0xff);\n\tindex = test_index & 0x0000ffff;\n\t/*printf(\"com test,test_index=%x,type=%d,index=%d\\n\", test_index,\n\t\t\t\tevent_type, index);*/\n\tif (event_type == 0xff)\t/*产生所有类型的事件*/\n\t{\n\t\tcp->comm_gen_all_event_flag = 1;\n\t\tcp->comm_gen_event_type = EN_TRIP_EVENT;\n\t}\n\telse\n\t{\n\t\tcp->comm_gen_all_event_flag = 0;\n\t\tcp->comm_gen_event_type = event_type;\n\t}\n\n\tif (index == 0xffff)\t/*产生所有事件*/\n\t{\n\t\tcp->comm_gen_even_flag = 1;\n\t\tcp->comm_gen_event_index = 0;\n\t}\n\telse\n\t{\n\t\tcp->comm_gen_event_index = index;\n\t\tputCommTestEvent(cp);\n\t}\n\n\treturn 0;\n}\n\nUINT16 getEventCfg(EventType event_type, void *p_p_cfg)\n{\n\tUINT16 num;\n\tINT32 chan_no;\n\tEvent *cp;\n\n\tif (event_type >= EN_EVENT_TYPE_NUM)\n\t\treturn 0;\n\n\tcp = getGpEvent();\n\tnum = g_event_que[event_type].event_ref_tab_item_num;\n\tswitch (event_type)\n\t{\n\tcase EN_TRIP_EVENT:\t\t\t\t/*动作事件*/\n\t\t*((WithParaEventCfg **)p_p_cfg) = cp->p_trip_event_cfg;\n\t\tbreak;\n\tcase EN_RUN_EVENT:\t\t\t\t/*运行记录*/\n\t\t*((WithParaEventCfg **)p_p_cfg) = cp->p_run_event_cfg;\n\t\tbreak;\n\tcase EN_CHECK_EVENT:\t\t\t/*自检事件*/\n\t\t*((NoParaEventCfg **)p_p_cfg) = cp->p_check_event_cfg;\n\t\tbreak;\n\tcase EN_BI_EVENT:\t\t\t\t/*开关量变位*/\n\t\t*((NoParaEventCfg **)p_p_cfg) = cp->p_bi_event_cfg;\n\t\tbreak;\n\tcase EN_YX_EVENT:\t\t\t\t/*遥信变位*/\n\t\t*((NoParaEventCfg **)p_p_cfg) = cp->p_yx_event_cfg;\n\t\tbreak;\n\tcase EN_CHAN_A_CHK_EVENT:\t\t/*通道自检*/\n\tcase EN_CHAN_B_CHK_EVENT:\n\tcase EN_CHAN_C_CHK_EVENT:\n\tcase EN_CHAN_D_CHK_EVENT:\n\t\tchan_no = event_type - EN_CHAN_A_CHK_EVENT;\n\t\t*((EventParaCfg **)p_p_cfg) = cp->p_chan_chk_cfg[chan_no];\n\t\tbreak;\n\tcase EN_CHAN_A_STAT_EVENT:\t\t/*通道统计*/\n\tcase EN_CHAN_B_STAT_EVENT:\n\tcase EN_CHAN_C_STAT_EVENT:\n\tcase EN_CHAN_D_STAT_EVENT:\n\t\tchan_no = event_type - EN_CHAN_A_STAT_EVENT;\n\t\t*((EventParaCfg **)p_p_cfg) = cp->p_chan_stat_cfg[chan_no];\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn num;\n}\n//\n////SOE的处理\n//SoeIndexTable *createSoeIndexTable(INT32 max_item)\n//{\n//\tSoeIndexTable *p_table;\n//\tINT32 mem_size;\n//\n//\tmem_size = sizeof(SoeIndexTable) + sizeof(SoeIndex) * (max_item-1);\n//\tp_table = (SoeIndexTable *) HOPEMALLOC(mem_size);\n//\tif (p_table == NULL)\n//\t{\n//\t\tPRINTINFO(ALL_SHOW, g_hmi_err_msg[EN_GET_MEM_ERR]\n//\t\t\t\t\t\t, \"soe index tab\", errno);\n//\t\treturn NULL;\n//\t}\n//\n//\tp_table->max_item = max_item;\n//\tp_table->item_num = 0;\n//\n//\treturn p_table;\n//}\n//\n//// 将SOE表键值由小到大排列\n//INT32 insertSoeIndexTable(SoeIndexTable *p_table, UINT16 key, UINT16 no)\n//{\n//\tINT16 low,high,mid;\n//\n//\tlow = 0;\n//\thigh = p_table->item_num - 1;\n//\twhile (low <= high)\n//\t{\n//\t\tmid = (low + high) / 2;\n//\t\tif (key < p_table->item[mid].key) high = mid - 1;\n//\t\telse if (key > p_table->item[mid].key) low = mid + 1;\n//\t\telse return -1;\n//\t}\n//\n//\tif (low < p_table->item_num)\n//\t\tmemmove(&p_table->item[low+1], &p_table->item[low],\n//\t\t\t\t\t(p_table->item_num-low)*sizeof(SoeIndex));\n//\n//\tp_table->item[low].key = key;\n//\tp_table->item[low].no = no;\n//\tp_table->item_num++;\n//\n//\treturn 0;\n//}\n//\n//UINT16 searchSoeIndexTable(SoeIndexTable *p_table, UINT16 key)\n//{\n//\tINT16 low,high,mid;\n//\n//\tlow = 0;\n//\thigh = p_table->item_num - 1;\n//\twhile (low <= high)\n//\t{\n//\t\tmid = (low + high) / 2;\n//\t\tif (key == p_table->item[mid].key)\n//\t\t\treturn p_table->item[mid].no;\n//\t\telse if (key < p_table->item[mid].key) high = mid - 1;\n//\t\telse low = mid + 1;\n//\t}\n//\n//\treturn 0xffff;\n//}\n//\n//void showSoeIndexTable(void)\n//{\n//\tINT32 i;\n//\tSoeIndexTable *p_table;\n//\tEvent *cp;\n//\n//\tcp = getGpEvent();\n//\tp_table = cp->p_soe_index_table;\n//\tif (p_table == NULL)\n//\t\treturn;\n//\n//\tprintf (\"\\tno     key         soe no\\n\");\n//\tprintf (\"\\t--- -------------- --------------\\n\");\n//\tfor (i=0; i<p_table->item_num; i++)\n//\t\tprintf (\"\\t%.3d %14x %14d\\n\", i, p_table->item[i].key,\n//\t\t\t\t\tp_table->item[i].no);\n//}\n//\n//INT32 initSoeProcess(Event *cp)\n//{\n//\tSoeIndexTable *p_table;\n//\tINT32 i,num;\n////\tUINT16 key;\n//\n//\tnum = g_event_que[EN_YX_EVENT].event_ref_tab_item_num;\n//\tp_table = createSoeIndexTable(num);\n//\tfor (i=0; i<num; i++)\n//\t{\n////\t\tkey = getSignalIndexByName(cp->p_soe_event_cfg[i].name);\n////\t\t//printf(\"soe:%s, key=%x\\n\", cp->p_soe_event_cfg[i].name, key);\n////\t\tif (key == 0xffff)\n////\t\t{\n////\t\t\tPRINTINFO(ALL_SHOW, s_error_msg[EN_EVENT_SOE_NOT_FIND_KEY]\n////\t\t\t\t\t\t, cp->p_soe_event_cfg[i].name);\n////\t\t\treturn -1;\n////\t\t}\n////\n////\t\tif (insertSoeIndexTable(p_table, key, i) < 0)\n////\t\t{\n////\t\t\tPRINTINFO(ALL_SHOW, s_error_msg[EN_EVENT_SOE_KEY_REPEART]\n////\t\t\t\t\t\t, cp->p_soe_event_cfg[i].name, key);\n////\t\t\treturn -1;\n////\t\t}\n//\t}\n//\n//\tif (p_table->item_num == 0)\n//\t{\n//\t\tHOPEFREE(p_table);\n//\t\treturn 0;\n//\t}\n//\n//\tcp->soe_fd = open(\"/dev/soe\", O_RDONLY, 0);\n//\tif (cp->soe_fd == NULL)\n//\t{\n//\t\tPRINTINFO(ALL_SHOW, s_error_msg[EN_EVENT_OPEN_SOE_READ_FD_ERR], errno);\n//\t\treturn -1;\n//\t}\n//\tcp->p_soe_index_table = p_table;\n//\n//\treturn 0;\n//}\n//\n//void saveSoeToSram(Event *cp)\n//{\n//\tSoeItem soe_item;\n//\tINT32 i=0;\n//\n//\twhile (i < 12\n//\t    && read(cp->soe_fd, (INT8 *)&soe_item, sizeof(SoeItem) > 0))\n//\t{\n//\t\tputSoeEvent(cp, &soe_item);\n//\t\ti++;\n//\t}\n//}\n\n/*\n * 以下为对外接口函数\n */\nUINT16 getRealEventNum(EventType event_type, UINT32 client_no)\n{\n\tQueCtrl *p_ctrl;\n\n\tif (event_type >= EN_EVENT_TYPE_NUM || client_no >= MAX_CLIENT_NUM)\n\t\treturn 0;\n\n\tp_ctrl = g_event_que[event_type].p_ctrl;\n\tif (p_ctrl == NULL)\t\t//没有此事件队列\n\t\treturn 0;\n\n\tif (p_ctrl->write == p_ctrl->read[client_no])\n\t\treturn 0;\n\n\treturn ((p_ctrl->write + p_ctrl->max_num - p_ctrl->read[client_no]) % \\\n\t\t\t\tp_ctrl->max_num);\n}\n\nUINT16 getNoticeRealEventNum(EventType event_type, UINT32 client_no)\n{\n\tQueCtrl *p_ctrl;\n\n\tif (event_type >= EN_EVENT_TYPE_NUM || client_no >= MAX_CLIENT_NUM)\n\t\treturn 0;\n\n\tp_ctrl = g_event_que[event_type].p_ctrl;\n\tif (p_ctrl == NULL)\t\t//没有此事件队列\n\t\treturn 0;\n\n\tif (p_ctrl->write == p_ctrl->tmp_read[client_no])\n\t\treturn 0;\n\n\treturn ((p_ctrl->write + p_ctrl->max_num - p_ctrl->tmp_read[client_no]) % \\\n\t\t\t\tp_ctrl->max_num);\n}\n\nUINT32 realEventEmpty(EventType event_type, UINT32 client_no)\n{\n\tQueCtrl *p_ctrl;\n\n\tif (event_type >= EN_EVENT_TYPE_NUM || client_no >= MAX_CLIENT_NUM)\n\t\treturn 1;\n\n\tp_ctrl = g_event_que[event_type].p_ctrl;\n\tif (p_ctrl == NULL)\t\t//没有此事件队列\n\t\treturn 1;\n\n\tif (p_ctrl->write == p_ctrl->read[client_no])\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nUINT32 noticeRealEventEmpty(EventType event_type, UINT32 client_no)\n{\n\tQueCtrl *p_ctrl;\n\n\tif (event_type >= EN_EVENT_TYPE_NUM || client_no >= MAX_CLIENT_NUM)\n\t\treturn 1;\n\n\tp_ctrl = g_event_que[event_type].p_ctrl;\n\tif (p_ctrl == NULL)\t\t//没有此事件队列\n\t\treturn 1;\n\n\tif (p_ctrl->write == p_ctrl->tmp_read[client_no])\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nUINT32 realEventEqNoticeRealEvent(EventType event_type, UINT32 client_no)\n{\n\tQueCtrl *p_ctrl;\n\n\tif (event_type >= EN_EVENT_TYPE_NUM || client_no >= MAX_CLIENT_NUM)\n\t\treturn 1;\n\n\tp_ctrl = g_event_que[event_type].p_ctrl;\n\tif (p_ctrl == NULL)\t\t//没有此事件队列\n\t\treturn 1;\n\n\tif (p_ctrl->read[client_no] == p_ctrl->tmp_read[client_no])\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nvoid clearRealEvent(EventType event_type, UINT32 client_no)\n{\n\tQueCtrl *p_ctrl;\n\n\tif (event_type >= EN_EVENT_TYPE_NUM || client_no >= MAX_CLIENT_NUM)\n\t\treturn;\n\n\tp_ctrl = g_event_que[event_type].p_ctrl;\n\tif (p_ctrl == NULL)\t\t//没有此事件队列\n\t\treturn;\n\n\tp_ctrl->read[client_no] = p_ctrl->write;\n\tp_ctrl->tmp_read[client_no] = p_ctrl->write;\n\n\treturn;\n}\n\nvoid clearAllRealEvent(UINT32 client_no)\n{\n\tINT32 i;\n\n\tfor (i=0; i<EN_EVENT_TYPE_NUM; i++)\n\t\tclearRealEvent(i, client_no);\n\n\treturn;\n}\n\nvoid clearAllRealEventByMoniblk(UINT32 client_no)\n{\n\tINT32 i;\n\n\tfor(i=0; i<EN_EVENT_TYPE_NUM; i++)\n\t{\n\t\tif(EN_BI_EVENT == i)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tclearRealEvent(i, client_no);\n\t}\n}\n\nINT32 getRealEvent(EventType event_type, UINT32 client_no, EventData *p_data,\n\t\t\t\t\t\tINT32 mode)\n{\n\tEventQue *p_event_que;\n\tINT32 ret;\n\n\tif (event_type >= EN_EVENT_TYPE_NUM)\n\t\treturn -1;\n\tp_event_que = &g_event_que[event_type];\n\tif (p_event_que->read_cfg_ok != 1)\n\t\treturn -1;\n\n\tswitch (event_type)\n\t{\n\tcase EN_TRIP_EVENT:\t\t\t/*动作事件*/\n\t\tret = getRealTripEvent(client_no, p_data, mode);\n\t\tbreak;\n\tcase EN_RUN_EVENT:\t\t\t\t/*运行记录*/\n\t\tret = getRealRunEvent(client_no, p_data, mode);\n\t\tbreak;\n\tcase EN_CHECK_EVENT:\t\t\t/*自检事件*/\n\tcase EN_BI_EVENT:\t\t\t\t/*开关量变位*/\n\tcase EN_CHAN_A_CHK_EVENT:\t\t/*通道自检*/\n\tcase EN_CHAN_B_CHK_EVENT:\n\tcase EN_CHAN_C_CHK_EVENT:\n\tcase EN_CHAN_D_CHK_EVENT:\n\tcase EN_CHAN_A_STAT_EVENT:\t\t/*通道统计*/\n\tcase EN_CHAN_B_STAT_EVENT:\n\tcase EN_CHAN_C_STAT_EVENT:\n\tcase EN_CHAN_D_STAT_EVENT:\n\tcase EN_ORDER_EVENT:\n\tcase EN_YX_EVENT:\n\t\tret = getRealEventQue(p_event_que, client_no,\n\t\t\t\t\t\t\t\t(INT8 *)&p_data->data, mode);\n\t\tp_data->para_num = p_event_que->para_num;\n\t\tp_data->type = event_type;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t\t//break;\n\t}\n\n\treturn ret;\n}\n\nINT32 ackRealEvent(EventType event_type, UINT32 client_no)\n{\n\tQueCtrl *p_ctrl;\n\n\tif (event_type >= EN_EVENT_TYPE_NUM || client_no >= MAX_CLIENT_NUM)\n\t\treturn -1;\n\n\tp_ctrl = g_event_que[event_type].p_ctrl;\n\tif (p_ctrl == NULL)\t\t//没有此事件队列\n\t\treturn 0;\n\n#ifdef INCLUDE_EVENT_SEM\n#if (OS_TYPE == VXWORKS)\n\tif (semTake(g_event_que[event_type].sem, wait_sem_time) == ERROR)\n\t\treturn -1;\n#endif\n#endif\n\n\tp_ctrl->read[client_no] = p_ctrl->tmp_read[client_no];\n\n#ifdef INCLUDE_EVENT_SEM\n#if (OS_TYPE == VXWORKS)\n\tsemGive(g_event_que[event_type].sem);\n#endif\n#endif\n\n\treturn 0;\n}\n\nUINT16 getHisEventNum(EventType event_type, UINT32 *p_start_no,\n\t\t\t\t\t\tUINT32 *p_last_no)\n{\n\tQueCtrl *p_ctrl;\n\n\tif (event_type >= EN_EVENT_TYPE_NUM)\n\t\treturn 0;\n\n\tp_ctrl = g_event_que[event_type].p_ctrl;\n\tif (p_ctrl == NULL)\t\t//没有此事件队列\n\t\treturn 0;\n\n\tif (p_ctrl->num == 0)\n\t{\n\t\t*p_start_no = 0;\n\t\t*p_last_no = 0;\n\t}\n\telse\n\t{\n\t\t*p_start_no = (p_ctrl->write + p_ctrl->max_num - p_ctrl->num) % \\\n\t\t\t\t\tp_ctrl->max_num;\n\t\t*p_last_no = (p_ctrl->write + p_ctrl->max_num - 1) % p_ctrl->max_num;\n\t}\n\n\treturn (p_ctrl->num);\n}\n\n/*\n * 折半查找\n * 结果找到 mid,找不到,比预查找元素大的在low之后，比预查找元素小的在high之前\n * 即 [high] < key < [low]\n */\nUINT16 binSearchEventQue(EventQue *p_event_que, EveTimeTag *p_search_time\n\t\t\t\t\t\t\t, UINT16 *p_low, UINT16 *p_high)\n{\n\tQueCtrl *p_ctrl;\n\tEveTimeTag *p_event_t;\n\tUINT16 low,high,mid,max_num;\n\tINT32 ret;\n\n\tp_ctrl = p_event_que->p_ctrl;\n\tmax_num = p_event_que->max_num;\n\n\tlow = (p_ctrl->write + max_num - p_ctrl->num) % max_num;\n\thigh = (p_ctrl->write + max_num - 1) % max_num;\n\tif (low > high)\n\t\thigh = high + max_num;\n\n\twhile (low <= high)\n\t{\n\t\tmid = (low + high) / 2;\n\t\tp_event_t = (EveTimeTag *) (p_event_que->p_item + \\\n\t\t\t\t\t\t\t\t\t(mid % max_num) * p_event_que->item_size);\n\t\tret = eveTimeTagCmp(p_search_time, p_event_t);\n\t\tif (ret == 0)\n\t\t\treturn (mid % max_num);\n\t\telse if (ret < 0)\n\t\t\thigh = mid - 1;\n\t\telse\n\t\t\tlow = mid + 1;\n\t}\n\n\t/*查找不满足条件时，使用此值*/\n\t*p_low = (low - 1) % max_num;\n\t*p_high = (high + 1) % max_num;\n\n\treturn 0xffff;\n}\n\n/*\n * 假设队列时顺序队列，未考虑运行中途由于时间不正确，引起的事件时间不正确的情况\n */\nUINT16 queryHisEventByTime(EventType event_type,\n\t\t\t\t\t\t\tEveTimeTag *p_start_time, EveTimeTag *p_end_time,\n\t\t\t\t\t\t\tUINT32 *p_start_no, UINT32 *p_last_no)\n{\n\tEventQue *p_event_que;\n\tEveTimeTag *p_event_min_t,*p_event_max_t;\n\tUINT16 start,end;\n\tUINT16 low,high,target,num;\n\n\tif (event_type >= EN_EVENT_TYPE_NUM)\n\t\treturn 0;\n\n\tp_event_que = &g_event_que[event_type];\n\tif (p_event_que->read_cfg_ok != 1)\n\t\treturn 0;\n\n\tif (p_event_que->p_ctrl->num == 0)\n\t{\n\t\t*p_start_no = 0;\n\t\t*p_last_no = 0;\n\t\treturn 0;\n\t}\n\n\t/*检查边界条件*/\n\tstart = (p_event_que->p_ctrl->write + p_event_que->max_num - \\\n\t\t\t\tp_event_que->p_ctrl->num) % p_event_que->max_num;\n\tend = (p_event_que->p_ctrl->write + p_event_que->max_num - 1) % \\\n\t\t\t\tp_event_que->max_num;\n\tp_event_min_t = (EveTimeTag *) (p_event_que->p_item + \\\n\t\t\t\t\t\t\t\t\t\tstart * p_event_que->item_size);\n\tif (eveTimeTagCmp(p_event_min_t, p_end_time) > 0)\n\t{\n\t\t*p_start_no = 0;\n\t\t*p_last_no = 0;\n\t\treturn 0;\n\t}\n\n\tp_event_max_t = (EveTimeTag *) (p_event_que->p_item + \\\n\t\t\t\t\t\t\t\t\t\tend * p_event_que->item_size);\n\tif (eveTimeTagCmp(p_event_max_t, p_start_time) < 0)\n\t{\n\t\t*p_start_no = 0;\n\t\t*p_last_no = 0;\n\t\treturn 0;\n\t}\n\n\tif (eveTimeTagCmp(p_event_min_t, p_start_time) >= 0)\n\t{\n\t\t*p_start_no = start;\n\t}\n\telse\n\t{\n\t\tlow = start;\n\t\thigh = end;\n\t\ttarget = binSearchEventQue(p_event_que, p_start_time, &low, &high);\n\t\tif (target != 0xffff)\t/*找到相同时间的事件*/\n\t\t\t*p_start_no = target;\n\t\telse\n\t\t\t*p_start_no = high;\n\t}\n\n\tif (eveTimeTagCmp(p_event_max_t, p_end_time) <= 0)\n\t{\n\t\t*p_last_no = end;\n\t}\n\telse\n\t{\n\t\tlow = start;\n\t\thigh = end;\n\t\ttarget = binSearchEventQue(p_event_que, p_end_time, &low, &high);\n\t\tif (target != 0xffff)\t/*找到相同时间的事件*/\n\t\t\t*p_last_no = target;\n\t\telse\n\t\t\t*p_last_no = low;\n\t}\n\n\t//有可能存储了最大条数\n\tnum = (*p_last_no + 1 + p_event_que->max_num - *p_start_no);\n\tif (num > p_event_que->max_num) num %= p_event_que->max_num;\n\n\treturn num;\n}\n\nINT32 getHisEvent(EventType event_type, HisEventReadCtrl *p_read_ctrl\n\t\t\t\t\t, EventData *p_data)\n{\n\tEventQue *p_event_que;\n\tUINT16 read,write;\n\tUINT16 last_no;\n\tINT8 *p_item;\n\tINT32 ret;\n\n\tif (event_type >= EN_EVENT_TYPE_NUM)\n\t\treturn -1;\n\n\tp_event_que = &g_event_que[event_type];\n\tif (p_event_que->read_cfg_ok != 1)\n\t\treturn -1;\n\n\t/*在取历史事件数据时，防止被用户删除了历史数据,读失败*/\n\tif (p_event_que->p_ctrl->num == 0)\n\t\treturn -1;\n\n\tlast_no = p_read_ctrl->last_no;\n\tif (last_no < p_read_ctrl->start_no)\n\t\tlast_no += p_event_que->max_num;\n\n\twrite = p_event_que->p_ctrl->write;\n\tif (write < p_read_ctrl->start_no)\n\t\twrite += p_event_que->max_num;\n\n\tif (p_read_ctrl->order == 0)\n\t\tread = p_read_ctrl->start_no + p_read_ctrl->off;\n\telse\n\t\tread = last_no - p_read_ctrl->off;\n\n\tif (write > read && write <= last_no)\t/*已有新事件覆盖，返回读失败*/\n\t\treturn -1;\n\n\tread %= p_event_que->max_num;\n\t/*正在写,要求互斥,读失败*/\n\tif (p_event_que->write_flag == 1 && read == p_event_que->p_ctrl->write)\n\t\treturn -1;\n\n\tp_data->para_num = p_event_que->para_num;\n\tp_data->type = event_type;\n\n\tswitch (event_type)\n\t{\n\tcase EN_TRIP_EVENT:\t\t\t/*动作事件*/\n\t\tret = getHisTripEvent(read, p_data);\n\t\tbreak;\n\tcase EN_RUN_EVENT:\t\t\t\t/*运行记录*/\n\t\tret = getHisRunEvent(read, p_data);\n\t\tbreak;\n\tcase EN_CHECK_EVENT:\t\t\t/*自检事件*/\n\tcase EN_BI_EVENT:\t\t\t\t/*开关量变位*/\n\tcase EN_CHAN_A_CHK_EVENT:\t\t/*通道自检*/\n\tcase EN_CHAN_B_CHK_EVENT:\n\tcase EN_CHAN_C_CHK_EVENT:\n\tcase EN_CHAN_D_CHK_EVENT:\n\tcase EN_CHAN_A_STAT_EVENT:\t\t/*通道统计*/\n\tcase EN_CHAN_B_STAT_EVENT:\n\tcase EN_CHAN_C_STAT_EVENT:\n\tcase EN_CHAN_D_STAT_EVENT:\n\tcase EN_ORDER_EVENT:\n\tcase EN_YX_EVENT:\n\t\tp_item = (p_event_que->p_item + read * p_event_que->item_size);\n\t\tSRAM_CPY((void *)&(p_data->data), p_item, p_event_que->item_size);\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t\t//break;\n\t}\n\n\treturn ret;\n}\n\n/*\n * 以下测试用例用\n */\nvoid eventShow(EventData *p_data, INT32 show_type)\n{\n\tINT32 i;\n\tINT32 chan_no;\n\tEventParaCfg *p_chan_cfg;\n\tINT8 phase[4];\n\tEvent *cp;\n\n\tcp = getGpEvent();\n\tif (p_data->type >= EN_EVENT_TYPE_NUM)\n\t{\n\t\tprintf(\"unknow event\\n\");\n\t\t\treturn;\n\t}\n\tprintf(\"------------------------------------------------------\\n\");\n\tprintf(\"%s:\", s_event_sram_name[p_data->type]);\n\tswitch (p_data->type)\n\t{\n\tcase EN_TRIP_EVENT:\t\t\t/*动作事件*/\n\t\tshowEventTime(&p_data->data.trip.t, show_type);\n\t\tphase[0] = ' ';\n\t\tphase[1] = ' ';\n\t\tphase[2] = ' ';\n\t\tphase[3] = 0;\n\t\tif ((p_data->data.trip.st_val & 0x02) != 0)\n\t\t{\n\t\t\tphase[0] = 'A';\n\t\t}\n\t\tif ((p_data->data.trip.st_val & 0x04) != 0)\n\t\t{\n\t\t\tphase[1] = 'B';\n\t\t}\n\t\tif ((p_data->data.trip.st_val & 0x08) != 0)\n\t\t{\n\t\t\tphase[2] = 'C';\n\t\t}\n\t\tprintf(\"ret_ms=%u,no=%d,st_no=%d,st_val=%x %s, q=%x, fault_no=%d,fan=%d,para:\\n\",\n\t\t\t\t\tp_data->data.trip.ret_ms,\n\t\t\t\t\tp_data->data.trip.no, p_data->data.trip.st_no,\n\t\t\t\t\tp_data->data.trip.st_val, phase, p_data->data.trip.q,\n\t\t\t\t\tp_data->data.trip.fault_no, p_data->data.trip.fan);\n\t\tfor (i=0; i<p_data->para_num; i++)\n\t\t{\n\t\t\tSHOW_INVAL_VAL(&p_data->data.trip.val[i]\n\t\t                   ,cp->p_trip_para_cfg[p_data->data.trip.para_no[i]].p_invar\n\t\t                   ,cp->p_trip_para_cfg[p_data->data.trip.para_no[i]].p_datafield);\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tbreak;\n\tcase EN_RUN_EVENT:\t\t\t\t/*运行记录*/\n\t\tshowEventTime(&p_data->data.run.t, show_type);\n\t\tprintf(\"no=%d,st_no=%d,st_val=%u,para:\\n\",\n\t\t\t\t\tp_data->data.run.no, p_data->data.run.st_no,\n\t\t\t\t\tp_data->data.run.st_val);\n\t\tfor (i=0; i<p_data->para_num; i++)\n\t\t\tSHOW_INVAL_VAL(&p_data->data.run.val[i],\n\t\t\tcp->p_run_para_cfg[p_data->data.run.para_no[i]].p_invar,\n\t\t\tcp->p_run_para_cfg[p_data->data.run.para_no[i]].p_datafield);\n\t\tprintf(\"\\n\");\n\t\tbreak;\n\tcase EN_CHECK_EVENT:\t\t\t/*自检事件*/\n\t\tshowEventTime(&p_data->data.sys_chk.t, show_type);\n\t\tprintf(\"no=%d,st_no=%d,st_val=%u,q=%x\\n\",\n\t\t\t\t\tp_data->data.sys_chk.no, p_data->data.sys_chk.st_no,\n\t\t\t\t\tp_data->data.sys_chk.st_val, p_data->data.sys_chk.q);\n\t\tbreak;\n\tcase EN_BI_EVENT:\t\t\t\t/*开关量变位*/\n\tcase EN_YX_EVENT:\n\t\tshowEventTime(&p_data->data.bi.t, show_type);\n\t\tprintf(\"no=%d,st_no=%d,st_val=%u,old_val=%d, q=%x\\n\",\n\t\t\t\t\tp_data->data.bi.no, p_data->data.bi.st_no,\n\t\t\t\t\tp_data->data.bi.st_val, p_data->data.bi.old_val, p_data->data.bi.q);\n\t\tbreak;\n\tcase EN_CHAN_A_CHK_EVENT:\t\t/*通道自检*/\n\tcase EN_CHAN_B_CHK_EVENT:\n\tcase EN_CHAN_C_CHK_EVENT:\n\tcase EN_CHAN_D_CHK_EVENT:\n\t\tshowEventTime(&p_data->data.chan_chk.t, show_type);\n\t\tprintf(\"no=%d,val:\\n\",p_data->data.chan_chk.no);\n\t\tchan_no = p_data->type - EN_CHAN_A_CHK_EVENT;\n\t\tp_chan_cfg = cp->p_chan_chk_cfg[chan_no];\n\t\tfor (i=0; i<p_data->para_num; i++)\n\t\t\tSHOW_INVAL_VAL(&p_data->data.chan_chk.val[i],\n\t\t\t\t\t\t\t\tp_chan_cfg[i].p_invar, p_chan_cfg[i].p_datafield);\n\t\tprintf(\"\\n\");\n\t\tbreak;\n\tcase EN_CHAN_A_STAT_EVENT:\t\t/*通道统计*/\n\tcase EN_CHAN_B_STAT_EVENT:\n\tcase EN_CHAN_C_STAT_EVENT:\n\tcase EN_CHAN_D_STAT_EVENT:\n\t\tshowEventTime(&p_data->data.chan_sta.t, show_type);\n\t\tprintf(\"no=%d,val:\\n\",p_data->data.chan_sta.no);\n\t\tchan_no = p_data->type - EN_CHAN_A_STAT_EVENT;\n\t\tp_chan_cfg = cp->p_chan_stat_cfg[chan_no];\n\t\tfor (i=0; i<p_data->para_num; i++)\n\t\t\tSHOW_INVAL_VAL(&p_data->data.chan_sta.val[i],\n\t\t\t\t\t\t\t\tp_chan_cfg[i].p_invar, p_chan_cfg[i].p_datafield);\n\t\tprintf(\"\\n\");\n\t\tbreak;\n\tcase EN_ORDER_EVENT:\n\t\tshowEventTime(&p_data->data.order.t, show_type);\n\t\tprintf(\"no=%d,st_no=%d,ctrl_obj_board=%d,ctrl_obj_addr=0x%x,\",p_data->data.order.no,\n\t\t\t\tp_data->data.order.inf.index,p_data->data.order.inf.ctrl_obj_board,\n\t\t\t\tp_data->data.order.inf.ctrl_obj_addr);\n\t\tprintf(\"ctrl_con_id=%d,ctrl_src_id=%d,ctrl_src_type=%d,ctrl_type=%d,\",\n\t\t\t\tp_data->data.order.inf.ctrl_con_id,p_data->data.order.inf.ctrl_src_id,\n\t\t\t\tp_data->data.order.inf.ctrl_src_type,p_data->data.order.inf.ctrl_type);\n\t\tprintf(\"ctrl_step=%d,ctrl_value=%x,ctrl_para=%d,ctrl_cause=%d\\n\",\n\t\t\t\tp_data->data.order.inf.ctrl_step,p_data->data.order.inf.ctrl_value.l_value,\n\t\t\t\tp_data->data.order.inf.ctrl_para,p_data->data.order.inf.ctrl_cause);\n\t\tbreak;\n\t}\n\treturn;\n}\n\nvoid showHisEvent(EventType event_type, INT32 show_type)\n{\n\tUINT16 i,num;\n\tHisEventReadCtrl read_ctl;\n\tEventData event;\n\n\tnum = getHisEventNum(event_type, &read_ctl.start_no, &read_ctl.last_no);\n\tprintf(\"---get event num=%d\\n\",num);\n\tread_ctl.order = 0;\t\t//升序查找\n\tfor (i=0; i<num; i++)\n\t{\n\t\tread_ctl.off = i;\n\t\tif (getHisEvent(event_type, &read_ctl, &event) == 0)\n\t\t{\n\t\t\teventShow(&event, show_type);\n\t\t}\n\t}\n}\n\nvoid showEventQue(EventType event_type)\n{\n\tEventQue *p_event_que;\n\tEventParaCtrl *p_para_ctrl;\n\n\tif (event_type >= EN_EVENT_TYPE_NUM)\n\t\treturn;\n\n\tp_event_que = &g_event_que[event_type];\n\n\tprintf(\"%s queue information\\n\", s_event_sram_name[event_type]);\n\tprintf(\"---------------------------------------------\\n\");\n\tshowQueCtrl(p_event_que->p_ctrl);\n\tprintf(\"---------------------------------------------\\n\");\n\tp_para_ctrl = p_event_que->p_para_ctrl;\n\tprintf(\"para ctrl:max_num=%d,write=%d\\n\",\n\t\t\t\tp_para_ctrl->max_num, p_para_ctrl->write);\n\n\treturn;\n}\n\nvoid showEventCtrl(EventType event_type)\n{\n\tQueCtrl *p_ctrl;\n\tINT32 i;\n\t\n\tp_ctrl = g_event_que[event_type].p_ctrl;\n\tprintf(\"--type=%d\\n\",       event_type);\n\tprintf(\"--max_num=%d\\n\",    p_ctrl->max_num);\n\tprintf(\"--para_num=%d\\n\",   p_ctrl->para_num);\n\tprintf(\"--num=%d\\n\",        p_ctrl->num);\n\tprintf(\"--write=%d\\n\",      p_ctrl->write);\n\tprintf(\"--no=%d\\n\",         p_ctrl->no);\n\tprintf(\"--tmp_write=%d\\n\",  p_ctrl->tmp_write);\n\tfor(i=0; i<MAX_CLIENT_NUM; i++)\n\t{\n\t\tprintf(\"--read[%d]=%d, \",  i, p_ctrl->read[i]);\n\t\tprintf(\"tmp_read[%d]=%d\\n\",i, p_ctrl->tmp_read[i]);\n\t}\n}\n\n\n",
					"file": "sy.src/sy.hmi/rttask/src/event.c",
					"file_size": 122131,
					"file_write_time": 131316227326571533,
					"settings":
					{
						"buffer_size": 114785,
						"encoding": "Western (Windows 1252)",
						"line_ending": "Windows",
						"scratch": true
					}
				},
				{
					"file": "sy.src/sy.hmi/rttask/inc/rtcommon.h",
					"settings":
					{
						"buffer_size": 8534,
						"encoding": "UTF-8",
						"line_ending": "Windows"
					}
				},
				{
					"contents": "\n#ifndef\t__INC_EVENT_H\n#define\t__INC_EVENT_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include \"syslave.h\"\n#include \"ctrl.h\"\n\n/*LED灯变化消息使用的类型定义*/\n#define LED_PIPE_MSG_TYPE\t\t7\n#define LED_MSG_STATE_CHANGE\t0\n#define LED_MODULE_ID\t\t\t5\n\n#define EVENT_MAX_BIT_MASK\t\t0x0fff\n\n#define\t\tGOOSE_Q_VALID\t\t0x01\n#define\t\tGOOSE_Q_RX_TEST\t\t0x02\n#define\t\tGOOSE_Q_LINK_OK\t\t0x04\n\n#define\t\tSV_Q_VALID\t\t\t0x01\n#define\t\tSV_Q_RX_TEST\t\t0x02\n#define\t\tSV_Q_LINK_OK\t\t0x04\n#define\t\tSV_Q_DS_ENA\t\t\t0x08\t\t// 控制块投退软压板\n#define\t\tSV_Q_SYNC_ERR\t\t0x10\n#define\t\tSV_Q_RES\t\t\t0x20\n#define\t\tSV_Q_OVERFLOW\t\t0x40\n#define\t\tSV_Q_SUBST\t\t\t0x80\n\n/*时标定义*/\ntypedef struct\n{\n\tINT32  sec;\n\tINT32  us;\n} EveTimeTag;\n\n/*事件类型定义,相当于INT32*/\ntypedef enum\n{\n\tEN_TRIP_EVENT,\t\t\t\t/*动作事件*/\n\tEN_CHECK_EVENT,\t\t\t\t/*自检事件*/\n\tEN_BI_EVENT,\t\t\t\t/*开关量变位*/\n\tEN_RUN_EVENT,\t\t\t\t/*运行记录*/\n\tEN_CHAN_A_CHK_EVENT,\t\t/*通道自检*/\n\tEN_CHAN_B_CHK_EVENT,\t\t/*通道自检*/\n\tEN_CHAN_C_CHK_EVENT,\t\t/*通道自检*/\n\tEN_CHAN_D_CHK_EVENT,\t\t/*通道自检*/\n\tEN_CHAN_A_STAT_EVENT,\t\t/*通道统计*/\n\tEN_CHAN_B_STAT_EVENT,\t\t/*通道统计*/\n\tEN_CHAN_C_STAT_EVENT,\t\t/*通道统计*/\n\tEN_CHAN_D_STAT_EVENT,\t\t/*通道统计*/\n\tEN_ORDER_EVENT,\t\t\t\t/*控制命令记录*/\n\tEN_YX_EVENT,\t\t\t\t/*带时标的BI记录*/\n\tEN_EVENT_TYPE_NUM\n} EventType;\n\n/*客户号的定义*/\n#define MAX_CLIENT_NUM\t\t32\n#define LCD_CLIENT_NO\t\t0\n#define PRINT_CLIENT_NO\t\t1\n#define IEC103_CLIENT_NO\t2\t// 串口3，网口8\n#define IEC61850_CLIENT_NO\t16\n\n\ntypedef enum\n{\n\tEN_RTTASK_READ_MODE_NO_ACK,\n\tEN_RTTASK_READ_MODE_ACK,\n\tEN_RTTASK_READ_MODE_NUM\n} RttaskReadMode;\n\n/*\n * 动作事件启动时间=t-ret_ms\n */\n\n/*用于记录带参数事件的参数结构*/\n/*typedef struct\n{\n\tUINT32\tno;\t\t\t\n\tINT32\tval;\n} IndexPara;*/\n\n#define MAX_EVENT_PARA_NUM\t24\ntypedef struct\n{\n\tEveTimeTag\tt;\t\t/*故障时间*/\n\tUINT16\tno;\t\t\t/*事件序号*/\n\tUINT16\tst_no;\t\t/*相对于事件引用表的排序号，从0开始*/\n\tUINT8\tst_val;\t\t/*状态值*/\n\tUINT8\tpara_num;\t/*参数个数*/\t\n\tUINT16\tq;\t\t\t/*品质位*/\n\tUINT32\tret_ms;\t\t/*相对时间,相对于本次故障启动时的时间*/\n\tUINT16\tfan; \t\t/*故障序号*/\n\tUINT16\tfault_no;\t/*整组报告序号*/\n\tUINT16\tbak[2];\n\tUINT16\tpara_no[MAX_EVENT_PARA_NUM];\t/*参数值的索引号*/\n\tFLOAT32\tval[MAX_EVENT_PARA_NUM];\t/*动作时故障参数值*/\n} TripEvent;\n\ntypedef struct\n{\n\tEveTimeTag\tt;\n\tUINT16\tno;\t\t\t/*事件序号*/\n\tUINT16\tst_no;\t\t/*相对于事件引用表的排序号，从0开始*/\n\tUINT8\tst_val;\t\t/*状态值*/\n\tUINT8\tpara_num;\t/*参数个数*/\n\tUINT16\tbak1;\t\t/*指向参数区索引,参数值个数可配置*/\n\tUINT16\tpara_no[MAX_EVENT_PARA_NUM];\t/*参数值的索引号*/\n\tINT32\tval[MAX_EVENT_PARA_NUM];\t/*动作时故障参数值*/\n} ParaEvent;\n\n/*不带参数的事件结构体,用于自检、开入变位等,16*/\ntypedef struct\n{\n\tEveTimeTag\tt;\n\tUINT16\tno;\t\t\t/*事件序号*/\n\tUINT16\tst_no;\t\t/*相对于事件引用表的排序号，从0开始*/\n\tUINT8\tst_val;\t\t/*状态值*/\n\tUINT8\told_val;\n\tUINT8\tvalid;\t\t/*pack,四字节边界对齐*/\n\tUINT8\tres;\n\tUINT16\tq;\t\t\t/*品质位*/\n} NoParaEvent;\n\n#define MAX_CHAN_PARA_NUM\t32\n/*通道自检,参数配置个数注意四字节边界对齐*/\ntypedef struct\n{\n\tEveTimeTag\tt;\n\tUINT16\tno;\t\t\t/*记录序号*/\n\tUINT16\tbak;\n\tINT16\tval[MAX_CHAN_PARA_NUM];\t\t/*发生时刻的值*/\n} ChanChkEvent;\n\n/*通道统计*/\ntypedef struct\n{\n\tEveTimeTag\tt;\n\tUINT16\tno;\t\t\t/*记录序号*/\n\tUINT16\tbak;\n\tINT32\tval[MAX_CHAN_PARA_NUM];\t\t/*发生时刻的值*/\n}ChanStatEvent;\n\n/*控制命令记录*/\ntypedef struct\n{\n\tEveTimeTag\tt;\n\tUINT16\tno;\t\t\t/*记录序号*/\n\tCtrlRpt inf;\n}OrderEvent;\n\ntypedef struct\n{\n\tUINT16\t\t\t\ttype;\t\t/*类型，事件类型*/\n\tUINT16\t\t\t\tpara_num;\t/*参数个数*/\n\t\n\tUINT16\t\t\t\tvalid;\t\t//事件有效性，内部使用\n\tUINT16\t\t\t\tbak;\n\tunion\n\t{\n\t\tTripEvent\t\ttrip;\t\t/*动作事件*/\n\t\tParaEvent\t\trun;\t\t/*运行记录*/\n\t\tNoParaEvent\t\tsys_chk;\t/*自检事件*/\n\t\tNoParaEvent\t\tbi;\t\t\t/*开关量变位*/\n\t\tNoParaEvent\t\tyx;\t\t\t// SOE变位\n\t\tChanChkEvent\tchan_chk;\t/*通道自检*/\n\t\tChanStatEvent\tchan_sta;\t/*通道统计*/\n\t\tOrderEvent\t\torder;\t\t/*控制命令记录*/\n\t} data;\n} EventData;\n\ntypedef struct\n{\n\tUINT32\tstart_no;\t\t/*查询的起始索引*/\n\tUINT32\tlast_no;\t\t/*查询的结束索引*/\n\tUINT16\torder;\t\t\t/*读取的顺序,0-正序,从start_no开始,1-倒序,从last_no开始*/\n\tUINT16\toff;\t\t\t/*从开始点的偏移*/\n}HisEventReadCtrl;\n\n/*实时取得整组记录的故障值*/\n/*\n * 一次整组动作信息\n * 在保护中，所有的波形都应该是通过报告调用出来的，即保护中整组报告与波形是捆绑的。\n * 触发类型定义:\n * 0-跳闸触发,优先级最高\n * 1-启动触发\n * 2-远方通信触发录波\n * 3-开入变位触发\n * 4-手动录波，优先级最低\n * 优先存储触发类型为0的整组故障事件,存储覆盖非0的事件\n */\n// MAX_WAVE_FAN_NUM在本文件中定义便于IEC103等使用\n#define MAX_WAVE_FAN_NUM\t16\t\t\t\t\t/*每次整组最大的录波分块数*/\n\n#define MAX_FAULT_PARA_NUM\t24\ntypedef struct\n{\n\tEveTimeTag\tt;\t\t\t\t\t/*发生时间*/\n\tUINT16\tnof;\t\t\t\t\t/*电网故障序号,用于与波形数据关联*/\n\tUINT16\tno:12;\t\t\t\t\t/*记录序号*/\n\tUINT16\ttrig_type:3;\t\t\t/*触发类型*/\n\tUINT16\tvalid:1;\t\t\t\t/*标志，BIT=1,波形有效*/\n\tUINT16\ttrip_event_num;\t\t\t/*以下由LCD显示实时整组相关的事件检索用*/\n\tUINT16\tchk_event_num;\n\tUINT16\tbi_event_num;\n\tUINT16\ttrip_event_start;\n\tUINT16\tchk_event_start;\n\tUINT16\tbi_event_start;\n\tUINT16\ttrip_event_end;\t\n\tUINT16\tchk_event_end;\n\tUINT16\tbi_event_end;\n\tUINT16\tfan_num;\t\t\t\t/*波形分块数*/\n\tUINT16\tfan_start;\t\t\t\t/*第一块波形的故障序号,用于与波形数据关联*/\n\tUINT16\tpara_num;\t\t\t\t/*参数个数*/\n\t/*故障简报值,如故障相别，测距结果，故障相电压、电流等*/\t\t\t\t\t\t\t\t\n\tFLOAT32\tpara_val[MAX_FAULT_PARA_NUM];\n} FaultPara;\n\n/*\n * 触发类型定义:\n * 0-跳闸触发,优先级最高\n * 1-启动触发\n * 2-远方通信触发录波\n * 3-开入变位触发\n * 4-手动录波，优先级最低\n * 优先存储触发类型为0的整组故障事件,存储覆盖非0的事件\n */\ntypedef enum\n{\n\tTRIP_TRIG,\n\tPICKUP_TRIG,\n\tMAN_REC_WAVE_TRIG,\n\tFAULT_TRIG_TYPE_NUM\n} FaultTrigType;\n\ntypedef struct\n{\n\tEveTimeTag\tt;\t\t\t\t\t\t/*发生时间*/\n\tUINT16\t\tnof;\t\t\t\t\t/*电网故障序号,用于与波形数据关联*/\n\tUINT16\t\tno:12;\t\t\t\t\t/*记录序号*/\n\tUINT16\t\ttrig_type:3;\t\t\t/*触发类型*/\n\tUINT16\t\tvalid:1;\t\t\t\t/*标志，BIT=1,波形有效*/\n\tUINT16\t\ttrip_event_num;\t\t\t/*存在.rpt文件中动作事件的数目*/\n\tUINT16\t\tchk_event_num;\t\t\t/*存在.rpt文件中自检事件的数目*/\n\tUINT16\t\tbi_event_num;\t\t\t/*存在.rpt文件中变位事件的数目*/\n\tUINT16\t\tfan_num;\t\t\t\t/*波形分块数*/\n\tUINT16\t\tfan_start;\t\t\t\t/*第一块波形的故障序号,用于与波形数据关联*/\n\tUINT16\t\tpara_num;\t\t\t\t/*参数个数*/\n\tUINT16\t\tset_num;\t\t\t\t/*整组中记录中写入的定值个数*/\n\tUINT16\t\tbi_num;\t\t\t\t\t/*组故障前存储的开关量个数*/\n\tUINT16\t\tchk_num;\t\t\t\t/*组故障前存储的自检量个数*/\n\tUINT16\t\tbak;\n} FaultHead;\n\n\ntypedef struct\n{\n\tEveTimeTag \tstart_t;\t/*录波采样第一点时间*/\n\tEveTimeTag \ttrig_t;\t\t/*录波触发时间*/\n\tUINT16\tfan;\t\t\t/*故障序号*/\n\tUINT16\trec_freq;\t\t/*录波频率*/\n\tUINT16\trec_start_dot;\t/*录波数据区起始点*/\n\tUINT16\trec_dot_num;\t/*录波数据区点数*/\n} WaveFanBlk;\n\n\n/*整组故障记录数据域的定义,相当于INT32*/\ntypedef enum\n{\n\tFAULT_DF_HEAD,\t\t\t/*整组故障头,FaultFileHead*/\n\tFAULT_DF_WAVE_BKL,\t\t/*录波分块数,结构见SampBlkHead*/\n\tFAULT_DF_SET_VAL,\t\t/*整组故障时的定值,结构SettingValue*/\n\tFAULT_DF_PARA_VAL,\t\t/*整组故障参数值域,为FLOAT32的数组*/\n\tFAULT_DF_BI_VAL,\t\t/*整组故障前开关量值,为UINT16的数组*/\n\tFAULT_DF_CHK_STATE,\t\t/*整组故障前自检状态值,为UINT16的数组*/\n\tFAULT_DF_TRIP_EVENT,\t/*动作事件,结构见EventData*/\n\tFAULT_DF_BI_EVENT,\t\t/*开关量变位,结构见NoParaEvent*/\t\n\tFAULT_DF_CHECK_EVENT,\t/*自检事件,结构见NoParaEvent*/\n\tFAULT_DF_ALL\t\t\t/*整组故障信息,分配需要的全部空间*/\n} FaultDataField;\n\ntypedef struct\n{\n\tEveTimeTag\tt;\t\t\t/*发生时间*/\n\tUINT16\t\tnof;\t\t\t/*电网故障序号,用于与波形数据关联*/\n\tUINT16\t\tno:12;\t\t\t/*记录序号*/\n\tUINT16\t\ttrig_type:3;\t/*触发类型*/\n\t/*写完.rpt文件后,计算个数*/\n\tUINT16\t\ttrip_event_num;\t/*最后存在.rpt文件中动作事件的数目*/\n\tUINT16\t\tchk_event_num;\t/*最后存在.rpt文件中自检事件的数目*/\n\tUINT16\t\tbi_event_num;\t/*最后存在.rpt文件中变位事件的数目*/\n\tUINT16\t\ttrip_event_start;\n\tUINT16\t\tchk_event_start;\n\tUINT16\t\tbi_event_start;\n\tUINT16\t\ttrip_event_end;\t\n\tUINT16\t\tchk_event_end;\n\tUINT16\t\tbi_event_end;\n\tUINT16\t\tpara_num;\n\tUINT16\t\ttotal_dot_num;\t\t\t/*录波总点数*/\n\tUINT16\t\tfan_num;\t\t\t\t/*录波总块数*/\n} FaultFileHead;\n/*\n * 整组故障读取控制头,先取FaultIndex,在按各类分别内存在取值\n * 使用FAULT_DF_ALL，整组故障信息返回的值次序如下\n * sizeof(FaultFileHead)*1\n * sizeof(SampBlkHead)*block_num\t\t录波分块控制头\n * sizeof(VALUE)*set_num\t故障发生时定值信息,保护定值,保护软压板\n * sizeof(float)*ai_num;\t\t故障简报值,如故障相别，测距结果，故障相电压、电流等\n * sizeof(UINT32)*(di_num+31)/32\t动作前开关量值\n * sizeof(EventData)*trip_event_num\t动作事件\n * sizeof(EventData)*bi_event_num\t开入变位事件\t\n * sizeof(EventData)*chk_event_num\t自检事件\n */\ntypedef struct\n{\n\tFaultDataField\tfield;\t\t\t/*数据域*/\n\tUINT16\t\t\toff;\t\t\t/*起始偏移*/\n\tUINT16\t\t\tnum;\t\t\t/*读取的个数*/\n}FaultReadCtrl;\n\n/*\n * 可以按照标识序号为NOF，或者fan来索引故障波形列表,\n * 按FAN取索引表,可以由blk_no取得COMTRADE中的某一块\n */\n\n/*波形列表类型定义,相当于INT32*/\ntypedef enum\n{\n\tEN_TAB_INDEX_BY_NOF,\t\t/*以NOF(电网故障序号)为索引类型*/\n\tEN_TAB_INDEX_BY_FAN,\t\t/*以FAN(故障序号)为索引类型*/\n\tEN_TAB_INDEX_NUM\n} WaveTabType;\n\ntypedef struct\n{\n\tEveTimeTag \tstart_t;\t/*录波采样第一点时间*/\n\tEveTimeTag \ttrig_t;\t\t/*录波触发时间*/\n\tUINT16\t\tnof;\t\t/*电网故障序号,用于与波形数据关联*/\n\tUINT16\t\tfan;\t\t/*故障序号*/\n\tUINT16\t\tfan_num;\t/*波形分块数*/\n\t/*在一次整组录波中的波形块号,可以作为COMTRADE中多块采样的索引*/\n\tUINT16\t\tblk_no;\t\t\n} WaveTabItem;\n\n/*波形文件名定义*/\nenum\n{\n\tEN_WAVE_USER_ID,\n\tEN_WAVE_DEBUG_ID\n};\n\n/*\n * \"/wave/comtrade\"\n * \"/wave/debug\"\n */\nEXTERN INT8 *gp_wave_file_dir[];\n\nenum\n{\n\tEN_FAULT_HDR_NAME_ID,\n\tEN_FAULT_CFG_NAME_ID,\n\tEN_FAULT_DAT_NAME_ID,\n\tEN_FAULT_RPT_NAME_ID,\n\tEN_FAULT_DES_NAME_ID,\n\tEN_FAULT_MID_NAME_ID,\n\tEN_FAULT_FILE_TYPE_NUM\n};\n\n/*\n * \".hdr\"\n * \".cfg\"\n * \".dat\"\n * \".rpt\"\n */\nEXTERN INT8 *gp_fault_file_ext_name[];\n\n/*实时事件读取接口*/\nEXTERN UINT32 noticeRealEventEmpty(EventType event_type, UINT32 client_no);\nEXTERN UINT32 realEventEmpty(EventType event_type, UINT32 client_no);\nEXTERN UINT16 getNoticeRealEventNum(EventType event_type, UINT32 client_no);\nEXTERN UINT16 getRealEventNum(EventType event_type, UINT32 client_no);\nUINT32 realEventEqNoticeRealEvent(EventType event_type, UINT32 client_no);\nEXTERN void clearRealEvent(EventType event_type, UINT32 client_no);\nEXTERN void clearAllRealEvent(UINT32 client_no);\nEXTERN INT32 getRealEvent(EventType event_type, UINT32 client_no, \n\t\t\t\t\t\t\tEventData *p_data, INT32 mode);\nEXTERN INT32 ackRealEvent(EventType event_type, UINT32 client_no);\n\n/*历史事件读取接口*/\nEXTERN UINT16 getHisEventNum(EventType event_type, UINT32 *p_start_no, \n\t\t\t\t\t\t\t\tUINT32 *p_last_no);\nEXTERN UINT16 queryHisEventByTime(EventType event_type, \n\t\t\t\t\t\t\tEveTimeTag *p_start_time, EveTimeTag *p_end_time,\n\t\t\t\t\t\t\tUINT32 *p_start_no, UINT32 *p_last_no);\nEXTERN INT32 getHisEvent(EventType event_type, HisEventReadCtrl *p_read_ctrl, \n\t\t\t\t\t\t\tEventData *p_data);\n\n/*实时整组故障记录读取接口*/\n/*\n * 建议用realFaultEmpty来判断是否有事件存在,1-空,0-非空，\n * 调用getRealFaultNum需遍历整个队列，调用时间长\n */\nEXTERN UINT32 noticeRealFaultEmpty(UINT32 client_no);\nEXTERN UINT32 realFaultEmpty(UINT32 client_no);\nEXTERN UINT16 getNoticeRealFaultNum(UINT32 client_no);\nEXTERN UINT16 getRealFaultNum(UINT32 client_no);\nEXTERN UINT32 realFaultEqNoticeRealFault(UINT32 client_no);\nEXTERN void clearRealFaultVal(UINT32 client_no);\nEXTERN INT32 getRealFaultVal(UINT32 client_no, FaultPara *p_data, INT32 mode);\nEXTERN INT32 ackRealFaultVal(UINT32 client_no);\n\n/*历史整组故障记录读取接口*/\nEXTERN UINT16 getHisFaultNum(UINT32 *p_start_no, UINT32 *p_last_no);\nEXTERN UINT16 queryHisFaultByTime(EveTimeTag *p_start_time, \n\t\t\t\t\t\t\t\t\tEveTimeTag *p_end_time, \n\t\t\t\t\t\t\t\t\tUINT32 *p_start_no, UINT32 *p_last_no);\nEXTERN INT32 getHisFaultHead(HisEventReadCtrl *p_read_ctrl, FaultHead *p_data);\n/*\n * 对于整组故障前开关量值和自检状态值的调用时\n * FaultReadCtl中的off和num均以16的倍数为单位\n */\nEXTERN INT32 getHisFaultData(FaultHead *p_fault_head, FaultReadCtrl *p_read_ctrl, \n\t\t\t\t\t\t\t\tvoid *p_data);\n\n/*波形列表读取接口*/\nEXTERN UINT32 getWaveTabNum(WaveTabType tab_type, UINT32 client_no);\nINT32 getWaveTabItem(WaveTabType tab_type, UINT32 client_no, \n\t\t\t\t\t\tWaveTabItem *p_data, UINT32 off, UINT32 *p_num);\nEXTERN INT32 ackWaveTabItem(WaveTabType tab_type, UINT32 client_no, \n\t\t\t\t\t\t\t\tUINT16 nof, UINT16 fan);\n\n/*波形文件名相关接口*/\nvoid getWaveName(EveTimeTag *p_trig_t, UINT16 nof, INT8 *dir,\n\t\t\t\t\t\t\t\tINT8 *ext_name, INT8 *name);\n#ifdef __cplusplus\n}\n#endif\n\n#endif\t/*__INC_EVENT_H*/\n\n\n\n",
					"file": "sy.src/sy.hmi/rttask/inc/event.h",
					"file_size": 12468,
					"file_write_time": 131214067320633803,
					"settings":
					{
						"buffer_size": 10488,
						"encoding": "Western (Windows 1252)",
						"line_ending": "Windows",
						"scratch": true
					}
				},
				{
					"file": "sy.src/sy.hmi/Makefile",
					"settings":
					{
						"buffer_size": 1925,
						"encoding": "UTF-8",
						"line_ending": "Windows"
					}
				},
				{
					"file": "sy.src/vxworks.mk",
					"settings":
					{
						"buffer_size": 2319,
						"encoding": "UTF-8",
						"line_ending": "Unix"
					}
				},
				{
					"contents": "#include \"syslave.h\"\n#include \"ovt.h\"\n#include \"msgtype.h\"\n#include \"can.h\"\n#include \"sync.h\"\n\n\nLOCAL CanOvt *cpu_can_ovt_head=NULL;\nLOCAL CanOvt *cpu_can_ovt_tail=NULL;\nLOCAL CanOvt *dsp_can_ovt_head=NULL;\nLOCAL CanOvt *dsp_can_ovt_tail=NULL;\n\nLOCAL UINT8 canwrt_cnt=0;\nLOCAL UINT8 stationary_flg=0;\n\n//EXTERN UINT16 local_sys_ms;\n#if BOARD_TYPE!= SY6101 && CPU_TYPE!=SHARC21469\nFLOAT32 fabs(FLOAT32 a)\n{\n\tif(a >= 0)return a;\n\telse return -a;\n}\nINT32 labs(INT32 a)\n{\n\tif(a >= 0)return a;\n\telse return -a;\n}\n#endif\n\nEXT_CODE\nLOCAL INT8 newCanOvtTbl(CanOvt **head,CanOvt **tail,INT8 board,INT8 type,INT16 total_num)\n{\n\tCanOvt *new_ovt;\n\n\tif (*tail != NULL)\n\t{\n\t\tif ((*tail)->item_num != (*tail)->max_num )\n\t\t\treturn NUM_OUTOF_RANGE;\n\t}\n\tnew_ovt = (CanOvt*)calloc(sizeof(CanOvt) + (total_num-1)*sizeof(Int32Var), 1);\n\tif (!new_ovt)\n\t\treturn ALLOCATE_FAILED;\n\n\tnew_ovt->dest  = board;\n\tnew_ovt->type  = type;\n\tnew_ovt->item_num   = 0;\n\tnew_ovt->max_num    = total_num;\n\tnew_ovt->next       = NULL;\n\tnew_ovt->send_tics  = 1;\n\tnew_ovt->ind_cnt = 0;\n\tif (*head == NULL)\n\t\t*tail = *head = new_ovt;\n\telse\n\t{\n\t\t(*tail)->next = new_ovt;\n\t\t(*tail) = new_ovt;\n\t}\n\n\treturn 0;\n}\n\nEXT_CODE\nLOCAL INT8 insertCanOvtItem(CanOvt *head,CanOvt *tail,UINT32 addr,INT8 inf)\n{\n\tBitVar     *bit_var;\n\tInt8Var    *int8_var;\n\tInt16Var   *int16_var;\n\tInt32Var   *int32_var;\n\tFloat32Var *float_var;\n\tSoeVar\t   *soe_var;\n\tINT32      num=tail->item_num;\n\n\tif (num > tail->max_num)\n\t\treturn NUM_OUTOF_RANGE;\n\tswitch (tail->type)\n\t{\n\t\tcase    BITS_TYPE:\n\t\t\tbit_var = (BitVar *)&(tail->item[num]);\n\t\t\tbit_var->old_value = 0;\n\t\t\tbit_var->inf=inf;\n\t\t\tbit_var->value=(UINT8*)addr;\n\t\t\tbreak;\n\t\tcase    INT8_TYPE:\n\t\t\tint8_var = (Int8Var *)&(tail->item[num]);\n\t\t\tint8_var->old_value = 0;\n\t\t\tint8_var->inf=inf;\n\t\t\tint8_var->value=(UINT8*)addr;\n\t\t\tbreak;\n\t\tcase    SOE_TYPE:\n\t\t\tsoe_var = (SoeVar *)&(tail->item[num]);\n\t\t\tsoe_var->old_value = 0;\n\t\t\tsoe_var->inf=inf;\n\t\t\tsoe_var->value=(SOE*)addr;\n\t\t\tbreak;\n\t\tcase    INT16_TYPE:\n\t\t\tint16_var = (Int16Var *)&(tail->item[num]);\n\t\t\tint16_var->old_value = 0;\n\t\t\tint16_var->dead_band = 1;\n\t\t\tint16_var->inf=inf;\n\t\t\tint16_var->value=(UINT16*)addr;\n\t\t\tbreak;\n\t\tcase    INT32_TYPE:\n\t\t\tint32_var = (Int32Var *)&(tail->item[num]);\n\t\t\tint32_var->old_value = 0;\n\t\t\tint32_var->dead_band = 50;\n\t\t\tint32_var->inf=inf;\n\t\t\tint32_var->value=(UINT32*)addr;\n\t\t\tbreak;\n\t\tcase    FLOAT_TYPE:\n\t\t\tfloat_var = (Float32Var *)&(tail->item[num]);\n\t\t\tfloat_var->old_value = 0;\n\t\t\tfloat_var->dead_band = 0.001;\n\t\t\tfloat_var->inf=inf;\n\t\t\tfloat_var->value=(FLOAT32*)addr;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn TYPE_NOT_MATCHED;\n\t}\n\ttail->item_num++;\n\treturn 0;\n}\n\nEXT_CODE\nINT8 canOvtProc(INT8 comm_way,INT32 len,INT8 *data)\n{\n\tINT8 inf,error_no,in_board;\n\tINT8 type,flag;\n\tINT16 total_num;\n\tINT32  offset=0;\n\tUINT32 addr;\n\n\tstationary_flg = 0;\n\tif (len < 5)\n\t\treturn INVALID_PACKET;\n\tflag = getChar(data,&offset);\n\tif ( (flag & 0x10)==0x10)     //start of packet\n\t{\n\t\tin_board=getChar(data,&offset);\n\t\ttype=getChar(data,&offset);\n\t\ttotal_num = getInt16(data,&offset);\n\t\tif (total_num == 0)\n\t\t\treturn NUM_OUTOF_RANGE;\n\t\tif(comm_way==CPUCAN_WAY)\n\t\t\terror_no = newCanOvtTbl(&cpu_can_ovt_head,&cpu_can_ovt_tail,in_board,type,total_num);\n\t\telse\n\t\t\terror_no = newCanOvtTbl(&dsp_can_ovt_head,&dsp_can_ovt_tail,in_board,type,total_num);\n\t\tif (error_no > 0)\n\t\t\treturn error_no;\n\t}\n\twhile (offset < len)\n\t{\n\t\tinf  = getChar(data,&offset);\n\t\taddr = getInt32(data, &offset);\n\t\tif(comm_way==CPUCAN_WAY)\n\t\t\terror_no = insertCanOvtItem(cpu_can_ovt_head,cpu_can_ovt_tail,addr,inf);\n\t\telse\n\t\t\terror_no = insertCanOvtItem(dsp_can_ovt_head,dsp_can_ovt_tail,addr,inf);\n\t\tif (error_no!=0)\n\t\t\treturn error_no;\n\t}\n\tif( offset !=len )\n\t\t\treturn INVALID_PACKET;\n\treturn 0;\n}\n\nLOCAL void canAllBitVarWrite(CanOvt *current)\n{\n\tINT32  i, j;\n\tCanMiniMsg smsg;\n\tBitVar *dp;\n\tUINT32  value=0,tmp_v;\n\tUINT8 offset, k, wr_num[2];\n\n\tputCanMsgHdr((CanMsg*)&smsg,current->dest,VAR_EXCHG_TYPE,ALLBIT_TYPE);\n\n\tif(current->item_num > 32)\n\t{\n\t\tk = 2;\n\t\twr_num[0] = 32;\n\t\twr_num[1] = current->item_num - 32;\n\t}\n\telse\n\t{\n\t\tk = 1;\n\t\twr_num[0] = current->item_num;\n\t\twr_num[1] = 0;\n\t}\n\n\tfor(i=0; i<k; i++)\n\t{\n\t\toffset = i<<5;\n\t\tvalue = 0;\n\t\tfor (j=0;j<wr_num[i];j++)\n\t\t{\n\t\t\tdp=(BitVar *)&(current->item[offset+j]);\n\t\t\ttmp_v = *dp->value;\n\t\t\tvalue |= (tmp_v & 0x00000001) << j;  //注意PPC big endian问题。与pic33不同。\n\t\t}\n\t\tputInt32(smsg.data,&smsg.len,value);\n\t}\n\tcanTx(DSPCAN_WAY,(CanMsg*)&smsg);\n}\n\nLOCAL void canBitVarWrite(CanOvt *current,INT8 comm_way)\n{\n\tINT8  sent=0;\n\tINT32 i;\n\tCanMiniMsg smsg;\n\tBitVar *dp;\n\tINT8 value=0;\n\n\tputCanMsgHdr((CanMsg*)&smsg,current->dest,VAR_EXCHG_TYPE,BIT_TYPE);\n\n\tfor (i=0;i<current->item_num;i++)\n\t{\n\t\tdp=(BitVar *)&(current->item[i]);\n\t\tvalue = *dp->value & 0x1;\n\t\tif ( value!=dp->old_value)\n\t\t{\n\t\t\tdp->old_value=value;\n\t\t\tputChar(smsg.data,&smsg.len,(dp->inf<<1)+value);\n\t\t}\n\t\tif (smsg.len==8)\n\t\t{\n\t\t\tcanTx(comm_way,(CanMsg*)&smsg);\n\t\t\tsmsg.len=0;\n\t\t\tsent=1;\n\t\t}\n\t}\n\tif( (DSPCAN_WAY==comm_way) && (smsg.len>0) )\n\t{\n\t\tcanTx(comm_way,(CanMsg*)&smsg);\n\t\tsent=1;\n\t}\n\tif( DSPCAN_WAY==comm_way)\n\t{\n\t\tcurrent->send_tics--;\n\t\tif(0==current->send_tics)\n\t\t{\n\t\t\tcanAllBitVarWrite(current);\n\t\t\tcurrent->status=0;\n\t\t}\n\n\t\tif( (1==sent) && (1!=current->status) )\n\t\t{\n\t\t\tcurrent->status=1;\n\t\t\tcurrent->send_tics=10;\n\t\t}\n\n\t\telse if( (1==current->status) && (0==sent) )\n\t\t{\n\n\t\t}\n\t\telse if( (0==sent) && (0==current->status) )\n\t\t{\n\t\t\tcurrent->send_tics=100;\n\t\t\tcurrent->status=2;\n\t\t}\n\t}\n}\n\nLOCAL void cpuCanBitVarWrite(CanOvt *current,INT8 comm_way)\n{\n\tINT32 i,j,k;\n\tCanMiniMsg smsg;\n\tBitVar *dp;\n\tBSOE *soe;\n\tINT8 value=0;\n\tUINT16 ms=0xfffff;\n\n#if BOARD_TYPE==SY6101\n\tif( (task_run_cnt[2]%24)!=0 )\n\t\treturn ;\n#endif\n\n\tputCanMsgHdr((CanMsg*)&smsg,current->dest,VAR_EXCHG_TYPE,BIT_TYPE);\n\n\tk=0;\n\tfor (i=0;i<current->item_num;i++)\n\t{\n\t\tdp=(BitVar *)&(current->item[i]);\n\t\tsoe=(BSOE*)dp->value;\n\t\tvalue = *dp->value & 0x1;\n\t\tif ( value!=dp->old_value)\n\t\t{\n\t\t\tdp->old_value=value;\n\t\t\tif(k==0)\n\t\t\t{\n\t\t\t\tputInt16(smsg.data,&smsg.len,soe->ms);\n\t\t\t\tms=soe->ms;\n\t\t\t}\n\t\t\tputChar(smsg.data,&smsg.len,(dp->inf<<1)+value);\n\t\t\tk++;\n\t\t\tfor(j=(i+1);j<current->item_num;j++)\n\t\t\t{\n\t\t\t\tdp=(BitVar *)&(current->item[j]);\n\t\t\t\tsoe=(BSOE*)dp->value;\n\t\t\t\tvalue = *dp->value & 0x1;\n\t\t\t\tif ( value!=dp->old_value && soe->ms==ms)\n\t\t\t\t{\n\t\t\t\t\tdp->old_value=value;\n\t\t\t\t\tk++;\n\t\t\t\t\tputChar(smsg.data,&smsg.len,(dp->inf<<1)+value);\n\t\t\t\t\tif(k>=6)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (smsg.len==8)\n\t\t{\n\t\t\tcanTx(comm_way,(CanMsg*)&smsg);\n\t\t\tsmsg.len=0;\n\t\t\tk=0;\n\t\t\tms=0xffff;\n\t\t}\n\t}\n\tif(   (CPUCAN_WAY==comm_way) && (smsg.len>2)  )\n\t{\n\t\tcanTx(comm_way,(CanMsg*)&smsg);\n\t}\n}\n\n\nLOCAL void canInt8VarWrite(CanOvt *current,INT8 comm_way)\n{\n\tINT32 i;\n\tCanMiniMsg smsg;\n\tInt8Var * dp;\n\n\tputCanMsgHdr((CanMsg*)&smsg,current->dest,VAR_EXCHG_TYPE,ONEBYTE_TYPE);\n\tif(CPUCAN_WAY==comm_way)\n\t\tputInt16(smsg.data,&smsg.len,local_sys_ms);\n\n\tfor (i=0;i<current->item_num;i++)\n\t{\n\t\tdp=(Int8Var *)&(current->item[i]);\n\t\tif ( *dp->value!=dp->old_value)\n\t\t{\n\t\t\tdp->old_value=*dp->value;\n\t\t\tputChar(smsg.data,&smsg.len,dp->inf);\n\t\t\tputChar(smsg.data,&smsg.len,*dp->value);\n\t\t}\n\t\tif (smsg.len==8)\n\t\t{\n\t\t\tcanTx(comm_way,(CanMsg*)&smsg);\n\t\t\tif(CPUCAN_WAY==comm_way)\n\t\t\t\tsmsg.len=2;\n\t\t\telse\n\t\t\t\tsmsg.len=0;\n\t\t}\n\t}\n\tif(  ( (CPUCAN_WAY==comm_way) && (smsg.len>2) ) ||\n\t\t ( (DSPCAN_WAY==comm_way) && (smsg.len>0) )    )\n\t{\n\t\tcanTx(comm_way,(CanMsg*)&smsg);\n\t}\n}\n\nLOCAL void canSoeVarWrite(CanOvt *current,INT8 comm_way)\n{\n\tINT32 i;\n\tCanMiniMsg smsg;\n\tSoeVar * dp;\n\n\tputCanMsgHdr((CanMsg*)&smsg,current->dest,VAR_EXCHG_TYPE,SOE8_TYPE);\n\n\tfor (i=0;i<current->item_num;i++)\n\t{\n\t\tdp=(SoeVar *)&(current->item[i]);\n\t\tif ( dp->value->val!=dp->old_value)\n\t\t{\n\t\t\tdp->old_value=dp->value->val;\n\t\t\tif(dp->value->s==0)\n\t\t\t{\n\t\t\t\tputInt32(smsg.data,&smsg.len,local_sys_s);\n\t\t\t\tputInt16(smsg.data,&smsg.len,local_sys_ms);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputInt32(smsg.data,&smsg.len,dp->value->s);\n\t\t\t\tputInt16(smsg.data,&smsg.len,dp->value->ms);\n\t\t\t}\n\t\t\tputChar(smsg.data,&smsg.len,dp->inf);\n\t\t\tputChar(smsg.data,&smsg.len,(dp->value->val|(dp->value->chgd<<7)));\n\t\t}\n\t\tif (smsg.len==8)\n\t\t{\n\t\t\tcanTx(comm_way,(CanMsg*)&smsg);\n\t\t\tsmsg.len=0;\n\t\t}\n\t}\n}\n\n#if CPU_TYPE==PIC33\n#define INT_SEND_PERIOD  1000\n#else\n#define INT_SEND_PERIOD  500\n#endif\n\nLOCAL void canInt32VarWrite(CanOvt *current,INT8 comm_way)\n{\n\tINT32 i;\n\tUINT32 delta_value;\n\tCanMiniMsg smsg;\n\tInt32Var * dp;\n\n\tif( stationary_flg && canwrt_cnt )\n\t\treturn;\n\n\tputCanMsgHdr((CanMsg*)&smsg,current->dest,VAR_EXCHG_TYPE,INTBYTE_TYPE);\n\tif(CPUCAN_WAY==comm_way)\n\t\tputInt16(smsg.data,&smsg.len,local_sys_ms);\n\n\tfor (i=0;i<current->item_num;i++)\n\t{\n\t\tdp=(Int32Var *)&(current->item[i]);\n\t\tdelta_value=*dp->value-dp->old_value;\n\t\tif ( (delta_value > dp->dead_band) || (i==current->ind_cnt ) )\n\t\t{\n\t\t\tdp->old_value=*dp->value;\n\t\t\tputInt16(smsg.data,&smsg.len,dp->inf);\n\t\t\tputInt32(smsg.data,&smsg.len,*dp->value);\n\t\t\tcanTx(comm_way,(CanMsg*)&smsg);\n\t\t\tif(CPUCAN_WAY==comm_way)\n\t\t\t\tsmsg.len=2;\n\t\t\telse\n\t\t\t\tsmsg.len=0;\n\t\t}\n\t}\n\tcurrent->ind_cnt++;\n\tif(current->ind_cnt >= current->item_num)\n\t{\n\t\tcurrent->ind_cnt = 0;\n\t}\n}\n\nLOCAL void canFloatVarWrite(CanOvt *current,INT8 comm_way)\n{\n\tINT32 i;\n\tFLOAT32 delta_value;\n\tCanMiniMsg smsg;\n\tFloat32Var * dp;\n\tif( stationary_flg && canwrt_cnt )\n\t\treturn ;\n\n\tputCanMsgHdr((CanMsg*)&smsg,current->dest,VAR_EXCHG_TYPE,FLOATBYTE_TYPE);\n\tif(CPUCAN_WAY==comm_way)\n\t\tputInt16(smsg.data,&smsg.len,local_sys_ms);\n\n\tfor (i=0;i<current->item_num;i++)\n\t{\n\t\tdp=(Float32Var *)&(current->item[i]);\n\t\tdelta_value=*dp->value-dp->old_value;\n\t\tif ( (fabs(delta_value) > dp->dead_band)|| (i==current->ind_cnt ) )\n\t\t{\n\t\t\tdp->old_value=*dp->value;\n\t\t\tputInt16 (smsg.data,&smsg.len,dp->inf);\n\t\t\tputInt32(smsg.data,&smsg.len,*(INT32 *)dp->value);\n\n\n\t\t\tcanTx(comm_way,(CanMsg*)&smsg);\n\t\t\tif(CPUCAN_WAY==comm_way)\n\t\t\t\tsmsg.len=2;\n\t\t\telse\n\t\t\t\tsmsg.len=0;\n\t\t}\n\t}\n\n\tcurrent->ind_cnt++;\n\tif(current->ind_cnt >= current->item_num)\n\t{\n\t\tcurrent->ind_cnt = 0;\n\t}\n}\n\nLOCAL void canOvtWrite(CanOvt *head,INT8 comm_way)\n{\n\tCanOvt *current=head;\n\n\twhile ( NULL!=current )\n\t{\n\n// printf(\"[%s]: type is %d\\n\", __FUNCTION__, current->type);\n\n\t\tswitch ( current->type )\n\t\t{\n\t\t\tcase    BITS_TYPE:\n\t\t\t\tif(comm_way==DSPCAN_WAY)\n\t\t\t\t\tcanBitVarWrite(current,comm_way);\n\t\t\t\telse\n\t\t\t\t\tcpuCanBitVarWrite(current,comm_way);\n\t\t\t\tbreak;\n\t\t\tcase    INT8_TYPE:\n\t\t\t\tcanInt8VarWrite(current,comm_way);\n\t\t\t\tbreak;\n\t\t\tcase \tSOE_TYPE:\n\t\t\t\tcanSoeVarWrite(current,comm_way);\n\t\t\t\tbreak;\n\t\t\tcase    INT16_TYPE:\n\t\t\t\tbreak;\n\t\t\tcase    INT32_TYPE:\n\t\t\t\tcanInt32VarWrite(current,comm_way);\n\t\t\t\tbreak;\n\t\t\tcase\tFLOAT_TYPE:\n\t\t\t\tcanFloatVarWrite(current,comm_way);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t\tcurrent=current->next;\n\t}\n}\n\nEXTERN void canVarWrite()\n{\n\tcanwrt_cnt++;\n\tif(canwrt_cnt >= 48)\n\t{\n\t\tcanwrt_cnt = 0;\n\t}\n\tif( task_run_cnt[2] > INT_SEND_PERIOD)\n\t{\n\t\tstationary_flg=1;\n\t}\n\n#if BOARD_TYPE!= SY6101\n\tcanOvtWrite(dsp_can_ovt_head,DSPCAN_WAY);\n#endif\n\tcanOvtWrite(cpu_can_ovt_head,CPUCAN_WAY);\n}\n",
					"file": "sy.src/sy.sys/system/src/canovt.c",
					"file_size": 11419,
					"file_write_time": 131315967155306186,
					"settings":
					{
						"buffer_size": 10879,
						"encoding": "Western (Windows 1252)",
						"line_ending": "Windows",
						"scratch": true
					}
				},
				{
					"contents": "/*==========================================================================*\n * 文件模块说明:                                                            *\n *   LCD历史报告相关业务实现                                                *\n * 文件版本: v1.00                                                          *\n * 开发人员: 黄小川                                                         *\n * 创建时间: 2012-12-20                                                     *\n * Copyright(c) 1993-2013 Shanghai SHR Electrical Power Technology Co. Ltd. *\n *==========================================================================*\n * 程序修改记录:\t\t\t\t\t\t\t\t                            *\n *   V1.00 2012-12-20, 黄小川: 详细设计实现                                 *\n *==========================================================================*/\n\n#include \"lcdreport.h\"\n#include \"lcdpage.h\"\n#include \"lcd.h\"\n#include \"lcdgrid.h\"\n#include \"lcdctrl.h\"\n#include \"lcddraw.h\"\n#include \"lcduigen.h\"\n#include \"lcdservice.h\"\n\n// 故障报告页面\ntypedef struct lcd_page_faultreport\n{\n\tLCD_PAGE_BASE;\n\tINT16 showItem;\n\tINT32 faultIndex;\n\tLcdFaultReport* fault;\n} LcdPageFaultReport;\n\n// 故障报告引用表加载\nstatic INT32 lcdFaultParaRefFunc(INT32 i, LcdSplitStringList* lst, LcdRefTable* ref, void* param)\n{\n\tLcdFaultPara* para = LCD_CLASS_CAST(LcdFaultPara, param);\n\tif(lst->num > 1)\n\t{\n\t\tpara->attrs[i] = *(lst->item[1]) - 48;\n\t}\t\n\tif(NULL != ref) {}\n\treturn 0;\n}\n\nLcdFaultReport* lcdFaultRefInit(Lcd* lcd, LcdService* svr)\n{\n\tLcdFaultReport* report = lcd->faultReport;\n\tif(NULL != report)\n\t{\n\t\treturn report;\n\t}\n\n\treport = LCD_NEWCLASS(LcdFaultReport);\n\tif(NULL == report)\n\t{\n\t\tLCD_EXCEPTION(\"lcdOpFaultReportInit: malloc failed\");\n\t\treturn NULL;\n\t}\n\tLCD_CLASS_INIT(LcdFaultData, &report->data);\n\tif(svr->refNum > 0)\n\t{\n\t\tlcdRefTableInit(lcd, svr->refs[0]);\n\t\treport->tripRef = svr->refs[0];\n\t}\n\tif(svr->refNum > 1)\n\t{\n\t\tif(lcdRefTableIsInited(svr->refs[1]))\n\t\t{\n\t\t\treport->paraInf = LCD_CLASS_CAST(LcdFaultPara, svr->refs[1]->data);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treport->paraInf = LCD_NEWCLASS(LcdFaultPara);\n\t\t\tif(NULL == report->paraInf)\n\t\t\t{\n\t\t\t\tLCD_EXCEPTION(\"lcdOpFaultReportInit: malloc failed\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treport->paraInf->ref = svr->refs[1];\n\t\t\treport->paraInf->ref->data = report->paraInf;\n\t\t\tlcdRefTableInitWithFunc(lcd, svr->refs[1], lcdFaultParaRefFunc, report->paraInf);\n\t\t}\n\t}\n\tlcd->faultReport = report;\n\treturn report;\n}\n/************************************************************\n * 函数名称: lcdOpFaultReportInit\n * 函数功能: 故障报告业务初始化\n * 输入参数: param, 标准初始化入口参数\n * 输出参数: 无\n * 返回值  : 无\n * 修改记录: \n *   V1.00 2012-12-20, hxc: 初次实现\n ************************************************************/\nvoid lcdOpFaultReportInit(void* param)\n{\n\tLcdParamInit* par = LCD_PARAM_INIT(param);\n\tLcdFaultReport* report = lcdFaultRefInit(par->lcd, par->svr);\n\tpar->svr->menuParam = report;\n}\n/************************************************************\n * 函数名称: lcdFaultRead\n * 函数功能: 读取当前故障报告历史数据\n * 输入参数: ctrl, 读取控制块\n * 输出参数: fault, 故障报告内容\n * 返回值  : 0成功，非0失败\n * 修改记录: \n *   V1.00 2012-12-21, hxc: 初次实现\n ************************************************************/\nINT32 lcdFaultRead(HisEventReadCtrl* ctrl, LcdFaultReport* p_fault_rpt)\n{\n\tINT32 i;\n\tINT32 ret;\n\tFaultReadCtrl fctrl;\n\tLcdFaultData* p_fault_data;\n\t\n\tp_fault_data = &p_fault_rpt->data;\n\t\n\tp_fault_data->valid = 0;\n\tp_fault_data->paraNum = 0;\n\tp_fault_data->tripNum = 0;\n\t//取整组的信息\n\tret = getHisFaultHead(ctrl, &p_fault_data->head);\n\tif(0 != ret)\n\t{\n\t\treturn 1;\n\t}\n\t//读para\n\tfctrl.field = FAULT_DF_PARA_VAL;\n\tfctrl.num = p_fault_data->head.para_num;\n\tfctrl.off = 0;\n\tif(p_fault_data->head.para_num > 0)\n\t{\n\t\tret = getHisFaultData(&p_fault_data->head, &fctrl, (void*)p_fault_data->para);\n\t\tif(0 != ret)\n\t\t{\n\t\t\treturn 2;\n\t\t}\n\t}\n\tp_fault_data->paraNum = p_fault_data->head.para_num;\n\tif(p_fault_data->head.para_num==0)\n\t\tp_fault_data->para_show_num = 0;\n\telse\n\t\tp_fault_data->para_show_num = p_fault_rpt->paraInf->ref->showNum;\n\t//读trip\n//\tif( fault->head.trip_event_num <= 0 ||\n//\t\tfault->head.trip_event_num > LCD_NUMOF(fault->trip) )\n//\t{\n//\t\t//printf(\"lcdFaultRead :fault trip event num = %d is overflow\\n\\r\",fault->head.trip_event_num);\n//\t\t//return 3;\n//\t\tfault->head.trip_event_num = LCD_NUMOF(fault->trip);\n//\t}\n\t\n    if(p_fault_data->head.trip_event_num > LCD_NUMOF(p_fault_data->trip) )\n\t{\n\t\tp_fault_data->head.trip_event_num = LCD_NUMOF(p_fault_data->trip);\n\t}\n\tfctrl.field = FAULT_DF_TRIP_EVENT;\n\tfctrl.num = p_fault_data->head.trip_event_num;\n\tfctrl.off = 0;\n\tret = getHisFaultData(&p_fault_data->head, &fctrl, (void*)p_fault_data->trip);\n\tif(0 != ret)\n\t{\n//\t\treturn 3;\n\t}\n\tfor(i=0, ret=0; i<p_fault_data->head.trip_event_num; ++i)\n\t{\t\n\t\tif((p_fault_data->trip[i].data.trip.st_val & 0x01))\n\t\t{\n\t\t\tif(ret != i)\n\t\t\t{\n\t\t\t\tp_fault_data->trip[ret] = p_fault_data->trip[i];\n\t\t\t}\n\t\t\tret++;\n\t\t}\n\t}\n\tp_fault_data->tripNum = ret;\n\tp_fault_data->valid = 1;\n\treturn 0;\n}\n\n// 故障报告附加数据列表绘制\nstatic void lcdUiFaultReportDraw(INT16 x, INT16 y, INT16 row, INT16 col, void* param)\n{\n\tCHAR* ptr;\n\tconst CHAR* str;\n\tLcdFaultReport* fault = (LcdFaultReport*)param;\n\n\tEventData* evt;\n\tDataFields* p_datafield=NULL;\n\tINT32 index;\n\tFLOAT32 fval;\n\tINT32 i,num_index=0,valid_index=0;\n\t\n\tif(col>0){}\n\tif(row < fault->data.tripNum)\n\t{\n\t\tevt = fault->data.trip + row;\n\n\t\tif (evt->data.trip.ret_ms > 3600 * 1000)\n\t\t{\n\t\t\tstr = LCD_FMTSTR(\"%s\", \">3600 s\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstr = LCD_FMTSTR(\"%dms\", evt->data.trip.ret_ms);\n\t\t}\n\t\t\n\t\t//str = LCD_FMTSTR(\"%dms\", evt->data.trip.ret_ms);\n\t\tlcdTextShow(x+LCD_TEXT_W*8, y, 0, 0, str, TEXT_FLAG_RIGHTALIGN);\n\n\t\tptr = lcdPullTextPixel(x+LCD_TEXT_W*10, y);\n\t\tif(NULL == fault->tripRef)\n\t\t{\n\t\t\tLCD_STRCPY(ptr, LCD_STRING(\"INVALID_CONFIG\"));\n\t\t}\n\t\telse if(evt->data.trip.st_no < fault->tripRef->num)\n\t\t{\n\t\t\tLCD_STRCPY(ptr, fault->tripRef->fields[evt->data.trip.st_no]->desc);\n\t\t}\n\n\n\t\tstr = lcdSearchPhase(1, evt->data.trip.st_val & 0x0e);\n\t\tlcdTextShowRight(LCD_WIDTH-LCD_TEXT_W, y, str);\n\t}\n\telse if(row < fault->data.tripNum + fault->data.para_show_num)\n\t{\n\t\tindex = row - fault->data.tripNum;\n\t\tif(NULL == fault->paraInf || NULL == fault->paraInf->ref)\n\t\t{\n\t\t\tptr = lcdPullTextPixel(x+LCD_TEXT_W*5, y);\n\t\t\tLCD_STRCPY(ptr, LCD_STRING(\"INVALID_CONFIG\"));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(i=0; i<fault->paraInf->ref->num; i++)\n\t\t\t{\n\t\t\t\tp_datafield = fault->paraInf->ref->fields[i];\n\t\t\t\tif( DESC_WAVE_VISIBLE(p_datafield) )\n\t\t\t\t\tnum_index++;\n\t\t\t\tif(num_index==index+1)\n\t\t\t\t{\n\t\t\t\t\tvalid_index = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(valid_index<fault->paraInf->ref->num)\n\t\t\t{\n\t\t\t\tlcdDrawText(x+LCD_TEXT_W*5, y, p_datafield->desc, 0);//故障参数名称\n            \t\n\t\t\t\tif(FAULTINFO_TBL_FAULT_TYPE_PHASE == fault->paraInf->attrs[valid_index])//故障参数值\n\t\t\t\t{\n\t\t\t\t\tstr = lcdSearchPhase(0, ((*((UINT8*)(&fault->data.para[valid_index]))) & 0x07));\n\t\t\t\t\tlcdTextShowRight(LCD_WIDTH-LCD_TEXT_W, y, str);\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfval = LCD_NATIVE(fault->data.para[valid_index], p_datafield);\n\t\t\t\t\tstr = lcdFormatValueStatic(&fval, p_datafield, 0);\n\t\t\t\t\tlcdTextShowRight(LCD_WIDTH-LCD_TEXT_W, y, str);\n\t\t\t\t} \n\t\t\t}\n\t\t}\n\n\t}\n}\n\nvoid lcdFaultDraw(LcdRect* rect, LcdFaultReport* fault, INT16 showItem)//故障信息描绘（序号+时间+ 参数）\n{\n\tLcdGrid ctrl;\n\tCHAR* ptr;\n\tSystemTime st;\n\tLcdRect client;\n\n\tptr = lcdPullTextPixel(rect->x, rect->y);\n\tsprintf(ptr, \"%04d\", fault->data.head.no);\n\tsysTimeToLocal(fault->data.head.t.sec, fault->data.head.t.us/1000, &st);\n\tsprintf(ptr+5, \"%4d-%02d-%02d %02d:%02d:%02d:%03d\", st.year, st.month, st.day,\n\t\tst.hour, st.minute, st.second, st.milliseconds);\n\n\tclient = *rect;\n\tclient.y += LCD_TEXT_H;\n\tclient.height -= LCD_TEXT_H;\n\tlcdGridInit(&ctrl, &client, fault->data.para_show_num + fault->data.tripNum, 0);\n\tctrl.showRow = showItem;\n\tlcdGridShow(&ctrl, lcdUiFaultReportDraw, fault);\n}\nvoid lcdFaultKey(LcdRect* rect, LcdFaultReport* fault, INT32 key, INT16* showItem)\n{\n\tLcdGrid ctrl;\n\tLcdRect client;\n\n\tclient = *rect;\n\tclient.y += LCD_TEXT_H;\n\tclient.height -= LCD_TEXT_H;\n\t\n\tlcdGridInit(&ctrl, &client, fault->data.para_show_num + fault->data.tripNum, 0);\n\t\n\tctrl.showRow = *showItem;\n\tlcdGridKey(&ctrl, key);\n\t*showItem = ctrl.showRow;\n}\n\n// 故障报告页面显示\nstatic void lcdUiFaultReportShow(void* param)\n{\n\tLcdParamShow* par = LCD_PARAM_SHOW(param);\n\tLcd* lcd = par->lcd;\n\tLcdPageFaultReport* page = (LcdPageFaultReport*)par->page;\n\tUINT16 num;\n\tHisEventReadCtrl rctrl = {0};\n\tINT32 ret=0;\n\t\n\tnum = getHisFaultNum(&rctrl.start_no, &rctrl.last_no);\n\tif(0 == num)\n\t{\n\t\tlcdMsgboxShow(LCD_STRING(\"NONE\"));\n\t}\n\telse\n\t{\n\t\trctrl.order = 1;\n\t\trctrl.off = (UINT16)page->faultIndex;\n\t\tret =  lcdFaultRead(&rctrl, page->fault) ;\n\t\n\t\tif(0 != ret)\n\t\t{\n\t\t\tlcdMsgboxShow(LCD_STRING(\"NONE\"));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tLcdRect rect;\n\t\t\tlcdClientRect(lcd, &rect, 0);\n\n\t\t\tlcdFaultDraw(&rect, page->fault, page->showItem);\n\t\t}\n\t}\t\n\n\tlcdFrameShow(lcd, 0, 0);\n}\n// 故障报告页面按键\nstatic void lcdUiFaultReportKey(void* param)\n{\n\tLcdParamKey* par = LCD_PARAM_KEY(param);\n\tLcd* lcd = par->lcd;\n\tINT32 key = par->key;\n\tLcdPageFaultReport* page = (LcdPageFaultReport*)par->page;\n\n\tUINT32 num = 0;\n\tUINT32 start = 0;\n\tUINT32 last = 0;\n\n\tLcdRect rect;\n\n\tswitch(key)\n\t{\n\tcase LCD_KEY_ADD:\n\tcase LCD_KEY_SUB:\n\t\tnum = getHisFaultNum(&start, &last);\n\t\tif(num > 0)\n\t\t{\n\t\t\tlcdClientRect(lcd, &rect, 0);\n\t\t\tlcdFaultKey(&rect, page->fault, key, &page->showItem);\n\t\t}\n\t\tbreak;\n\tcase LCD_KEY_UP:\n\t\tnum = getHisFaultNum(&start, &last);\n\t\tif(num > 0 && page->faultIndex < (INT32)num - 1)\n\t\t{\n\t\t\tpage->faultIndex++;\n\t\t\tpage->showItem = 0;\n\t\t\tlcdRedraw();\n\t\t}\n\t\tbreak;\n\tcase LCD_KEY_DOWN:\n\t\tnum = getHisFaultNum(&start, &last);\n\t\tif(page->faultIndex > 0)\n\t\t{\n\t\t\tpage->faultIndex--;\n\t\t\tpage->showItem = 0;\n\t\t\tlcdRedraw();\n\t\t}\n\t\tbreak;\n\tcase LCD_KEY_LEFT:\n\tcase LCD_KEY_RIGHT:\n\t\tlcdUiAlttabKey(param);\n\t\tbreak;\n\tcase LCD_KEY_ESC:\n\tcase LCD_KEY_ENTER:\n\t\tlcdClosePage((LcdPage*)page);\n\t\tbreak;\n\t}\n}\n/************************************************************\n * 函数名称: lcdOpFaultReport\n * 函数功能: 故障报告显示业务入口\n * 输入参数: param, 标准入口参数\n * 输出参数: 无\n * 返回值  : 无 \n * 修改记录: \n *   V1.00 2012-12-20, hxc: 初次实现\n ************************************************************/\nvoid lcdOpFaultReport(void* param)\n{\n\tLcdParamMenu* par = LCD_PARAM_MENU(param);\n\tLcd* lcd = par->lcd;\n\tLcdPageFaultReport* page = LCD_NEW_DPAGE(LcdPageFaultReport, lcd);\n\tpage->showFunc = lcdUiFaultReportShow;\n\tpage->keyFunc = lcdUiFaultReportKey;\n\tpage->fault = LCD_CLASS_CAST(LcdFaultReport, par->data);\n\n\tlcdOpenPage((LcdPage*)page);\n}\n\n////////////////////////////////////////////////////////////////////////////////////////\n/************************************************************\n * 函数名称: lcdOpNormalReportInit\n * 函数功能: 普通的历史报告业务初始化\n * 输入参数: param, 标准入口参数\n * 输出参数: 无\n * 返回值  : 无 \n * 修改记录: \n *   V1.00 2012-12-20, hxc: 初次实现\n ************************************************************/\nvoid lcdOpNormalReportInit(void* param)\n{\n\tLcdParamInit* par = LCD_PARAM_INIT(param);\n\tLcd* lcd = par->lcd;\n\tLcdService* svr = par->svr;\n\tLcdNormalReport* report = LCD_NEWCLASS(LcdNormalReport);\n\tif(NULL == report)\n\t{\n\t\tLCD_EXCEPTION(\"lcdOpNormalReortInit: malloc failed\");\n\t\treturn;\n\t}\n\tsvr->menuParam = report;\n\n\treport->type = svr->id;\n\n\tif(svr->refNum > 0)\n\t{\n\t\tlcdRefTableInit(lcd, svr->refs[0]);\n\t\treport->ref = svr->refs[0];\n\t}\n\tif(svr->refNum > 1)\n\t{\n\t\tlcdRefTableInit(lcd, svr->refs[1]);\n\t\treport->paraRef = svr->refs[1];\n\t}\n\tswitch(svr->id)\n\t{\n\tcase BI_CHG_REPORT:\n\t\treport->innerType = EN_BI_EVENT;\n\t\tpar->lcd->biReport = report;\n\t\tbreak;\n\tcase SOE_REPORT:\n\t\treport->innerType = EN_YX_EVENT;\n\t\tpar->lcd->soeReport = report;\n\t\tbreak;\n\tcase RUN_REPORT:\n\t\treport->innerType = EN_RUN_EVENT;\n\t\tpar->lcd->runReport = report;\n\t\tbreak;\n\tcase CHECK_REPORT:\n\t\treport->innerType = EN_CHECK_EVENT;\n\t\tpar->lcd->checkReport = report;\n\t\tbreak;\n\tcase TRP_REPORT:\n\t\treport->innerType = EN_TRIP_EVENT;\n\t\tpar->lcd->tripReport = report;\n\tdefault:\n\t\tbreak;\n\t}\n}\n// 普通报告页面\ntypedef struct lcd_page_normalreport\n{\n\tLCD_PAGE_BASE;\n\tINT16 showItem;\n\tINT16 selectItem;\n\tINT16 showPara;\n\tINT16 paraNum;\n\tINT32 reportIndex;\n\tLcdNormalReport* report;\n\tEventData data;\n} LcdPageNormalReport;\n// 普通报告列表绘制\nstatic void lcdUiNormalReportDrawList(INT16 x, INT16 y, INT16 row, INT16 col, void* param)\n{\n\tCHAR* ptr;\n\tEventData evt;\n\tSystemTime st;\n\tUINT16 no=0;\n\tUINT16 index=0;\n\tUINT8 value=0;\n\t//DataFields* field;\n\tINT32 ret = 0;\n\tLcdNormalReport* report = LCD_CLASS_CAST(LcdNormalReport, param);\n\tCHAR str[64];\n\t\n\tif(col>0){}\n\t\n\treport->ctrl.order = 1;\n\treport->ctrl.off = row;\n\tswitch(report->type)\n\t{\n\tcase CHECK_REPORT:\n\t\tret = getHisEvent(EN_CHECK_EVENT, &report->ctrl, &evt);\n\t\tif(0 == ret)\n\t\t{\n\t\t\tno = evt.data.sys_chk.no;\n\t\t\tsysTimeToLocal(evt.data.sys_chk.t.sec, evt.data.sys_chk.t.us/1000, &st);\n\t\t\tindex = evt.data.sys_chk.st_no;\n\t\t\tvalue = evt.data.sys_chk.st_val;\n\t\t}\n\t\tbreak;\n\tcase BI_CHG_REPORT:\n\t\tgetHisEvent(EN_BI_EVENT, &report->ctrl, &evt);\n\t\tno = evt.data.bi.no;\n\t\tsysTimeToLocal(evt.data.bi.t.sec, evt.data.bi.t.us/1000, &st);\n\t\tindex = evt.data.bi.st_no;\n\t\tvalue = evt.data.bi.st_val;\n\t\tbreak;\n\tcase SOE_REPORT:\n\t\tgetHisEvent(EN_YX_EVENT, &report->ctrl, &evt);\n\t\tno = evt.data.yx.no;\n\t\tsysTimeToLocal(evt.data.yx.t.sec, evt.data.yx.t.us/1000, &st);\n\t\tindex = evt.data.yx.st_no;\n\t\tvalue = evt.data.yx.st_val;\n\t\tbreak;\n\tcase RUN_REPORT:\n\t\tgetHisEvent(EN_RUN_EVENT, &report->ctrl, &evt);//根据控件类查询历史事件的相关信息\n\t\tno = evt.data.run.no;//序号\n\t\tsysTimeToLocal(evt.data.run.t.sec, evt.data.run.t.us/1000, &st);//时间\n\t\tindex = evt.data.run.st_no;//事件索引号，根据索引号，在时间引用表中查询事件名称\n\t\tvalue = evt.data.run.st_val;//状态值\n\t\tbreak;\n\tcase TRP_REPORT:\n\t\tgetHisEvent(EN_TRIP_EVENT, &report->ctrl, &evt);//获取历史事件\n\t\tno = evt.data.trip.no;                          //动作事件的事件序号\n\t\tsysTimeToLocal(evt.data.trip.t.sec, evt.data.trip.t.us/1000, &st);//事件故障时间\n\t\tindex = evt.data.trip.st_no;                    //相对事件引用表的序号\n\t\tvalue = evt.data.trip.st_val;                   //事件状态值\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\tptr = lcdPullTextPixel(x, y);\n\tsprintf(ptr, \"%04d\", no);\n\tif(0 == ret)\n\t{\n\t\tsprintf(ptr + 5, \"%4d-%02d-%02d %02d:%02d:%02d:%03d\",\n\t\t\tst.year, st.month, st.day, st.hour, st.minute, st.second, st.milliseconds);//事件时间\n\n\t\tptr = lcdPullTextPixel(x, y+LCD_TEXT_H);  //换行\n\t\tLCD_STRCPY(ptr + 5, index < report->ref->num ? report->ref->fields[index]->desc : LCD_STRING(\"NONE_DESC\"));//事件名称\n\t\tif(report->type == SOE_REPORT)\n\t\t{\n\t\t\tsprintf(str,\"%d->%d\",evt.data.yx.old_val,evt.data.yx.st_val);\n\t\t    LCD_STRCPY(ptr + LCD_TEXT_COLNUM - 5, str); \n\t    }\n\t    else if(report->type == BI_CHG_REPORT) \n\t    {\n\t\t\tsprintf(str,\"%d->%d\",evt.data.bi.old_val,evt.data.bi.st_val);\n\t\t    LCD_STRCPY(ptr + LCD_TEXT_COLNUM - 5, str); \n\t    \n\t\t}\t\n\t    else\n\t    {\n\t    \t LCD_STRCPY(ptr + LCD_TEXT_COLNUM - 5, value ? \"0->1\" : \"1->0\");\n\t    }\n\t}\n\telse\n\t{\n\t\tLCD_STRCPY(ptr + 5, LCD_STRING(\"NONE_DATA\"));\n\t\tptr = lcdPullTextPixel(x, y+LCD_TEXT_H);\n\t\tLCD_STRCPY(ptr + 5, LCD_STRING(\"NONE_DESC\"));\n\t}\n\t//TODO 运行报告还有参数列表，建议采用多级展开模式更合理\n}\n// 运行报告具体条目的参数列表绘制\nstatic void lcdUiNormalReportDrawRunPara(INT16 x, INT16 y, INT16 row, INT16 col, void* param)\n{\n\tCHAR* ptr;\n\tUINT16 index;\n\tDataFields* field=NULL;\n\tLcdPageNormalReport* page = (LcdPageNormalReport*)param;\n\tLcdNormalReport* report = page->report;\n\tEventData* evt = &page->data;\n\n\tptr = lcdPullTextPixel(x, y);\n\tif(NULL != report->paraRef)\n\t{\n\t\tif((UINT16)row < evt->data.run.para_num)\n\t\t{\n\t\t\tindex = evt->data.run.para_no[row];\n\t\t\tif(index < report->paraRef->num)\n\t\t\t{\t\t\t\t\n\t\t\t\tfield = report->paraRef->fields[index];\n\t\t\t\tLCD_STRCPY(ptr, field->desc);                          //参数名称\n\t\t\t\tptr = lcdFormatValueStatic(evt->data.run.val+row, field, 0);//参数值\n\t\t\t\tlcdTextShowRight(LCD_WIDTH-LCD_TEXT_W, y, ptr);\n\t\t\t}\n\t\t}\n\t\tif(NULL == field)\n\t\t{\n\t\t\tLCD_STRCPY(ptr, LCD_STRING(\"NONE_DESC\"));\n\t\t}\n\t}\n\telse\n\t{\n\t\tLCD_STRCPY(ptr, LCD_STRING(\"INVALID_CONFIG\"));\n\t}\n\t\n\tif(col>0){}\n}\n// TRIP报告具体条目的参数列表绘制\nstatic void lcdUiNormalReportDrawTripPara(INT16 x, INT16 y, INT16 row, INT16 col, void* param)\n{\n\tCHAR* ptr;\n\tUINT16 index;\n\tFLOAT32 value;\n\tDataFields* field=NULL;\n\tLcdPageNormalReport* page = (LcdPageNormalReport*)param;\n\tLcdNormalReport* report = page->report;\n\tEventData* evt = &page->data;\n\n\tptr = lcdPullTextPixel(x, y);\n\tif(NULL != report->paraRef)\n\t{\n\t\tif((UINT16)row < evt->data.trip.para_num)\n\t\t{\n\t\t\tindex = evt->data.trip.para_no[row];\n\t\t\tif(index < report->paraRef->num)\n\t\t\t{\n\t\t\t\tfield = report->paraRef->fields[index];\n\t\t\t\tvalue = LCD_NATIVE(evt->data.trip.val[row], field);\n\t\t\t\tLCD_STRCPY(ptr, field->desc);\n\t\t\t\tptr = lcdFormatValueStatic(&value, field, 0);\n\t\t\t\tlcdTextShowRight(LCD_WIDTH-LCD_TEXT_W, y, ptr);\n\t\t\t}\n\t\t}\n\t\tif(NULL == field)\n\t\t{\n\t\t\tLCD_STRCPY(ptr, LCD_STRING(\"NONE_DESC\"));\n\t\t}\n\t}\n\telse\n\t{\n\t\tLCD_STRCPY(ptr, LCD_STRING(\"INVALID_CONFIG\"));\n\t}\n\t\n    if(col>0){}\n}\n// 普通报告具体条目绘制\nstatic void lcdUiNormalReportDrawItem(LcdRect* rect, LcdPageNormalReport* page)\n{\n\tCHAR* ptr;\n\tSystemTime st;\n\tUINT16 no=0;\n\tUINT16 index=0;\n\tUINT16 paraNum=0;\n\tUINT8 value=0;\n\tLCD_GRID_CELL_FUNC func=(LCD_GRID_CELL_FUNC)(0);\n\n\tLcdGrid ctrl;\n\tLcdRect client;\n\tINT32 ret = 1;\n\tEventData* evt = &page->data;\n\tLcdNormalReport* report = page->report;\n\n\treport->ctrl.order = 1;\n\treport->ctrl.off = (UINT16)page->reportIndex;\n\t/*各变量赋值*/\n\tif(EN_RUN_EVENT == report->innerType)\n\t{\n\t\tret = getHisEvent(EN_RUN_EVENT, &report->ctrl, evt);\n\t\tif(0 == ret)\n\t\t{\n\t\t\tno = evt->data.run.no;\n\t\t\tsysTimeToLocal(evt->data.run.t.sec, evt->data.run.t.us/1000, &st);\n\t\t\tindex = evt->data.run.st_no;\n\t\t\tvalue = evt->data.run.st_val;\n\t\t\tparaNum = evt->data.run.para_num;\n\t\t\tfunc = lcdUiNormalReportDrawRunPara;\n\t\t}\n\t}\n\telse if(EN_TRIP_EVENT == report->innerType)\n\t{\n\t\tret = getHisEvent(EN_TRIP_EVENT, &report->ctrl, evt);\n\t\tif(0 == ret)\n\t\t{\n\t\t\tno = evt->data.trip.no;\n\t\t\tsysTimeToLocal(evt->data.trip.t.sec, evt->data.trip.t.us/1000, &st);\n\t\t\tindex = evt->data.trip.st_no;\n\t\t\tvalue = evt->data.trip.st_val;\n\t\t\tparaNum = evt->data.trip.para_num;\n\t\t\tfunc = lcdUiNormalReportDrawTripPara;\n\t\t}\n\t}\n\t/*绘制页面参数具体内容*/\n\tif(0 == ret)\n\t{\n\t\tptr = lcdPullTextPixel(rect->x, rect->y);\n\t\tsprintf(ptr, \"%04d\", no);  //序号\n\t\tsprintf(ptr + 5, \"%4d-%02d-%02d %02d:%02d:%02d:%03d\",\n\t\t\tst.year, st.month, st.day, st.hour, st.minute, st.second, st.milliseconds);//时间\n\n\t\tptr = lcdPullTextPixel(rect->x, rect->y+LCD_TEXT_H);\n\t\tLCD_STRCPY(ptr + 5, index < report->ref->num ? report->ref->fields[index]->desc : LCD_STRING(\"NONE_DESC\"));//名称\n \n\t\tLCD_STRCPY(ptr + LCD_TEXT_COLNUM - 5, value ? \"0->1\" : \"1->0\"); \n\n\t\tpage->paraNum = paraNum;\n\t\tif(NULL != report->paraRef)\n\t\t{\n\t\t\tclient = *rect;\n\t\t\tclient.y += LCD_TEXT_H*2;\n\t\t\tclient.height -= LCD_TEXT_H*2;\n\t\t\tlcdGridInit(&ctrl, &client, paraNum, 0);\n\t\t\tctrl.showRow = page->showPara;\n\t\t\tlcdGridShow(&ctrl, func, page);//绘制事件参数（包括参数名称，参数值），由func来完成\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlcdMsgboxShow(LCD_STRING(\"INVALID_CONFIG\"));//无效配置\n\t\t}\n\t}\n\telse\n\t{\n\t\tpage->paraNum = 0;\n\t\tlcdMsgboxShow(LCD_STRING(\"NONE\"));//无内容\n\t}\n}\n// 普通报告页面显示\nstatic void lcdUiNormalReportShow(void* param)\n{\n\tLcdParamShow* par = LCD_PARAM_SHOW(param);\n\tLcd* lcd = par->lcd;\n\tLcdPageNormalReport* page = (LcdPageNormalReport*)par->page;\n\tLcdNormalReport* report = page->report;\n\tLcdGrid ctrl;\n\tLcdRect rect;\n\t\n\treport->num = getHisEventNum(report->innerType, &report->ctrl.start_no, &report->ctrl.last_no);\n\tif(NULL == report->ref)\n\t{\n\t\tlcdMsgboxShow(LCD_STRING(\"INVALID_CONFIG\"));\n\t}\n\telse if(0 == report->num)\n\t{\n\t\tlcdMsgboxShow(LCD_STRING(\"NONE\"));\n\t}\n\telse if(report->ref->num <= 0)\n\t{\n\t\tlcdMsgboxShow(LCD_STRING(\"NONE_CONFIG\"));\n\t}\n\telse if(page->reportIndex < 0)\n\t{\n\t\tlcdClientRect(lcd, &rect, 0);\n\t\tif(EN_RUN_EVENT == report->innerType || EN_TRIP_EVENT == report->innerType)  //显示运行报告和动作报告的所有条目\n\t\t{\n\t\t\tlcdGridInit(&ctrl, &rect, report->num, GRID_SELECT);\n\t\t\tctrl.rowHeight = LCD_TEXT_H * 2;\n\t\t\tctrl.showRow = page->showItem;\n\t\t\tctrl.selectRow = page->selectItem;\n\t\t\tlcdGridShow(&ctrl, lcdUiNormalReportDrawList, report);//显示报告列表\n\t\t}\n\t\telse  //显示除运行报告和动作报告之外的所有条目\n\t\t{\n\t\t\tlcdGridInit(&ctrl, &rect, report->num, 0);\n\t\t\tctrl.rowHeight = LCD_TEXT_H * 2;\n\t\t\tctrl.showRow = page->showItem;\n\t\t\tlcdGridShow(&ctrl, lcdUiNormalReportDrawList, report);\n\t\t}\n\t\t//LCD_TRACE2(\"lcdUiNormalReportShow: %d~%d\", report->ctrl.start_no, report->ctrl.last_no);\n\t}\n\telse    //运行报告和动作报告具体条目显示\n\t{\n\t\tlcdClientRect(lcd, &rect, 0);\n\t\tlcdUiNormalReportDrawItem(&rect, page);  //显示具体报告项（序号+时间+名称+状态值+参数名称+参数值）\n\t\t//LCD_TRACE3(\"lcdUiNormalReportShow: %d~%d, %d\", report->ctrl.start_no, report->ctrl.last_no, page->reportIndex);\n\t}\n\tlcdFrameShow(lcd, 0, 0);\n}\n// 普通报告页面按键\nstatic void lcdUiNormalReportKey(void* param)\n{\n\tLcdParamKey* par = LCD_PARAM_KEY(param);\n\tLcd* lcd = par->lcd;\n\tINT32 key = par->key;\n\tLcdPageNormalReport* page = (LcdPageNormalReport*)par->page;\n\tLcdNormalReport* report = page->report;\n\tLcdGrid ctrl;\n\tLcdRect rect;\n\n\treport->num = getHisEventNum(report->innerType, &report->ctrl.start_no, &report->ctrl.last_no);//读取历史事件的数目\n\tif(LCD_KEY_LEFT == key || LCD_KEY_RIGHT == key)\n\t{\n\t\tlcdUiAlttabKey(param);\n\t}\n\telse if(report->num > 0 && NULL != report->ref && report->ref->num > 0)//有事件发生过\n\t{\n\t\t// 列表\n\t\tif(page->reportIndex < 0)//step 1 \n\t\t{\n\t\t\tlcdClientRect(lcd, &rect, 0);\n\t\t\t\n\t\t\tif(EN_RUN_EVENT == report->innerType || EN_TRIP_EVENT == report->innerType)//运行报告和动作报告业务下，黑影显示\n\t\t\t{\n\t\t\t\tlcdGridInit(&ctrl, &rect, report->num, GRID_SELECT);\n\t\t\t\tctrl.rowHeight = LCD_TEXT_H * 2;\n\t\t\t\tctrl.showRow = page->showItem;\n\t\t\t\tctrl.selectRow = page->selectItem;\n\t\t\t\tlcdGridKey(&ctrl, key);\n\t\t\t\tpage->showItem = ctrl.showRow;\n\t\t\t\tpage->selectItem = ctrl.selectRow;\n\t\t\t\tif(LCD_KEY_ENTER == key)\n\t\t\t\t{\n\t\t\t\t\tpage->reportIndex = page->selectItem;//>=0  进入step 2\n\t\t\t\t\tlcdRedraw();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse  //除运行报告和动作报告业务之外的业务\n\t\t\t{\n\t\t\t\tlcdGridInit(&ctrl, &rect, report->num, 0);\n\t\t\t\tctrl.rowHeight = LCD_TEXT_H * 2;\n\t\t\t\tctrl.showRow = page->showItem;\n\t\t\t\tlcdGridKey(&ctrl, key);\n\t\t\t\tpage->showItem = ctrl.showRow;\n\t\t\t}\n\t\t\t\n\t\t\tif(LCD_KEY_ESC == key)\n\t\t\t{\n\t\t\t\tlcdClosePage((LcdPage*)page);//关闭页面\n\t\t\t}\n\t\t}\n\t\t// 条目\n\t\telse  //step =2\n\t\t{\n\t\t\tif(LCD_KEY_DOWN == key)\n\t\t\t{\n\t\t\t\tif(page->reportIndex > 0)\n\t\t\t\t{\n\t\t\t\t\tpage->reportIndex--;\n\t\t\t\t\tpage->showPara = 0;\n\t\t\t\t\tlcdRedraw();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(LCD_KEY_UP == key)\n\t\t\t{\n\t\t\t\tif(page->reportIndex < report->num - 1)\n\t\t\t\t{\n\t\t\t\t\tpage->reportIndex++;\n\t\t\t\t\tpage->showPara = 0;\n\t\t\t\t\tlcdRedraw();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(LCD_KEY_ESC == key)\n\t\t\t{\n\t\t\t\tpage->reportIndex = -1;\n\t\t\t\tlcdRedraw();\n\t\t\t}\n\t\t\telse if(NULL != report->paraRef && page->paraNum > 0)\n\t\t\t{\n\t\t\t\tlcdClientRect(lcd, &rect, 0);\n\t\t\t\trect.y += LCD_TEXT_H*2;\n\t\t\t\trect.height -= LCD_TEXT_H*2;\n\t\t\t\tlcdGridInit(&ctrl, &rect, page->paraNum, 0);\n\t\t\t\tctrl.showRow = page->showPara;\n\t\t\t\tif ((LCD_KEY_ADD == key) || (LCD_KEY_SUB))\n\t\t\t\t{\n\t\t\t\t\tlcdGridKey(&ctrl, key);\n\t\t\t\t\tpage->showPara = ctrl.showRow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse if(LCD_KEY_ESC == key)\n\t{\n\t\tlcdClosePage((LcdPage*)page);\n\t}\n}\n/************************************************************\n * 函数名称: lcdOpNormalReport\n * 函数功能: 普通的历史报告业务入口\n * 输入参数: param, 标准入口参数\n * 输出参数: 无\n * 返回值  : 无 \n * 修改记录: \n *   V1.00 2012-12-20, hxc: 初次实现\n ************************************************************/\nvoid lcdOpNormalReport(void* param)\n{\n\tLcdParamMenu* par = LCD_PARAM_MENU(param);\n\tLcd* lcd = par->lcd;\n\tLcdPageNormalReport* page = LCD_NEW_DPAGE(LcdPageNormalReport, lcd);\n\n\tpage->showFunc = lcdUiNormalReportShow;\n\tpage->keyFunc = lcdUiNormalReportKey;\n\tpage->report = LCD_CLASS_CAST(LcdNormalReport, par->data);\n\tpage->reportIndex = -1;\n\tlcdOpenPage((LcdPage*)page);\n}\n////////////////////////////////////////////////////////////////////////////////////////\n/************************************************************\n * 函数名称: lcdOpOrderReportInit\n * 函数功能: 控制报告业务初始化\n * 输入参数: param, 标准入口参数\n * 输出参数: 无\n * 返回值  : 无 \n * 修改记录: \n *   V1.00 2012-12-20, hxc: 初次实现\n ************************************************************/\nvoid lcdOpOrderReportInit(void* param)\n{\n\tINT32 i;\n\tLcdParamInit* par = LCD_PARAM_INIT(param);\n\tLcdService* svr = par->svr;\n\tLcdOrderReport* report = LCD_NEWCLASS(LcdOrderReport);\n\tif(NULL == report)\n\t{\n\t\tLCD_EXCEPTION(\"lcdOpOrderReportInit: malloc failed\");\n\t\treturn;\n\t}\n\tsvr->menuParam = report;\n\tfor(i=0; i<svr->refNum && i<LCD_NUMOF(report->refs); ++i)\n\t{\n\t\tlcdRefTableInit(par->lcd, svr->refs[i]);\n\t\treport->refs[i] = svr->refs[i];\n\t}\n\tpar->lcd->orderReport = report;\n}\n// 控制报告页面\ntypedef struct lcd_page_orderreport\n{\n\tLCD_PAGE_BASE;\n\tINT32 orderItem;\n\tLcdOrderReport* report;\n} LcdPageOrderReport;\n\n// 获取控制报告业务类型字符串\nINT8 *getProtocol(UINT32 protocol_id)\n{\n\tINT8 *buf;\n\tswitch(protocol_id)\n\t{\n\tcase IEC103:\n\t\tbuf = (INT8*)getLocalDescByAbbr(\"Protocol_IEC103\");\n\t\tbreak;\n\tcase IEC61850:\n\t\tbuf = (INT8*)getLocalDescByAbbr(\"Protocol_IEC61850\");\n\t\tbreak;\n\tcase LCD:\n\t\tbuf = (INT8*)getLocalDescByAbbr(\"Protocol_LCD\");\n\t\tbreak;\n\tdefault:\n\t\tbuf = (INT8*)getLocalDescByAbbr(\"UnKnown\");\n\t\tbreak;\n\t}\n\treturn buf;\n}\n// 获取控制报告参数类型字符串\nINT8 *getCtrlPara(UINT32 ctrl_para)\n{\n\tINT8 *buf;\n\tswitch(ctrl_para)\n\t{\n\tcase SYNC_CHECK:\n\t\tbuf = (INT8*)getLocalDescByAbbr(\"SYNC_CHECK\");\n\t\tbreak;\n\tcase DEAD_CHECK:\n\t\tbuf = (INT8*)getLocalDescByAbbr(\"DEAD_CHECK\");\n\t\tbreak;\n\tcase NO_CHECK:\n\t\tbuf = (INT8*)getLocalDescByAbbr(\"NO_CHECK\");\n\t\tbreak;\n\tcase SYNC_DEAD_CHECK:\n\t\tbuf = (INT8*)getLocalDescByAbbr(\"SYNC_DEAD_CHECK\");\n\t\tbreak;\n\tdefault:\n\t\tbuf = (INT8*)getLocalDescByAbbr(\"UnKnown\");\n\t\tbreak;\n\t}\n\treturn buf;\n}\n// 获取控制报告控制模式字符串\nINT8 *getCtrlStep(UINT32 ctrl_step)\n{\n\tINT8 *buf;\n\tswitch(ctrl_step)\n\t{\n\tcase IDLE:\n\t\tbuf = (INT8*)getLocalDescByAbbr(\"CTRL_IDLE\");\n\t\tbreak;\n\tcase SELECT:\n\t\tbuf = (INT8*)getLocalDescByAbbr(\"CTRL_SELECT\");\n\t\tbreak;\n\tcase EXECUTE:\n\t\tbuf = (INT8*)getLocalDescByAbbr(\"CTRL_EXECUTE\");\n\t\tbreak;\n\tcase CANCEL:\n\t\tbuf = (INT8*)getLocalDescByAbbr(\"CTRL_CANCEL\");\n\t\tbreak;\n\tdefault:\n\t\tbuf = (INT8*)getLocalDescByAbbr(\"UnKnown\");\n\t\tbreak;\n\t}\n\treturn buf;\n}\n// 获取控制报告原因字符串\nINT8 *getCtrlCause(UINT32 ctrl_cause)\n{\n\tINT8* buf;\n\tswitch(ctrl_cause)\n\t{\n\tcase OBJ_ON_BUSY:\n\t\tbuf = (INT8*)getLocalDescByAbbr(\"OBJ_ON_BUSY\");\n\t\tbreak;\n\tcase CTRL_INVALID:\n\t\tbuf = (INT8*)getLocalDescByAbbr(\"CTRL_INVALID\");\n\t\tbreak;\n\tcase EXE_TIME_OUT:\n\t\tbuf = (INT8*)getLocalDescByAbbr(\"EXE_TIME_OUT\");\n\t\tbreak;\n\tcase DEV_STATUS_BS:\n\t\tbuf = (INT8*)getLocalDescByAbbr(\"DEV_STATUS_BS\");\n\t\tbreak;\n\tcase DEV_LOCAL_CTRL:\n\t\tbuf = (INT8*)getLocalDescByAbbr(\"DEV_LOCAL_CTRL\");\n\t\tbreak;\n\tcase DEV_TEST:\n\t\tbuf = (INT8*)getLocalDescByAbbr(\"DEV_TEST\");\n\t\tbreak;\n\tcase ERROR_OPTION_VALUE:\n\t\tbuf = (INT8*)getLocalDescByAbbr(\"ERROR_OPTION_VALUE\");\n\t\tbreak;\n\tcase ERROR_SEL_VALUE:\n\t\tbuf = (INT8*)getLocalDescByAbbr(\"ERROR_SEL_VALUE\");\n\t\tbreak;\n\tcase ERROR_CLOSE_TYPE:\n\t\tbuf = (INT8*)getLocalDescByAbbr(\"ERROR_CLOSE_TYPE\");\n\t\tbreak;\n\tcase ERROR_RELATION_CONDITIION:\n\t\tbuf = (INT8*)getLocalDescByAbbr(\"ERROR_RELATION_CONDITIION\");\n\t\tbreak;\n\tcase ERROR_SYNC_CONDITIION:\n\t\tbuf = (INT8*)getLocalDescByAbbr(\"ERROR_SYNC_CONDITIION\");\n\t\tbreak;\n\tcase ERROR_U_LOW:\n\t\tbuf = (INT8*)getLocalDescByAbbr(\"ERROR_U_LOW\");\n\t\tbreak;\n\tcase ERROR_PTDX:\n\t\tbuf = (INT8*)getLocalDescByAbbr(\"ERROR_PTDX\");\n\t\tbreak;\n\tcase ERROR_VDIF:\n\t\tbuf = (INT8*)getLocalDescByAbbr(\"ERROR_VDIF\");\n\t\tbreak;\n\tcase ERROR_FDIF:\n\t\tbuf = (INT8*)getLocalDescByAbbr(\"ERROR_FDIF\");\n\t\tbreak;\n\tcase ERROR_DFDIF:\n\t\tbuf = (INT8*)getLocalDescByAbbr(\"ERROR_DFDIF\");\n\t\tbreak;\n\tcase ERROR_ADIF:\n\t\tbuf = (INT8*)getLocalDescByAbbr(\"ERROR_ADIF\");\n\t\tbreak;\n\tcase ERROR_U_HIG:\n\t\tbuf = (INT8*)getLocalDescByAbbr(\"ERROR_U_HIG\");\n\t\tbreak;\n\tcase CTRL_SUCCESS:\n\t\tbuf = (INT8*)getLocalDescByAbbr(\"CTRL_SUCCESS\");\n\t\tbreak;\n\tdefault:\n\t\tbuf = (INT8*)getLocalDescByAbbr(\"UnKnown\");\n\t\tbreak;\n\t}\t\t\n\treturn buf;\n}\n#define LCD_ORDERREPORT_COL 16\n\n// 控制报告页面显示\nstatic void lcdUiOrderReportShow(void* param)\n{\n\tLcdParamShow* par = LCD_PARAM_SHOW(param);\n\tLcdPageOrderReport* page = (LcdPageOrderReport*)par->page;\n\tHisEventReadCtrl rctrl;\n\tDataFields* field;\n\tEventData evt;\n\tSystemTime st;\n\tLcdRect rect;\n\tCHAR* ptr;\n\tOrderEvent* order;\n\tUINT16 num;\n\tLcdRefTable *Ref;\n\tUINT32       u_ctrl_value=0;\t//Bit1-Bit0：01（分）10（合）初始状态全为零\n\tFLOAT32      f_ctrl_value=0.0;\t//遥设值\n\tUINT8        show_para_flag=0;\n\tUINT32        ctrl_value = 0;  //by yzl\n\n\tnum = getHisEventNum(EN_ORDER_EVENT, &rctrl.start_no, &rctrl.last_no);\n\tif(0 == num)\n\t{\n\t\tlcdMsgboxShow(LCD_STRING(\"NONE\"));\n\t}\n\telse if(NULL == page->report->refs[0])\n\t{\n\t\tlcdMsgboxShow(LCD_STRING(\"INVALID_CONFIG\"));\n\t}\n\telse\n\t{\n\t\trctrl.order = 1;\n\t\trctrl.off = (UINT16)page->orderItem;\n\t\tgetHisEvent(EN_ORDER_EVENT, &rctrl, &evt);\n\t\torder = &evt.data.order;\n\t\tsysTimeToLocal(order->t.sec, order->t.us/1000, &st);\n\t\t\n\t\tswitch(order->inf.ctrl_type)\n\t    {\n\t    \tcase YK:\n\t    \t\tRef = page->report->refs[0] ;\n\t    \t\tu_ctrl_value=order->inf.ctrl_value.l_value;\n\t    \t\tbreak;\n\t    \tcase YS:\n\t    \t\tRef = page->report->refs[1] ;\n\t    \t\tf_ctrl_value=order->inf.ctrl_value.f_value;\n\t    \t\tbreak;\n\t    \tcase YT:\n\t    \t\tRef = page->report->refs[2] ;\n\t    \t\tu_ctrl_value=order->inf.ctrl_value.l_value;\n\t    \t\tbreak;\n\t    \tcase SK:\n\t    \t\tRef = page->report->refs[3] ;\n\t    \t\tu_ctrl_value=order->inf.ctrl_value.l_value;\n\t    \t\tbreak;\n\t    \tdefault:\n\t    \t\tRef = page->report->refs[0] ;\n\t    \t\tu_ctrl_value=order->inf.ctrl_value.l_value;\n\t    \t\tbreak;\n\t    }\n\t\t\n\t\tfield = Ref->fields[order->inf.index];\n\t\t//field = page->report->refs[0]->fields[order->inf.index];\n\n\t\tlcdClientRect(par->lcd, &rect, 0);\n\t\tptr = lcdPullTextPixel(rect.x, rect.y);\n\t\tsprintf(ptr, \"%04d\", order->no);\n\t\tsprintf(ptr + 5, \"%4d-%02d-%02d %02d:%02d:%02d:%03d\",\n\t\t\tst.year, st.month, st.day, st.hour, st.minute, st.second, st.milliseconds);\n\n\t\t//对象\n\t\trect.y += LCD_TEXT_H;\n\t\tlcdTextShow(rect.x + LCD_TEXT_X(LCD_ORDERREPORT_COL), rect.y, 0, 0, LCD_STRING(\"CTRL_OBJ\"), TEXT_FLAG_RIGHTALIGN); \n\t\tlcdDrawText(rect.x + LCD_TEXT_X(LCD_ORDERREPORT_COL+1), rect.y, field->desc, 0);\n        \n        //执行结果\n\t\trect.y += LCD_TEXT_H;\n\t\tlcdTextShow(rect.x + LCD_TEXT_X(LCD_ORDERREPORT_COL), rect.y, 0, 0, LCD_STRING(\"CTRL_RESULT\"), TEXT_FLAG_RIGHTALIGN); \n\t\tlcdDrawText(rect.x + LCD_TEXT_X(LCD_ORDERREPORT_COL+1), rect.y, getCtrlCause(order->inf.ctrl_cause), 0);\n        \n\t\t//参数\n\t\tif(YK == order->inf.ctrl_type)\n\t\t{\n\t\t\tif(u_ctrl_value!=0 &&(u_ctrl_value&0x03)!=0x01)\n    \t    {\n    \t\t\tshow_para_flag=1;\n    \t    }\n            if(show_para_flag)\n    \t\t{\n    \t\t\trect.y += LCD_TEXT_H;\n    \t\t\tlcdTextShow(rect.x + LCD_TEXT_X(LCD_ORDERREPORT_COL), rect.y, 0, 0, LCD_STRING(\"CTRL_PARA\"), TEXT_FLAG_RIGHTALIGN); \n    \t\t\tlcdDrawText(rect.x + LCD_TEXT_X(LCD_ORDERREPORT_COL+1), rect.y, getCtrlPara(order->inf.ctrl_para), 0);\n    \t\t}\n\t\t}\n\t\t\n\t\t//值\n\t\trect.y += LCD_TEXT_H;\n\t\tif(YS == order->inf.ctrl_type)\n\t\t{\n\t\t\tlcdTextShow(rect.x + LCD_TEXT_X(LCD_ORDERREPORT_COL), rect.y, 0, 0, LCD_STRING(\"CTRL_VALUE\"), TEXT_FLAG_RIGHTALIGN);\n\t\t\tptr = lcdPullTextPixel(rect.x + LCD_TEXT_X(LCD_ORDERREPORT_COL+1), rect.y);\n\t\t\tsprintf(ptr, \"%f\", order->inf.ctrl_value.f_value);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlcdTextShow(rect.x + LCD_TEXT_X(LCD_ORDERREPORT_COL), rect.y, 0, 0, LCD_STRING(\"CTRL_DIR\"), TEXT_FLAG_RIGHTALIGN);\n\t\t\t//if((order->inf.ctrl_value.l_value & 0x03) == 0x01)\n\t\t\tctrl_value = u_ctrl_value & 0x03 ;\n\t\t\tif(YT == order->inf.ctrl_type) //遥调\n\t\t\t{\n\t\t\t\tif(0x02 == ctrl_value ) //\n\t\t\t    {\n\t\t\t\t    lcdDrawText(rect.x + LCD_TEXT_X(LCD_ORDERREPORT_COL+1), rect.y, LCD_STRING(\"CTRL_HIGHER\"), 0);//升\n\t\t\t    }\n\t\t\t    else if(0x01 == ctrl_value )\n\t\t\t    {\n\t\t\t\t    lcdDrawText(rect.x + LCD_TEXT_X(LCD_ORDERREPORT_COL+1), rect.y, LCD_STRING(\"CTRL_LOWER\"), 0);//降\n\t\t\t    }\n\t\t\t    else   \n\t\t\t    {\n\t\t\t    \tlcdDrawText(rect.x + LCD_TEXT_X(LCD_ORDERREPORT_COL+1), rect.y, LCD_STRING(\"CTRL_STOP\"), 0);//停\n\t\t\t    }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(0x01 == ctrl_value )\n\t\t\t    {\n\t\t\t\t    lcdDrawText(rect.x + LCD_TEXT_X(LCD_ORDERREPORT_COL+1), rect.y, LCD_STRING(\"CTRL_SEPARATE\"), 0);//合\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\t    lcdDrawText(rect.x + LCD_TEXT_X(LCD_ORDERREPORT_COL+1), rect.y, LCD_STRING(\"CTRL_CLOSE\"), 0);//分\n\t\t\t    }\n\t\t\t}\n\t\t}\n\t\t//当前步骤\n\t\trect.y += LCD_TEXT_H;\n\t\tlcdTextShow(rect.x + LCD_TEXT_X(LCD_ORDERREPORT_COL), rect.y, 0, 0, LCD_STRING(\"CTRL_STEP\"), TEXT_FLAG_RIGHTALIGN); \n\t\tlcdDrawText(rect.x + LCD_TEXT_X(LCD_ORDERREPORT_COL+1), rect.y, getCtrlStep(order->inf.ctrl_step), 0);\n\n\t\t//规约\n\t\trect.y += LCD_TEXT_H;\n\t\tlcdTextShow(rect.x + LCD_TEXT_X(LCD_ORDERREPORT_COL), rect.y, 0, 0, LCD_STRING(\"CTRL_TYPE\"), TEXT_FLAG_RIGHTALIGN); \n\t\tlcdDrawText(rect.x + LCD_TEXT_X(LCD_ORDERREPORT_COL+1), rect.y, getProtocol(order->inf.ctrl_src_id), 0);\n\t\t\n\t\t//后台IP\n\t\tif(LCD != order->inf.ctrl_src_id)\n\t\t{\n\t\t\trect.y += LCD_TEXT_H;\n\t\t\tlcdTextShow(rect.x + LCD_TEXT_X(LCD_ORDERREPORT_COL), rect.y, 0, 0, LCD_STRING(\"CTRL_IP\"), TEXT_FLAG_RIGHTALIGN);\n\t\t\tptr = lcdPullTextPixel(rect.x + LCD_TEXT_X(LCD_ORDERREPORT_COL+1), rect.y);\n\t\t\tif(IEC61850 == order->inf.ctrl_src_id)\n\t\t\t{\n\t\t\t\t//ip_adr.s_addr = htonl(order->inf.ctrl_con_id);\n\t\t\t\t//inet_ntoa_b(ip_adr, s_ip_temp);\n\t\t\t\t//sprintf(ptr, s_ip_temp);\n\t\t\t\tsprintf(ptr, \"%d.%d.%d.%d\",\n\t\t\t\t\t(order->inf.ctrl_con_id >> 24) & 0xff, \n\t\t\t\t\t(order->inf.ctrl_con_id >> 16) & 0xff,\n\t\t\t\t\t(order->inf.ctrl_con_id >> 8) & 0xff,\n\t\t\t\t\torder->inf.ctrl_con_id & 0xff );\n\t\t\t}\n\t\t\telse\n\t\t\t{\t\t\t\n\t\t\t\tsprintf(ptr, \"%d\", order->inf.ctrl_con_id);\n\t\t\t}\n\t\t}\t\n\t}\n\tlcdFrameShow(par->lcd, 0, 0);\n}\n// 控制报告页面按键\nvoid lcdUiOrderReportKey(void* param)\n{\n\tLcdParamKey* par = LCD_PARAM_KEY(param);\n\tINT32 key = par->key;\n\tLcdPageOrderReport* page = (LcdPageOrderReport*)par->page;\n\tLcdOrderReport* report = page->report;\n\tUINT32 start;\n\tUINT32 last;\n\tUINT16 num;\n\n\tswitch(key)\n\t{\n\tcase LCD_KEY_UP:\n\t\tnum = getHisEventNum(EN_ORDER_EVENT, &start, &last);\n\t\tif(num > 1 && page->orderItem < (INT32)num - 1)\n\t\t{\n\t\t\tpage->orderItem++;\n\t\t\tlcdRedraw();\n\t\t}\n\t\tbreak;\n\tcase LCD_KEY_DOWN:\n\t\tnum = getHisEventNum(EN_ORDER_EVENT, &start, &last);\n\t\tif(page->orderItem > 0)\n\t\t{\n\t\t\tpage->orderItem--;\n\t\t\tlcdRedraw();\n\t\t}\n\t\tbreak;\t\n\tcase LCD_KEY_LEFT:\n\tcase LCD_KEY_RIGHT:\n\t\tlcdUiAlttabKey(param);\n\t\tbreak;\n\tcase LCD_KEY_ESC:\n\t\tlcdClosePage((LcdPage*)page);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n/************************************************************\n * 函数名称: lcdOpOrderReport\n * 函数功能: 控制报告显示业务入口\n * 输入参数: param, 标准入口参数\n * 输出参数: 无\n * 返回值  : 无 \n * 修改记录: \n *   V1.00 2012-12-20, hxc: 初次实现\n ************************************************************/\nvoid lcdOpOrderReport(void* param)\n{\n\tLcdParamMenu* par = LCD_PARAM_MENU(param);\n\tLcd* lcd = par->lcd;\n\tLcdPageOrderReport* page = LCD_NEW_DPAGE(LcdPageOrderReport, lcd);\n\n\tpage->showFunc = lcdUiOrderReportShow;\n\tpage->keyFunc = lcdUiOrderReportKey;\n\tpage->report = LCD_CLASS_CAST(LcdOrderReport, par->data);\n\n\tlcdOpenPage((LcdPage*)page);\n}\n",
					"file": "sy.src/sy.hmi/lcd/src/lcdreport.c",
					"file_size": 36420,
					"file_write_time": 131214066369667168,
					"settings":
					{
						"buffer_size": 34160,
						"encoding": "Western (Windows 1252)",
						"line_ending": "Windows",
						"scratch": true
					}
				}
			],
			"build_system": "",
			"build_system_choices":
			[
			],
			"build_varint": "",
			"command_palette":
			{
				"height": 242.0,
				"last_filter": "Cscope: ",
				"selected_items":
				[
					[
						"Cscope: ",
						"Cscope: Look up functions calling this function"
					],
					[
						"syntax",
						"Set Syntax: C"
					],
					[
						"syntax:c",
						"Set Syntax: C"
					],
					[
						"install",
						"Package Control: Install Package"
					],
					[
						"Package Control: ",
						"Package Control: Install Package"
					],
					[
						"set syntax:c",
						"Set Syntax: C"
					],
					[
						"ins",
						"Package Control: Install Package"
					],
					[
						"x",
						"Set Syntax: XML"
					],
					[
						"sy",
						"Set Syntax: C"
					],
					[
						"make",
						"Set Syntax: Makefile"
					],
					[
						"syntax:make",
						"Set Syntax: Makefile"
					],
					[
						"Package Control: install ",
						"Package Control: Install Package"
					],
					[
						"Package Control: install c",
						"Package Control: Install Package"
					],
					[
						":w",
						":w - Save"
					]
				],
				"width": 528.0
			},
			"console":
			{
				"height": 146.0,
				"history":
				[
					"install package",
					"import urllib.request,os; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ','%20')).read())"
				]
			},
			"distraction_free":
			{
				"menu_visible": true,
				"show_minimap": false,
				"show_open_files": false,
				"show_tabs": false,
				"side_bar_visible": false,
				"status_bar_visible": false
			},
			"expanded_folders":
			[
				"/D/workspace/U21",
				"/D/workspace/U21/sy.src",
				"/D/workspace/U21/sy.src/sy.hmi",
				"/D/workspace/U21/sy.src/sy.hmi/lcd/src",
				"/D/workspace/U21/sy.src/sy.hmi/rttask/src",
				"/D/workspace/U21/sy.src/sy.sys",
				"/D/workspace/U21/sy.src/sy.sys/sy6101/kernel",
				"/D/workspace/U21/sy.src/sy.sys/system",
				"/D/workspace/U21/sy.src/sy.sys/system/src"
			],
			"file_history":
			[
				"/D/workspace/U21/sy.release/sy.sys/common.pic33/inc/p33FJ128GP706A.h",
				"/D/workspace/U21/sy.src/vxworks.mk",
				"/D/workspace/U21/sy.src/sy.sys/system/src/salve.c",
				"/D/workspace/U21/sy.src/sy.sys/system/src/can.c",
				"/D/workspace/U21/sy.src/sy.hmi/rttask/inc/wavep.h",
				"/D/workspace/U21/sy.src/sy.hmi/rttask/src/comtrade.c",
				"/D/workspace/U21/sy.src/sy.hmi/rttask/inc/rtcommon.h",
				"/D/workspace/U21/sy.release/sy.sys/sy6101L/inc/setting.h",
				"/D/workspace/Distribution_Network/sy.src/sy.slave/Makefile",
				"/D/workspace/Distribution_Network/sy.src/sy.slave/sy2101/Makefile",
				"/C/Users/wangzhichao/Desktop/wave/wave/comtrade/16949_20150701_100132_004.hdr",
				"/D/workspace/Distribution_Network/sy.src/vxworks.mk",
				"/D/workspace/Distribution_Network/sy.src/Makefile",
				"/D/SVN/Distribution_Network/sy.src/sy.slave/sy2102/app/src/appinit.c",
				"/D/5.Real/Zeitest/Distribution/config.xml",
				"/D/5.Real/Zeitest/Distribution/platform/config.xml",
				"/D/workspace/U21/sy.src/sy.sys/sy6201/Makefile",
				"/D/workspace/U21/sy.src/sy.sys/sy6101/app/Makefile",
				"/D/workspace/U21/sy.src/sy.hmi/Makefile",
				"/D/workspace/U21/sy.src/sy.hmi/rttask/src/event.c",
				"/D/workspace/U21/sy.src/sy.sys/system/src/ivt.c",
				"/D/workspace/U21/sy.release/sy.sys/system/inc/ivt.h",
				"/D/workspace/U21/sy.src/sy.hmi/rttask/src/sram.c",
				"/D/workspace/U21/sy.src/sy.hmi/lcd/inc/lcd.h",
				"/D/workspace/U21/sy.src/sy.hmi/rttask/inc/event.h",
				"/D/workspace/U21/sy.src/sy.hmi/rttask/inc/eventp.h",
				"/D/workspace/U21/sy.release/sy.sys/sy6101L/inc/dbg.h",
				"/E/apprentice/eclipse/algs4/src/algs4/PercolationStats.java",
				"/E/apprentice/eclipse/algs4/src/algs4/Percolation.java",
				"/D/workspace/U21/sy.src/sy.hmi/lcd/src/lcdbase.c",
				"/D/workspace/U21/sy.src/sy.hmi/lcd/src/lcdhome.c",
				"/D/workspace/U21/sy.src/sy.hmi/lcd/src/lcd.c",
				"/D/workspace/U21/sy.release/sy.sys/sy6101L/inc/dev.h",
				"/E/apprentice/eclipse/algs4/data/percolation/sedgewick60.txt",
				"/E/apprentice/eclipse/algs4/src/algs4/PercolationStat.java",
				"/E/Ryan/Sublime Text Build 3083/Data/Packages/User/Default (Windows).sublime-keymap",
				"/E/Ryan/Sublime Text Build 3083/Data/Packages/CTags/Default.sublime-mousemap",
				"/E/Ryan/Sublime Text Build 3083/Data/Packages/CTags/Default.sublime-keymap",
				"/D/workspace/U21/sy.src/sy.sys/sy6201/sys/src/sy6201.c",
				"/D/workspace/U21/sy.src/sy.hmi/rttask/src/rttask.c",
				"/D/workspace/U21/sy.src/sy.hmi/rttask/inc/sram.h",
				"/D/workspace/U21/sy.src/sy.hmi/rttask/inc/sramp.h",
				"/D/workspace/U21/sy.src/sy.hmi/rttask/inc/rtconst.h",
				"/D/workspace/U21/sy.src/sy.sys/sy6201/sys/Makefile",
				"/D/workspace/U21/sy.src/sy.sys/sy6201/app/Makefile",
				"/D/workspace/U21/sy.src/sy.sys/sy6101/sys/Makefile",
				"/D/workspace/U21/sy.src/sy.sys/sy6101/modules/Makefile",
				"/D/workspace/U21/sy.src/sy.sys/system/Makefile",
				"/C/Users/wangzhichao/Desktop/startup.txt",
				"/D/workspace/U21/sy.src/sy.sys/system/src/canovt.c",
				"/E/apprentice/eclipse/algs4/data/percolation/PercolationVisualizer.java",
				"/D/workspace/U21/sy.release/sy.sys/sy6101L/inc/master.h",
				"/D/workspace/U21/sy.release/sy.sys/system/inc/msgtype.h",
				"/D/workspace/U21/sy.src/sy.sys/system/src/parameter.c",
				"/D/workspace/U21/sy.release/sy.sys/system.16.04.06/inc/syslave.h",
				"/D/workspace/U21/sy.src/sy.sys/system/inc/ivt.h",
				"/D/workspace/U21/sy.src/sy.sys/system/src/locivt.c",
				"/D/workspace/U21/sy.release/sy.sys/system.16.04.06/inc/ivt.h",
				"/D/workspace/U21/sy.release/sy.sys/sy6101L/inc/sy6101.h",
				"/D/workspace/U21/sy.src/sy.sys/system/src/regsignal.c",
				"/D/workspace/U21/sy.src/sy.sys/sy6101/modules/src/hashtbl.c",
				"/D/workspace/U21/sy.release/sy.sys/sy6101L/inc/hashtbl.h",
				"/D/workspace/U21/sy.src/sy.sys/system/src/ovt.c",
				"/D/workspace/U21/sy.src/sy.sys/system/src/hbus.c",
				"/D/workspace/U21/sy.src/sy.sys/system/src/hbusovt.c",
				"/D/workspace/U21/sy.src/sy.hmi/iec103/inc/iec103asdu.h",
				"/D/workspace/U21/sy.src/sy.hmi/iec103/src/nr103link.c",
				"/D/workspace/U21/sy.release/sy.sys/system.16.04.06/inc/can.h",
				"/D/workspace/U21/sy.src/sy.hmi/iec103/src/nr103asdu.c",
				"/D/workspace/U21/sy.src/sy.hmi/lcd/inc/lcdaccoeff.h",
				"/D/workspace/U21/sy.src/sy.hmi/lcd/src/lcddebug.c",
				"/D/workspace/U21/sy.src/sy.hmi/lcd/inc/lcddebug.h",
				"/D/workspace/U21/sy.src/sy.hmi/iec103/src/iec103link.c",
				"/D/workspace/U21/sy.src/sy.sys/Makefile",
				"/D/workspace/U21/sy.src/sy.hmi/iec103/src/iec103asdu.c",
				"/E/Ryan/algs4partI-009/dataAndSource/algs4-data/tobe.txt",
				"/D/workspace/U21/sy.src/sy.sys/system/makeall",
				"/D/workspace/U21/sy.src/Makefile",
				"/D/workspace/U21/sy.src/sy.hmi/iec103/src/init103gs.c",
				"/D/workspace/U21/sy.src/sy.hmi/iec103/src/iec103.c",
				"/D/5.Real/Zeitest/UDC302_4t1/死区说明.txt",
				"/D/workspace/U21/sy.src/sy.hmi/lcd/src/lcdstatus.c",
				"/D/workspace/U21/sy.src/sy.hmi/lcd/src/lcdservice.c",
				"/D/workspace/U21/sy.src/sy.hmi/lcd/src/lcdpage.c",
				"/D/workspace/U21/sy.src/sy.hmi/iec103/src/testshow.c",
				"/D/workspace/U21/sy.src/sy.hmi/iec103/src/queue.c",
				"/D/workspace/U21/sy.src/sy.hmi/lcd/src/lcdversion.c",
				"/D/workspace/U21/sy.src/sy.hmi/lcd/src/lcdgrid.c",
				"/D/workspace/U21/sy.src/sy.hmi/lcd/inc/lcdbase.h",
				"/D/workspace/U21/sy.src/sy.hmi/lcd/src/lcdtest.c",
				"/D/workspace/U21/sy.src/sy.hmi/lcd/src/lcdorder.c",
				"/D/workspace/U21/sy.src/sy.hmi/lcd/src/lcddiagram.c",
				"/D/workspace/U21/sy.src/sy.hmi/lcd/src/lcddraw.c",
				"/D/workspace/U21/sy.src/sy.hmi/iec103/inc/iec103.h",
				"/D/workspace/U21/sy.src/sy.hmi/rttask/inc/sysntp.h",
				"/D/workspace/U21/sy.src/sy.hmi/rttask/src/sysntp.c",
				"/D/workspace/U21/sy.src/sy.sys/sy6101/modules/src/fd.c",
				"/D/3.platform resource/邱大为版本程序/6in1版本/ccc/system的inc/inc/bcomponent.h",
				"/D/workspace/U21/sy.release/sy.sys/system/inc/component.h",
				"/D/workspace/U21/sy.release/sy.sys/system.16.04.06/inc/component.h",
				"/E/apprentice/Computer/C programming/solutions/CPP/ch7/11.c",
				"/D/workspace/U21/sy.src/sy.hmi/lcd/src/lcdctrl.c",
				"/D/workspace/U21/sy.src/sy.hmi/lcd/src/lcdjoin.cpp",
				"/D/5.Real/Zeitest/UDC_DYSFZ/extr_UDC_DYSFZ/10/config.xml",
				"/E/apprentice/Computer/C programming/solutions/CPP/ch7/8.c",
				"/E/apprentice/Computer/C programming/solutions/CPP/ch7/9.c",
				"/D/workspace/U21/sy.src/sy.hmi/print/src/print.c",
				"/D/workspace/U21/sy.src/sy.hmi/print/src/printfunc.c",
				"/D/workspace/U21/sy.src/sy.hmi/print/inc/print.h",
				"/E/Ryan/Sublime Text Build 3083/Data/Packages/User/CscopeSublime.sublime-settings",
				"/E/Ryan/Sublime Text Build 3083/Data/Packages/User/CTags.sublime-settings",
				"/D/workspace/U21/sy.src/sy.hmi/print/src/printinit.c",
				"/E/VM/CentOS7.vmx",
				"/D/workspace/U21/sy.release/sy.sys/common.gnu/inc/linux/types.h",
				"/D/workspace/U21/sy.src/sy.hmi/ld.lst",
				"/D/workspace/U21_6IN1/sy.src/sy.hmi/rttask/src/sysntp.c",
				"/D/workspace/U21_6IN1/sy.src/sy.hmi/rttask/inc/sysntp.h",
				"/D/workspace/U21_6IN1/sy.release/sy.sys/common.sharc21469/inc/sharc21469.h",
				"/D/workspace/U21_4t1/sy.src/sy.hmi/rttask/src/sysntp.c",
				"/D/workspace/U21_6IN1/sy.release/sy.sys/common.gnu/inc/base/string.c",
				"/D/workspace/U21_4t1/sy.release/sy.sys/sy6101L/inc/sy6101.h",
				"/D/3.platform resource/邱大为版本程序/6in1版本/六统一hmi代码/print/makefile",
				"/D/workspace/U21_6IN1/sy.src/sy.hmi/rttask/src/event.c",
				"/D/workspace/U21_6IN1/sy.src/sy.hmi/rttask/src/comtrade.c",
				"/D/workspace/U21_6IN1/sy.src/sy.hmi/rttask/src/wave.c",
				"/D/workspace/U21_6IN1/sy.src/sy.hmi/rttask/src/rtcommon.c",
				"/D/workspace/U21_6IN1/sy.src/sy.hmi/rttask/src/.tags",
				"/E/Ryan/Sublime Text Build 3083/Data/Packages/Cscope/CscopeSublime.sublime-settings"
			],
			"find":
			{
				"height": 36.0
			},
			"find_in_files":
			{
				"height": 90.0,
				"where_history":
				[
					"D:\\workspace\\U21\\sy.src\\sy.hmi\\iec103",
					"D:\\workspace\\U21\\sy.src\\sy.hmi\\lcd",
					"D:\\workspace\\U21\\sy.src",
					"D:\\workspace\\U21",
					"D:\\workspace\\U21\\sy.src\\sy.hmi\\lcd",
					"D:\\workspace\\U21\\sy.src\\sy.hmi\\iec103",
					"D:\\workspace\\U21\\sy.src\\sy.hmi\\lcd",
					"D:\\workspace\\U21\\sy.src\\sy.hmi\\iec103\\inc",
					"D:\\workspace\\U21\\sy.src\\sy.hmi\\iec103",
					"D:\\workspace\\U21\\sy.src\\sy.hmi\\iec103\\inc",
					"D:\\workspace\\U21\\sy.src\\sy.hmi\\iec103",
					"D:\\workspace\\U21\\sy.src\\sy.hmi\\lcd\\src",
					"D:\\workspace\\U21",
					"D:\\workspace\\U21\\sy.src\\sy.hmi\\lcd",
					"D:\\workspace\\U21\\sy.src",
					"D:\\workspace\\U21\\sy.src\\sy.hmi\\rttask",
					"D:\\workspace\\U21",
					"D:\\workspace\\U21\\sy.src\\sy.hmi\\rttask",
					"D:\\3.platform resource\\5试验fpk\\UDC-311AG_Ver1.19",
					"D:\\3.platform resource\\赵小伟版本程序\\u21 工程\\iec103",
					"D:\\workspace,D:\\3.platform resource\\赵小伟版本程序,D:\\3.platform resource\\邱大为版本程序",
					"D:\\workspace,D:\\3.platform resource\\赵小伟版本程序",
					"D:\\workspace\\U21_6IN1",
					"C:\\Users\\wangzhichao\\Desktop\\代码改动",
					"D:\\workspace\\U21_6IN1"
				]
			},
			"find_state":
			{
				"case_sensitive": false,
				"find_history":
				[
					"putCheckEvent",
					"p_data",
					"write",
					"putRunEvent",
					"p_item",
					"para_size",
					"p_item",
					"p_event_cfg",
					"Error",
					"error",
					"B05",
					"p_ctrl",
					"p_event_cfg",
					"event",
					"Event",
					"event",
					"p_ctrl",
					"rttask_time_count",
					"eventTask",
					"current=hbus_bit_ivt[0]",
					"numberOfOpenSites",
					" +",
					"with_index_que",
					"para_size",
					"max_index",
					"p_cfg_start",
					"p_cfg",
					"msg sub_type is 9",
					"msg sub_type is 8",
					"msg sub_type is 13",
					"current_ivt",
					"cur_loc_addr",
					"this_type",
					"msg sub_type is 6",
					"D1 B9",
					"CF DF",
					"C2 B7",
					"B5 CD",
					"msg sub_type is 5",
					"msg sub_type is 4",
					"msg sub_type is 3",
					"sg sub_type is 3",
					"msg sub_type is 3",
					"sntpTask",
					"initSntpTimer",
					"send_sntp_timer_count",
					"wait_sntp_reply_timer_count",
					"wait_sntp_invalid_count",
					"send_sntp_timer_period",
					"send_sntp_timer_count",
					"para_addr",
					"middle_packet",
					"para_index",
					"index",
					"len",
					"para_part_len",
					"ref_para",
					"ordCanMsgProc",
					"msg",
					"m",
					"msg",
					"rmsg",
					"31",
					"32",
					"31",
					"49",
					"50",
					"g_lcd_draw_session",
					"accoef_crc_table",
					"result",
					"canMsgProc",
					"DataFields:",
					"printf(\"DataFields",
					"printf(\"title",
					"title:",
					"appNew",
					"put",
					"putSlave",
					"accoeff.ini",
					"offset",
					"p_103_data",
					"formGenDataElement",
					"p_tx_buf",
					"formGenDataElement",
					"procAsdu221",
					"f_zdb",
					"i",
					"I",
					"i",
					"p_datafield",
					"kod",
					"CT",
					"lcdShowStatus",
					"9",
					"gdd_type",
					"GDD",
					"gdd",
					"hmi.xml",
					"++",
					"recieve_counter",
					"++",
					"+",
					"++",
					"freeTcp",
					"recv_sntp_counter",
					"hmi.xml",
					"discount",
					"printWaveNof",
					"printWave",
					"sec",
					"cp->wait_sntp_invalid_period",
					" p_reply->referenceIdentifie",
					"_NTP_DEBUG",
					"_NTP_DBG",
					"initSoeProcess(cp)",
					"ret = initSoeProcess(cp)",
					"clear",
					"clearAllRealEventByMoniblk",
					"rttask.run_cnt type",
					"B10.rttask.run_cnt",
					"SNTP_DBG",
					"sntpTeask",
					"sntpTask",
					"INT8 buf",
					"0xff",
					"INF",
					"FUN",
					"printf(\"this is line %d  in file %s\\n\", __LINE__,  __FILE__)"
				],
				"highlight": true,
				"in_selection": false,
				"preserve_case": false,
				"regex": true,
				"replace_history":
				[
					"_NTP_DBF",
					"sntpTask",
					"LCD_PSD_DBG_MSG",
					"",
					"LCD_MAX_FACTOR_ADJUST",
					"crc_table_ini",
					"LCD_FILE_INI",
					"LCD_INI_BUFFER_SIZE",
					"LCD_INI_DEBUG",
					"INI_BUFFER_SIZE",
					"PRINTINFO",
					"crc32_calc_ini",
					"crc_table_ini",
					"BUFFER_SIZE",
					"printf",
					"U",
					"INT8",
					"INT32",
					"int",
					"unsigned int",
					"short",
					"char",
					"UINT",
					"INT8",
					"INT32",
					"UINT8",
					"INT8",
					"B7",
					"B6",
					"dec_ans",
					"",
					" ",
					",",
					" ",
					",",
					"",
					"swc_1_horgw1",
					"swc_2_horgw1",
					"swc_3_horgw1",
					"add",
					"set",
					" ",
					"",
					" ",
					"service",
					" "
				],
				"reverse": false,
				"show_context": true,
				"use_buffer2": true,
				"whole_word": false,
				"wrap": true
			},
			"groups":
			[
				{
					"selected": 1,
					"sheets":
					[
						{
							"buffer": 0,
							"file": "sy.src/sy.hmi/rttask/src/sysntp.c",
							"semi_transient": false,
							"settings":
							{
								"buffer_size": 21682,
								"regions":
								{
								},
								"selection":
								[
									[
										5614,
										5614
									]
								],
								"settings":
								{
									"bracket_highlighter.busy": false,
									"bracket_highlighter.locations":
									{
										"close":
										{
											"1":
											[
												5904,
												5905
											]
										},
										"icon":
										{
											"1":
											[
												"Packages/BracketHighlighter/icons/curly_bracket.png",
												"brackethighlighter.default"
											]
										},
										"open":
										{
											"1":
											[
												5500,
												5501
											]
										},
										"unmatched":
										{
										}
									},
									"bracket_highlighter.regions":
									[
										"bh_c_define",
										"bh_c_define_center",
										"bh_c_define_open",
										"bh_c_define_close",
										"bh_c_define_content",
										"bh_curly",
										"bh_curly_center",
										"bh_curly_open",
										"bh_curly_close",
										"bh_curly_content",
										"bh_double_quote",
										"bh_double_quote_center",
										"bh_double_quote_open",
										"bh_double_quote_close",
										"bh_double_quote_content",
										"bh_tag",
										"bh_tag_center",
										"bh_tag_open",
										"bh_tag_close",
										"bh_tag_content",
										"bh_angle",
										"bh_angle_center",
										"bh_angle_open",
										"bh_angle_close",
										"bh_angle_content",
										"bh_round",
										"bh_round_center",
										"bh_round_open",
										"bh_round_close",
										"bh_round_content",
										"bh_single_quote",
										"bh_single_quote_center",
										"bh_single_quote_open",
										"bh_single_quote_close",
										"bh_single_quote_content",
										"bh_unmatched",
										"bh_unmatched_center",
										"bh_unmatched_open",
										"bh_unmatched_close",
										"bh_unmatched_content",
										"bh_square",
										"bh_square_center",
										"bh_square_open",
										"bh_square_close",
										"bh_square_content",
										"bh_regex",
										"bh_regex_center",
										"bh_regex_open",
										"bh_regex_close",
										"bh_regex_content",
										"bh_default",
										"bh_default_center",
										"bh_default_open",
										"bh_default_close",
										"bh_default_content"
									],
									"syntax": "Packages/C++/C.sublime-syntax",
									"translate_tabs_to_spaces": false
								},
								"translation.x": 0.0,
								"translation.y": 3581.0,
								"zoom_level": 1.0
							},
							"stack_index": 4,
							"type": "text"
						},
						{
							"buffer": 1,
							"file": "sy.src/sy.hmi/rttask/src/event.c",
							"semi_transient": false,
							"settings":
							{
								"buffer_size": 114785,
								"regions":
								{
								},
								"selection":
								[
									[
										48442,
										48442
									]
								],
								"settings":
								{
									"bracket_highlighter.busy": false,
									"bracket_highlighter.locations":
									{
										"close":
										{
											"1":
											[
												49985,
												49986
											]
										},
										"icon":
										{
											"1":
											[
												"Packages/BracketHighlighter/icons/curly_bracket.png",
												"brackethighlighter.default"
											]
										},
										"open":
										{
											"1":
											[
												48307,
												48308
											]
										},
										"unmatched":
										{
										}
									},
									"bracket_highlighter.regions":
									[
										"bh_c_define",
										"bh_c_define_center",
										"bh_c_define_open",
										"bh_c_define_close",
										"bh_c_define_content",
										"bh_curly",
										"bh_curly_center",
										"bh_curly_open",
										"bh_curly_close",
										"bh_curly_content",
										"bh_double_quote",
										"bh_double_quote_center",
										"bh_double_quote_open",
										"bh_double_quote_close",
										"bh_double_quote_content",
										"bh_tag",
										"bh_tag_center",
										"bh_tag_open",
										"bh_tag_close",
										"bh_tag_content",
										"bh_angle",
										"bh_angle_center",
										"bh_angle_open",
										"bh_angle_close",
										"bh_angle_content",
										"bh_round",
										"bh_round_center",
										"bh_round_open",
										"bh_round_close",
										"bh_round_content",
										"bh_single_quote",
										"bh_single_quote_center",
										"bh_single_quote_open",
										"bh_single_quote_close",
										"bh_single_quote_content",
										"bh_unmatched",
										"bh_unmatched_center",
										"bh_unmatched_open",
										"bh_unmatched_close",
										"bh_unmatched_content",
										"bh_square",
										"bh_square_center",
										"bh_square_open",
										"bh_square_close",
										"bh_square_content",
										"bh_regex",
										"bh_regex_center",
										"bh_regex_open",
										"bh_regex_close",
										"bh_regex_content",
										"bh_default",
										"bh_default_center",
										"bh_default_open",
										"bh_default_close",
										"bh_default_content"
									],
									"in_converting": true,
									"origin_encoding": "GB2312",
									"revert_to_scratch": true,
									"syntax": "Packages/C++/C.sublime-syntax",
									"translate_tabs_to_spaces": false
								},
								"translation.x": 0.0,
								"translation.y": 41343.0,
								"zoom_level": 1.0
							},
							"stack_index": 0,
							"type": "text"
						},
						{
							"buffer": 2,
							"file": "sy.src/sy.hmi/rttask/inc/rtcommon.h",
							"semi_transient": false,
							"settings":
							{
								"buffer_size": 8534,
								"regions":
								{
								},
								"selection":
								[
									[
										5624,
										5601
									]
								],
								"settings":
								{
									"bracket_highlighter.busy": false,
									"bracket_highlighter.locations":
									{
										"close":
										{
										},
										"icon":
										{
										},
										"open":
										{
										},
										"unmatched":
										{
										}
									},
									"bracket_highlighter.regions":
									[
										"bh_c_define",
										"bh_c_define_center",
										"bh_c_define_open",
										"bh_c_define_close",
										"bh_c_define_content",
										"bh_curly",
										"bh_curly_center",
										"bh_curly_open",
										"bh_curly_close",
										"bh_curly_content",
										"bh_double_quote",
										"bh_double_quote_center",
										"bh_double_quote_open",
										"bh_double_quote_close",
										"bh_double_quote_content",
										"bh_tag",
										"bh_tag_center",
										"bh_tag_open",
										"bh_tag_close",
										"bh_tag_content",
										"bh_angle",
										"bh_angle_center",
										"bh_angle_open",
										"bh_angle_close",
										"bh_angle_content",
										"bh_round",
										"bh_round_center",
										"bh_round_open",
										"bh_round_close",
										"bh_round_content",
										"bh_single_quote",
										"bh_single_quote_center",
										"bh_single_quote_open",
										"bh_single_quote_close",
										"bh_single_quote_content",
										"bh_unmatched",
										"bh_unmatched_center",
										"bh_unmatched_open",
										"bh_unmatched_close",
										"bh_unmatched_content",
										"bh_square",
										"bh_square_center",
										"bh_square_open",
										"bh_square_close",
										"bh_square_content",
										"bh_regex",
										"bh_regex_center",
										"bh_regex_open",
										"bh_regex_close",
										"bh_regex_content",
										"bh_default",
										"bh_default_center",
										"bh_default_open",
										"bh_default_close",
										"bh_default_content"
									],
									"syntax": "Packages/C++/C++.sublime-syntax",
									"translate_tabs_to_spaces": false
								},
								"translation.x": 0.0,
								"translation.y": 4255.0,
								"zoom_level": 1.0
							},
							"stack_index": 2,
							"type": "text"
						},
						{
							"buffer": 3,
							"file": "sy.src/sy.hmi/rttask/inc/event.h",
							"semi_transient": false,
							"settings":
							{
								"buffer_size": 10488,
								"regions":
								{
								},
								"selection":
								[
									[
										782,
										782
									]
								],
								"settings":
								{
									"bracket_highlighter.busy": false,
									"bracket_highlighter.locations":
									{
										"close":
										{
											"1":
											[
												1148,
												1149
											]
										},
										"icon":
										{
											"1":
											[
												"Packages/BracketHighlighter/icons/curly_bracket.png",
												"brackethighlighter.default"
											]
										},
										"open":
										{
											"1":
											[
												695,
												696
											]
										},
										"unmatched":
										{
										}
									},
									"bracket_highlighter.regions":
									[
										"bh_c_define",
										"bh_c_define_center",
										"bh_c_define_open",
										"bh_c_define_close",
										"bh_c_define_content",
										"bh_curly",
										"bh_curly_center",
										"bh_curly_open",
										"bh_curly_close",
										"bh_curly_content",
										"bh_double_quote",
										"bh_double_quote_center",
										"bh_double_quote_open",
										"bh_double_quote_close",
										"bh_double_quote_content",
										"bh_tag",
										"bh_tag_center",
										"bh_tag_open",
										"bh_tag_close",
										"bh_tag_content",
										"bh_angle",
										"bh_angle_center",
										"bh_angle_open",
										"bh_angle_close",
										"bh_angle_content",
										"bh_round",
										"bh_round_center",
										"bh_round_open",
										"bh_round_close",
										"bh_round_content",
										"bh_single_quote",
										"bh_single_quote_center",
										"bh_single_quote_open",
										"bh_single_quote_close",
										"bh_single_quote_content",
										"bh_unmatched",
										"bh_unmatched_center",
										"bh_unmatched_open",
										"bh_unmatched_close",
										"bh_unmatched_content",
										"bh_square",
										"bh_square_center",
										"bh_square_open",
										"bh_square_close",
										"bh_square_content",
										"bh_regex",
										"bh_regex_center",
										"bh_regex_open",
										"bh_regex_close",
										"bh_regex_content",
										"bh_default",
										"bh_default_center",
										"bh_default_open",
										"bh_default_close",
										"bh_default_content"
									],
									"in_converting": true,
									"origin_encoding": "GB2312",
									"syntax": "Packages/C++/C++.sublime-syntax",
									"translate_tabs_to_spaces": false
								},
								"translation.x": 0.0,
								"translation.y": 735.0,
								"zoom_level": 1.0
							},
							"stack_index": 5,
							"type": "text"
						},
						{
							"buffer": 4,
							"file": "sy.src/sy.hmi/Makefile",
							"semi_transient": false,
							"settings":
							{
								"buffer_size": 1925,
								"regions":
								{
								},
								"selection":
								[
									[
										1140,
										1140
									]
								],
								"settings":
								{
									"bracket_highlighter.busy": false,
									"bracket_highlighter.locations":
									{
										"close":
										{
										},
										"icon":
										{
										},
										"open":
										{
										},
										"unmatched":
										{
										}
									},
									"bracket_highlighter.regions":
									[
										"bh_c_define",
										"bh_c_define_center",
										"bh_c_define_open",
										"bh_c_define_close",
										"bh_c_define_content",
										"bh_curly",
										"bh_curly_center",
										"bh_curly_open",
										"bh_curly_close",
										"bh_curly_content",
										"bh_double_quote",
										"bh_double_quote_center",
										"bh_double_quote_open",
										"bh_double_quote_close",
										"bh_double_quote_content",
										"bh_tag",
										"bh_tag_center",
										"bh_tag_open",
										"bh_tag_close",
										"bh_tag_content",
										"bh_angle",
										"bh_angle_center",
										"bh_angle_open",
										"bh_angle_close",
										"bh_angle_content",
										"bh_round",
										"bh_round_center",
										"bh_round_open",
										"bh_round_close",
										"bh_round_content",
										"bh_single_quote",
										"bh_single_quote_center",
										"bh_single_quote_open",
										"bh_single_quote_close",
										"bh_single_quote_content",
										"bh_unmatched",
										"bh_unmatched_center",
										"bh_unmatched_open",
										"bh_unmatched_close",
										"bh_unmatched_content",
										"bh_square",
										"bh_square_center",
										"bh_square_open",
										"bh_square_close",
										"bh_square_content",
										"bh_regex",
										"bh_regex_center",
										"bh_regex_open",
										"bh_regex_close",
										"bh_regex_content",
										"bh_default",
										"bh_default_center",
										"bh_default_open",
										"bh_default_close",
										"bh_default_content"
									],
									"syntax": "Packages/Makefile/Makefile.sublime-syntax"
								},
								"translation.x": 0.0,
								"translation.y": 375.0,
								"zoom_level": 1.0
							},
							"stack_index": 1,
							"type": "text"
						},
						{
							"buffer": 5,
							"file": "sy.src/vxworks.mk",
							"semi_transient": false,
							"settings":
							{
								"buffer_size": 2319,
								"regions":
								{
								},
								"selection":
								[
									[
										1976,
										1976
									]
								],
								"settings":
								{
									"bracket_highlighter.busy": false,
									"bracket_highlighter.locations":
									{
										"close":
										{
										},
										"icon":
										{
										},
										"open":
										{
										},
										"unmatched":
										{
										}
									},
									"bracket_highlighter.regions":
									[
										"bh_c_define",
										"bh_c_define_center",
										"bh_c_define_open",
										"bh_c_define_close",
										"bh_c_define_content",
										"bh_curly",
										"bh_curly_center",
										"bh_curly_open",
										"bh_curly_close",
										"bh_curly_content",
										"bh_double_quote",
										"bh_double_quote_center",
										"bh_double_quote_open",
										"bh_double_quote_close",
										"bh_double_quote_content",
										"bh_tag",
										"bh_tag_center",
										"bh_tag_open",
										"bh_tag_close",
										"bh_tag_content",
										"bh_angle",
										"bh_angle_center",
										"bh_angle_open",
										"bh_angle_close",
										"bh_angle_content",
										"bh_round",
										"bh_round_center",
										"bh_round_open",
										"bh_round_close",
										"bh_round_content",
										"bh_single_quote",
										"bh_single_quote_center",
										"bh_single_quote_open",
										"bh_single_quote_close",
										"bh_single_quote_content",
										"bh_unmatched",
										"bh_unmatched_center",
										"bh_unmatched_open",
										"bh_unmatched_close",
										"bh_unmatched_content",
										"bh_square",
										"bh_square_center",
										"bh_square_open",
										"bh_square_close",
										"bh_square_content",
										"bh_regex",
										"bh_regex_center",
										"bh_regex_open",
										"bh_regex_close",
										"bh_regex_content",
										"bh_default",
										"bh_default_center",
										"bh_default_open",
										"bh_default_close",
										"bh_default_content"
									],
									"origin_encoding": "ASCII",
									"syntax": "Packages/Makefile/Makefile.sublime-syntax"
								},
								"translation.x": 0.0,
								"translation.y": 1200.0,
								"zoom_level": 1.0
							},
							"stack_index": 3,
							"type": "text"
						},
						{
							"buffer": 6,
							"file": "sy.src/sy.sys/system/src/canovt.c",
							"semi_transient": false,
							"settings":
							{
								"buffer_size": 10879,
								"regions":
								{
								},
								"selection":
								[
									[
										10003,
										10003
									]
								],
								"settings":
								{
									"bracket_highlighter.busy": false,
									"bracket_highlighter.locations":
									{
										"close":
										{
											"1":
											[
												10599,
												10600
											]
										},
										"icon":
										{
											"1":
											[
												"Packages/BracketHighlighter/icons/curly_bracket.png",
												"brackethighlighter.default"
											]
										},
										"open":
										{
											"1":
											[
												9977,
												9978
											]
										},
										"unmatched":
										{
										}
									},
									"bracket_highlighter.regions":
									[
										"bh_c_define",
										"bh_c_define_center",
										"bh_c_define_open",
										"bh_c_define_close",
										"bh_c_define_content",
										"bh_curly",
										"bh_curly_center",
										"bh_curly_open",
										"bh_curly_close",
										"bh_curly_content",
										"bh_double_quote",
										"bh_double_quote_center",
										"bh_double_quote_open",
										"bh_double_quote_close",
										"bh_double_quote_content",
										"bh_tag",
										"bh_tag_center",
										"bh_tag_open",
										"bh_tag_close",
										"bh_tag_content",
										"bh_angle",
										"bh_angle_center",
										"bh_angle_open",
										"bh_angle_close",
										"bh_angle_content",
										"bh_round",
										"bh_round_center",
										"bh_round_open",
										"bh_round_close",
										"bh_round_content",
										"bh_single_quote",
										"bh_single_quote_center",
										"bh_single_quote_open",
										"bh_single_quote_close",
										"bh_single_quote_content",
										"bh_unmatched",
										"bh_unmatched_center",
										"bh_unmatched_open",
										"bh_unmatched_close",
										"bh_unmatched_content",
										"bh_square",
										"bh_square_center",
										"bh_square_open",
										"bh_square_close",
										"bh_square_content",
										"bh_regex",
										"bh_regex_center",
										"bh_regex_open",
										"bh_regex_close",
										"bh_regex_content",
										"bh_default",
										"bh_default_center",
										"bh_default_open",
										"bh_default_close",
										"bh_default_content"
									],
									"in_converting": true,
									"origin_encoding": "GB2312",
									"syntax": "Packages/C++/C.sublime-syntax",
									"translate_tabs_to_spaces": false
								},
								"translation.x": 0.0,
								"translation.y": 10440.0,
								"zoom_level": 1.0
							},
							"stack_index": 6,
							"type": "text"
						},
						{
							"buffer": 7,
							"file": "sy.src/sy.hmi/lcd/src/lcdreport.c",
							"semi_transient": false,
							"settings":
							{
								"buffer_size": 34160,
								"regions":
								{
								},
								"selection":
								[
									[
										0,
										0
									]
								],
								"settings":
								{
									"bracket_highlighter.busy": false,
									"bracket_highlighter.locations":
									{
										"close":
										{
										},
										"icon":
										{
										},
										"open":
										{
										},
										"unmatched":
										{
										}
									},
									"bracket_highlighter.regions":
									[
										"bh_c_define",
										"bh_c_define_center",
										"bh_c_define_open",
										"bh_c_define_close",
										"bh_c_define_content",
										"bh_curly",
										"bh_curly_center",
										"bh_curly_open",
										"bh_curly_close",
										"bh_curly_content",
										"bh_double_quote",
										"bh_double_quote_center",
										"bh_double_quote_open",
										"bh_double_quote_close",
										"bh_double_quote_content",
										"bh_tag",
										"bh_tag_center",
										"bh_tag_open",
										"bh_tag_close",
										"bh_tag_content",
										"bh_angle",
										"bh_angle_center",
										"bh_angle_open",
										"bh_angle_close",
										"bh_angle_content",
										"bh_round",
										"bh_round_center",
										"bh_round_open",
										"bh_round_close",
										"bh_round_content",
										"bh_single_quote",
										"bh_single_quote_center",
										"bh_single_quote_open",
										"bh_single_quote_close",
										"bh_single_quote_content",
										"bh_unmatched",
										"bh_unmatched_center",
										"bh_unmatched_open",
										"bh_unmatched_close",
										"bh_unmatched_content",
										"bh_square",
										"bh_square_center",
										"bh_square_open",
										"bh_square_close",
										"bh_square_content",
										"bh_regex",
										"bh_regex_center",
										"bh_regex_open",
										"bh_regex_close",
										"bh_regex_content",
										"bh_default",
										"bh_default_center",
										"bh_default_open",
										"bh_default_close",
										"bh_default_content"
									],
									"in_converting": true,
									"origin_encoding": "GB2312",
									"syntax": "Packages/C++/C.sublime-syntax",
									"translate_tabs_to_spaces": false
								},
								"translation.x": -0.0,
								"translation.y": 25920.0,
								"zoom_level": 1.0
							},
							"stack_index": 7,
							"type": "text"
						}
					]
				}
			],
			"incremental_find":
			{
				"height": 30.0
			},
			"input":
			{
				"height": 36.0
			},
			"layout":
			{
				"cells":
				[
					[
						0,
						0,
						1,
						1
					]
				],
				"cols":
				[
					0.0,
					1.0
				],
				"rows":
				[
					0.0,
					1.0
				]
			},
			"menu_visible": true,
			"output.exec":
			{
				"height": 30.0
			},
			"output.find_results":
			{
				"height": 0.0
			},
			"pinned_build_system": "Packages/D/D.sublime-build",
			"position": "0,2,3,-32000,-32000,-1,-1,768,125,62,892",
			"project": "U21.sublime-project",
			"replace":
			{
				"height": 66.0
			},
			"save_all_on_build": true,
			"select_file":
			{
				"height": 0.0,
				"last_filter": "",
				"selected_items":
				[
					[
						"",
						"sy.release\\sy.sys\\common.gnu\\inc\\cmd_confdefs.h"
					]
				],
				"width": 0.0
			},
			"select_project":
			{
				"height": 500.0,
				"last_filter": "",
				"selected_items":
				[
					[
						"",
						"D:\\workspace\\Distribution_Network\\distribution_network.sublime-project"
					]
				],
				"width": 380.0
			},
			"select_symbol":
			{
				"height": 392.0,
				"last_filter": "",
				"selected_items":
				[
				],
				"width": 520.0
			},
			"selected_group": 0,
			"settings":
			{
			},
			"show_minimap": true,
			"show_open_files": false,
			"show_tabs": true,
			"side_bar_visible": true,
			"side_bar_width": 243.0,
			"status_bar_visible": true,
			"template_settings":
			{
			},
			"window_id": 38,
			"workspace_name": "/D/workspace/U21/U21.sublime-workspace"
		}
	],
	"workspaces":
	{
		"recent_workspaces":
		[
			"/D/workspace/U21/U21.sublime-workspace",
			"/D/workspace/Distribution_Network/distribution_network.sublime-workspace",
			"/D/workspace/U21_6IN1/U21_6t1.sublime-workspace",
			"/D/workspace/U22/U22.sublime-workspace",
			"/D/workspace/BSPU21/BSP.sublime-workspace",
			"/D/workspace/U21_4t1/U21_4t1.sublime-workspace",
			"/D/workspace/U22_6IN1/U22_6IN1.sublime-workspace",
			"/D/workspace/4U/4U.sublime-workspace",
			"/E/apprentice/eclipse/algorithm.sublime-workspace"
		]
	}
}
