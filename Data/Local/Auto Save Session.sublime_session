{
	"folder_history":
	[
		"/D/workspace/4U/sy.src/sy.hmi/rttask",
		"/D/workspace/4U/sy.src/sy.hmi/lcd",
		"/D/workspace/Distribution_Network",
		"/E/apprentice/eclipse/algs4",
		"/D/workspace/BSPU21",
		"/D/workspace/4U"
	],
	"last_version": 3126,
	"last_window_id": 45,
	"log_indexing": false,
	"settings":
	{
		"new_window_height": 648.0,
		"new_window_settings":
		{
			"auto_complete":
			{
				"selected_items":
				[
					[
						"__",
						"__LINE__"
					],
					[
						"sntp_se",
						"sntp_server_sockaddr"
					],
					[
						"in",
						"inside"
					],
					[
						"ou",
						"out_center"
					],
					[
						"out",
						"out_center"
					],
					[
						"re",
						"return\t(can.c)"
					],
					[
						"lv",
						"lv2_cnt"
					],
					[
						"sy",
						"syncSrc[32"
					],
					[
						"E",
						"EXTERN"
					],
					[
						"syn",
						"sync_table"
					],
					[
						"reg",
						"regLv3SyncFunc"
					],
					[
						"_",
						"__LINE__"
					],
					[
						"sync",
						"syncSrc"
					],
					[
						"V",
						"VAR_SYNC_MAX"
					],
					[
						"IN",
						"INT32"
					],
					[
						"all",
						"allcated"
					],
					[
						"s",
						"sync_table"
					],
					[
						"sys",
						"sys_regSynVar"
					],
					[
						"BO",
						"BOARD_TYPE==SY2102"
					],
					[
						"G",
						"GetGpVarSync\t(meaVarSync.h)"
					],
					[
						"gp",
						"gp_vars_sync"
					],
					[
						"I",
						"INT32\t(slave.c)"
					],
					[
						"de",
						"desc"
					],
					[
						"do",
						"dont_need_reg"
					],
					[
						"rttas",
						"rttaskAppInit2"
					],
					[
						"res",
						"result"
					],
					[
						"succ",
						"successful"
					],
					[
						"tmp",
						"tmp_time_src_mode"
					],
					[
						"time_src_",
						"time_src_ok_mask"
					],
					[
						"wait",
						"waiting"
					],
					[
						"new",
						"newSync"
					],
					[
						"INT",
						"INT32"
					],
					[
						"rttaskA",
						"rttaskAppInit1"
					],
					[
						"can",
						"can_no"
					],
					[
						"func",
						"function"
					],
					[
						"h",
						"hbus"
					],
					[
						"SYS",
						"SYS_ROOT_DIR"
					],
					[
						"printEventInitStateI",
						"printEventInitStateItem"
					],
					[
						"tran",
						"tran_val"
					],
					[
						"time",
						"time_us"
					],
					[
						"ti",
						"time_us"
					],
					[
						"UNIT",
						"UINT32"
					],
					[
						"wr",
						"writing_flag"
					],
					[
						"w",
						"writing_cnt"
					],
					[
						"0x",
						"0xffffff"
					],
					[
						"rec",
						"recv_proc_len"
					],
					[
						"p",
						"p_gin"
					],
					[
						"gen",
						"gen_entry_num"
					],
					[
						"getGen",
						"getGenGrpByGrpNo"
					],
					[
						"U",
						"UINT32"
					],
					[
						"f",
						"f_value"
					],
					[
						"u",
						"u_value"
					],
					[
						"by",
						"byte_num"
					],
					[
						"da",
						"datafield"
					],
					[
						"sett",
						"setting_grp_no"
					],
					[
						"sys_",
						"sys_grp_no"
					],
					[
						"grp",
						"grp_no"
					],
					[
						"gin",
						"gin_entry"
					],
					[
						"local_s",
						"local_set_value"
					],
					[
						"start",
						"start_sec_index"
					],
					[
						"op",
						"lcdOpWireDiagram"
					],
					[
						"show",
						"show_sec_num"
					],
					[
						"Print",
						"PrintLangDesc"
					],
					[
						"trans",
						"s_print_translate_array"
					],
					[
						"print_",
						"print_item_num"
					],
					[
						"se",
						"section_index"
					],
					[
						"sub",
						"sub_grp_num"
					],
					[
						"it",
						"item_num"
					],
					[
						"gr",
						"grp_index"
					],
					[
						"led",
						"led_cmd"
					],
					[
						"si",
						"signal_num"
					],
					[
						"C",
						"CALC"
					],
					[
						"init",
						"initLcdStep1"
					],
					[
						"sec",
						"sec_num"
					],
					[
						"g_",
						"g_lcd_timer_task"
					],
					[
						"fir",
						"first_sec"
					],
					[
						"g",
						"graph_page"
					],
					[
						"DBG",
						"LCD_DEBUG_MSG"
					],
					[
						"WI",
						"LCD_WIRE_DIAGRAM_DEBUG"
					],
					[
						"tm",
						"tmp_child"
					],
					[
						"p_",
						"p_section"
					],
					[
						"W",
						"LCD_WIRE_DIAGRAM_DEBUG"
					],
					[
						"LCD_WI",
						"LCD_WIRE_DIAGRAM_DEBUG"
					],
					[
						"row",
						"row_num"
					],
					[
						"L",
						"LCD_MAX_FACTOR"
					],
					[
						"n",
						"nfactor"
					],
					[
						"b",
						"buffer"
					],
					[
						"B",
						"BUFFER_SIZE"
					],
					[
						"fac",
						"factorOut"
					],
					[
						"f_f",
						"f_factor"
					],
					[
						"f_",
						"f_coeff"
					],
					[
						"sour",
						"source1"
					],
					[
						"print",
						"printf\tprintf …"
					],
					[
						"buf",
						"buffer"
					],
					[
						"fa",
						"factorOut"
					],
					[
						"l",
						"lcd_temp"
					],
					[
						"LCD_MAX",
						"LCD_MAX_FACTOR_ADJUST"
					],
					[
						"factor",
						"factor_temp"
					],
					[
						"cr",
						"crc_ini"
					],
					[
						"crc",
						"crc_ini"
					],
					[
						"c",
						"crc"
					],
					[
						"a",
						"accoeff"
					],
					[
						"S",
						"Section_Name"
					],
					[
						"section",
						"Section_Name"
					],
					[
						"K",
						"Key_Name"
					],
					[
						"st",
						"strcat"
					],
					[
						"d",
						"d_ptr"
					],
					[
						"max",
						"max_all"
					],
					[
						"arr",
						"arr1"
					],
					[
						"str",
						"strlen"
					],
					[
						"va",
						"value"
					],
					[
						"r",
						"right"
					],
					[
						"al",
						"allocbuf"
					],
					[
						"ma",
						"maxlines"
					],
					[
						"t",
						"t_tail"
					],
					[
						"M",
						"MAXLINE"
					],
					[
						"bu",
						"buf_sign"
					],
					[
						"get",
						"getchar"
					],
					[
						"m",
						"MAXLINE　100"
					],
					[
						"mask",
						"mask_x"
					],
					[
						"i",
						"inc\t#include \"…\""
					],
					[
						"inc",
						"include"
					],
					[
						"he",
						"hexa"
					],
					[
						"H",
						"HEAD1"
					],
					[
						"ele",
						"ele_src"
					],
					[
						"ds",
						"dst"
					],
					[
						"res_b",
						"res_b"
					],
					[
						"D",
						"Distance_a"
					]
				]
			},
			"build_system_choices":
			[
			],
			"build_varint": "",
			"command_palette":
			{
				"height": 392.0,
				"last_filter": "syntaxc",
				"selected_items":
				[
					[
						"syntaxc",
						"Set Syntax: C"
					],
					[
						"Cscope: ",
						"Cscope: Look up functions calling this function"
					],
					[
						"syntax:pl",
						"Set Syntax: Plain Text"
					],
					[
						"insta",
						"Package Control: Install Package"
					],
					[
						"syntax:c",
						"Set Syntax: C"
					],
					[
						"sy",
						"Set Syntax: C"
					],
					[
						"Package Control: ",
						"Package Control: Install Package"
					],
					[
						"install",
						"Package Control: Install Package"
					],
					[
						"set syntax:c",
						"Set Syntax: C"
					],
					[
						"ins",
						"Package Control: Install Package"
					],
					[
						"x",
						"Set Syntax: XML"
					],
					[
						"make",
						"Set Syntax: Makefile"
					],
					[
						"syntax:make",
						"Set Syntax: Makefile"
					],
					[
						"Package Control: install ",
						"Package Control: Install Package"
					],
					[
						"Package Control: install c",
						"Package Control: Install Package"
					],
					[
						":w",
						":w - Save"
					]
				],
				"width": 528.0
			},
			"console":
			{
				"height": 146.0,
				"history":
				[
					"install package",
					"import urllib.request,os; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ','%20')).read())"
				]
			},
			"distraction_free":
			{
				"menu_visible": true,
				"show_minimap": false,
				"show_open_files": false,
				"show_tabs": false,
				"side_bar_visible": false,
				"status_bar_visible": false
			},
			"file_history":
			[
				"/D/version history/U21/readme.md",
				"/D/workspace/Distribution_Network/sy.src/sy.hmi/rttask/inc/sysntp.h",
				"/D/workspace/Distribution_Network/sy.release/sy.sys/common.k64/inc/rtcs/rtcs_sock.h",
				"/D/workspace/Distribution_Network/sy.src/vxworks.mk",
				"/D/workspace/Distribution_Network/sy.src/sy.slave/sy2101/Makefile",
				"/C/WindRiver/vxworks-6.4/target/usr/src/util/fioLib.c",
				"/D/workspace/Distribution_Network/sy.src/sy.hmi/Makefile",
				"/D/workspace/Distribution_Network/sy.src/sy.slave/sy2101/app/Makefile",
				"/D/workspace/Distribution_Network/sy.release/sy.sys/sy2101/inc/mm.h",
				"/D/workspace/Distribution_Network/sy.src/sy.slave/system/Makefile",
				"/D/workspace/Distribution_Network/sy.src/sy.master/Makefile",
				"/D/workspace/Distribution_Network/sy.src/sy.slave/Makefile",
				"/D/workspace/U21/sy.src/sy.hmi/Makefile",
				"/D/4开发环境/sh.exe",
				"/D/workspace/4U/sy.src/sy.hmi/Makefile",
				"/D/workspace/Distribution_Network/sy.src/sy.master/src/master.c",
				"/D/workspace/Distribution_Network/sy.src/sy.master/src/msurv.c",
				"/D/workspace/Distribution_Network/sy.src/sy.master/src/dbgvar.cpp",
				"/D/workspace/Distribution_Network/sy.src/sy.master/src/dwload.c",
				"/D/workspace/Distribution_Network/sy.src/sy.master/src/dev.cpp",
				"/D/workspace/Distribution_Network/sy.src/sy.master/src/para.cpp",
				"/D/workspace/Distribution_Network/sy.release/sy.sys/sy2101/inc/sy2101.h",
				"/D/workspace/4U/sy.src/vxworks.mk",
				"/D/workspace/Distribution_Network/sy.src/sy.slave/system/src/can.c",
				"/D/3.platform resource/就地化/sy.release/sy.release/sy.sys/system/inc/bcomponent.h",
				"/D/workspace/Distribution_Network/sy.src/sy.master/src/sigivt.c",
				"/D/workspace/U21/sy.src/sy.hmi/lcd/Makefile",
				"/D/workspace/U21/sy.src/vxworks.mk",
				"/D/SVN/U21/sy.release/sy.sys/system/inc/bcomponent.h",
				"/E/apprentice/Computer/C programming/diamond.c",
				"/D/workspace/Distribution_Network/sy.src/sy.slave/system/src/slave.c",
				"/D/workspace/Distribution_Network/sy.src/sy.master/src/mcan.c",
				"/D/workspace/Distribution_Network/sy.src/sy.master/src/sigovt.c",
				"/D/5.Real/Zeitest/Distribution/platform/config.xml",
				"/D/5.Real/Zeitest/Distribution/platform/report.txt",
				"/D/workspace/Distribution_Network/sy.release/sy.sys/common.gnu/inc/linux/types.h",
				"/D/workspace/Distribution_Network/sy.src/sy.slave/sy2102/app/src/appinit.c",
				"/D/SVN/Distribution_Network/sy.src/sy.slave/sy2102/sys/src/tmrisr.c",
				"/D/SVN/U21_6tong1/sy.release/sy.sys/sy6101/exe/sysdict.xml",
				"/D/SVN/U22_6T1/sy.release/sy.sys/sy1101/exe/sysdict.xml",
				"/D/workspace/Distribution_Network/sy.src/sy.master/src/utf8.c",
				"/D/workspace/Distribution_Network/sy.src/sy.slave/system/src/slave.c.mine",
				"/D/SVN/Distribution_Network/sy.src/sy.slave/system/src/ctrl.c",
				"/D/SVN/Distribution_Network/sy.src/sy.slave/system/src/canovt.c",
				"/D/SVN/Distribution_Network/sy.src/sy.slave/system/src/canivt.c",
				"/D/SVN/Distribution_Network/sy.src/sy.slave/system/src/can.c",
				"/D/SVN/Distribution_Network/sy.src/sy.slave/system/src/debug.c",
				"/D/SVN/Distribution_Network/sy.src/sy.slave/system/src/dwupload.c",
				"/D/SVN/Distribution_Network/sy.src/sy.slave/system/src/hbus.c",
				"/D/SVN/Distribution_Network/sy.src/sy.slave/system/src/hbusivt.c",
				"/D/SVN/Distribution_Network/sy.src/sy.slave/system/src/hbusovt.c",
				"/D/SVN/Distribution_Network/sy.src/sy.slave/system/src/ivt.c",
				"/D/SVN/Distribution_Network/sy.src/sy.slave/system/src/linkcan.c",
				"/D/SVN/Distribution_Network/sy.src/sy.slave/system/src/locivt.c",
				"/D/SVN/Distribution_Network/sy.src/sy.slave/system/src/measVarSync.c",
				"/D/SVN/Distribution_Network/sy.src/sy.slave/system/src/ovt.c",
				"/D/SVN/Distribution_Network/sy.src/sy.slave/system/src/parameter.c",
				"/D/SVN/Distribution_Network/sy.src/sy.slave/system/src/regsignal.c",
				"/D/SVN/Distribution_Network/sy.src/sy.slave/system/src/slave.c",
				"/D/SVN/Distribution_Network/sy.src/sy.slave/system/src/surv.c",
				"/D/SVN/Distribution_Network/sy.src/sy.slave/system/src/sync.c",
				"/D/SVN/Distribution_Network/sy.src/sy.slave/system/src/taskque.c",
				"/D/workspace/Distribution_Network/sy.src/sy.slave/system/src/measVarSync.c",
				"/D/workspace/Distribution_Network/sy.src/sy.slave/system/src/taskque.c",
				"/D/workspace/Distribution_Network/sy.src/sy.slave/system/inc/linkcan.h",
				"/C/Users/wangzhichao/Desktop/shr/config.xml",
				"/D/5.Real/Zeitest/Distribution/app/17.1.16/config.xml",
				"/D/5.Real/Zeitest/Distribution/app/17.1.16/appinit.c",
				"/D/5.Real/Zeitest/Distribution/app/17.1.13/config.xml",
				"/D/workspace/Distribution_Network/sy.release/sy.sys/system/inc/meaVarSync.h",
				"/D/workspace/Distribution_Network/sy.src/sy.slave/system/src/canovt.c",
				"/D/workspace/Distribution_Network/sy.src/sy.slave/system/inc/syslave.h",
				"/D/workspace/Distribution_Network/sy.src/sy.slave/system/inc/meaVarSync.h",
				"/D/workspace/Distribution_Network/sy.release/sy.sys/system/inc/syslave.h",
				"/D/workspace/Distribution_Network/sy.src/sy.slave/system/src/sync.c",
				"/D/workspace/Distribution_Network/sy.release/sy.sys/sy2102/inc/board.h",
				"/D/workspace/Distribution_Network/sy.src/sy.hmi/lcd/inc/lcdbase.h",
				"/D/workspace/Distribution_Network/sy.src/sy.hmi/lcd/inc/lcd.h",
				"/D/workspace/Distribution_Network/sy.src/sy.hmi/lcd/src/lcd.c",
				"/D/workspace/Distribution_Network/sy.src/sy.hmi/lcd/src/lcdnews.c",
				"/D/workspace/Distribution_Network/sy.release/sy.sys/sy2101/inc/master.h",
				"/D/workspace/Distribution_Network/sy.src/sy.hmi/rttask/src/rttask.c",
				"/D/5.Real/Zeitest/U21 LMT/UDC-311AG_160928_Ver1.10B2/extr_UDL-531A-G-Z_SH_Ver1.12B1_2016-12-02_11-37-38/10/config.xml",
				"/D/5.Real/Zeitest/Distribution/config.xml",
				"/D/5.Real/Zeitest/Distribution/app/config.xml",
				"/C/Users/wangzhichao/Desktop/startcan.txt",
				"/D/workspace/Distribution_Network/sy.release/sy.sys/system/inc/msgtype.h",
				"/D/workspace/Distribution_Network/sy.release/sy.sys/system/inc/ovt.h",
				"/D/workspace/Distribution_Network/sy.src/sy.slave/system/src/linkcan.c",
				"/D/workspace/Distribution_Network/sy.release/sy.sys/common.k64/link/readme.txt",
				"/D/workspace/Distribution_Network/sy.src/sy.slave/system/src/parameter.c",
				"/D/workspace/Distribution_Network/sy.src/sy.slave/system/src/ovt.c",
				"/D/workspace/Distribution_Network/sy.release/sy.sys/sy2101/inc/dev.h",
				"/D/workspace/Distribution_Network/sy.src/sy.slave/system/inc/hbus.h",
				"/D/version history/Distribution_Network/readme.md",
				"/D/workspace/Distribution_Network/sy.src/sy.slave/sy2102/sys/src/hbusisr.c",
				"/D/workspace/Distribution_Network/sy.src/sy.slave/sy2102/sys/src/sy2102.c",
				"/D/workspace/Distribution_Network/sy.src/sy.slave/system/inc/msgtype.h",
				"/D/workspace/Distribution_Network/sy.release/sy.sys/system/inc/taskque.h",
				"/D/workspace/Distribution_Network/sy.src/sy.hmi/rttask/src/sysntp.c",
				"/D/workspace/Distribution_Network/sy.src/sy.hmi/lcd/inc/lcdaccoeff.h",
				"/D/workspace/Distribution_Network/sy.src/sy.sys/system/Makefile",
				"/D/workspace/Distribution_Network/sy.src/sy.sys/Makefile",
				"/D/workspace/Distribution_Network/sy.src/sy.sys/system/src/can.c",
				"/D/workspace/Distribution_Network/sy.src/sy.sys/system/src/parameter.c",
				"/D/workspace/Distribution_Network/sy.src/sy.sys/system/src/slave.c",
				"/D/workspace/Distribution_Network/sy.src/sy.slave/common.k64/inc/bsp/bsp.h",
				"/D/workspace/Distribution_Network/sy.release/sy.sys/common.k64/inc/bsp/bsp.h",
				"/D/workspace/Distribution_Network/sy.src/sy.sys/system/src/salve.c",
				"/D/3.platform resource/邱大为版本程序/distrubution_system/wzc_new/wzc/sy.src/sy.sys/sy2101/Makefile",
				"/D/3.platform resource/邱大为版本程序/distrubution_system/wzc_new/wzc/sy.src/Makefile",
				"/D/3.platform resource/邱大为版本程序/distrubution_system/wzc_new/wzc/sy.src/sy.sys/Makefile",
				"/D/3.platform resource/邱大为版本程序/distrubution_system/wzc_new/wzc/sy.src/vxworks.mk",
				"/D/3.platform resource/邱大为版本程序/distrubution_system/wzc_new/wzc/sy.src/sy.sys/system/Makefile",
				"/D/workspace/Distribution_Network/sy.src/sy.slave/sy2102/sys/src/kenetisop.c",
				"/D/workspace/Distribution_Network/sy.src/sy.slave/system/src/debug.c",
				"/D/workspace/Distribution_Network/sy.src/sy.sys/system/src/debug.c",
				"/D/workspace/U21/sy.src/sy.sys/system/makeall",
				"/D/workspace/Distribution_Network/sy.release/sy.sys/sy2102/inc/sy2102.h",
				"/D/workspace/Distribution_Network/sy.src/sy.slave/common.k64/src/shell/source/mfs/sh_copy.c",
				"/D/workspace/Distribution_Network/sy.src/sy.slave/common.k64/inc/Mk64fn.h",
				"/D/workspace/Distribution_Network/sy.src/sy.slave/system/inc/ctrl.h",
				"/D/workspace/Distribution_Network/sy.src/sy.slave/system/src/regsignal.c",
				"/D/workspace/Distribution_Network/sy.src/sy.slave/system/src/locivt.c",
				"/D/workspace/Distribution_Network/sy.src/sy.slave/system/src/dwupload.c",
				"/D/workspace/Distribution_Network/sy.src/sy.slave/system/src/ctrl.c",
				"/D/workspace/Distribution_Network/sy.src/sy.slave/system/src/ivt.c",
				"/D/workspace/Distribution_Network/sy.src/sy.slave/system/src/hbusovt.c"
			],
			"find":
			{
				"height": 36.0
			},
			"find_in_files":
			{
				"height": 90.0,
				"where_history":
				[
					"D:\\workspace\\Distribution_Network\\sy.src",
					"D:\\workspace\\Distribution_Network\\sy.src\\sy.master",
					"D:\\workspace\\Distribution_Network\\sy.src\\sy.slave",
					"D:\\workspace\\Distribution_Network\\sy.src\\sy.master",
					"D:\\workspace\\Distribution_Network\\sy.src\\sy.slave\\system",
					"D:\\workspace\\Distribution_Network\\sy.src\\sy.slave",
					"D:\\workspace\\Distribution_Network",
					"D:\\workspace\\Distribution_Network\\sy.src\\sy.slave\\system",
					"D:\\workspace\\Distribution_Network",
					"D:\\workspace\\Distribution_Network\\sy.src\\sy.slave",
					"D:\\workspace\\Distribution_Network\\sy.src",
					"D:\\workspace\\U22_6IN1\\sy.src\\sy.hmi\\rttask",
					"D:\\workspace\\U22_6IN1\\sy.src",
					"D:\\workspace\\U22_6IN1\\sy.src\\sy.hmi\\lcd",
					"D:\\workspace\\U22_6IN1",
					"D:\\workspace\\Localization\\sy.src\\sy.hmi\\iec103",
					"D:\\workspace\\Localization",
					"D:\\workspace\\Localization\\sy.src",
					"D:\\workspace\\Localization",
					"D:\\workspace\\Localization\\sy.src\\sy.hmi\\lcd",
					"D:\\workspace\\Localization",
					"D:\\workspace\\Localization\\sy.release\\sy.sys\\sy6101L\\lib",
					"D:\\workspace\\Localization",
					"D:\\workspace\\Localization\\sy.src\\sy.hmi\\lcd",
					"D:\\workspace\\Localization\\sy.src",
					"D:\\workspace\\Localization",
					"D:\\workspace\\Localization\\sy.src\\sy.hmi\\lcd",
					"D:\\workspace\\U21_4t1\\sy.src",
					"D:\\workspace\\U21_4t1\\sy.src\\sy.hmi\\lcd",
					"D:\\workspace\\U21_4t1\\sy.src\\sy.hmi\\lcd\\src",
					"D:\\workspace\\U21_4t1\\sy.src",
					"D:\\workspace\\U21_4t1",
					"D:\\workspace\\U21_4t1\\sy.src\\sy.hmi\\lcd",
					"D:\\workspace\\U21_4t1\\sy.src\\sy.hmi\\lcd\\src",
					"D:\\3.platform resource\\5试验fpk\\UDC-311AG_Ver1.19",
					"D:\\3.platform resource\\赵小伟版本程序\\u21 工程\\iec103",
					"D:\\workspace,D:\\3.platform resource\\赵小伟版本程序,D:\\3.platform resource\\邱大为版本程序",
					"D:\\workspace,D:\\3.platform resource\\赵小伟版本程序",
					"D:\\workspace\\U21_6IN1",
					"C:\\Users\\wangzhichao\\Desktop\\代码改动",
					"D:\\workspace\\U21_6IN1"
				]
			},
			"find_state":
			{
				"case_sensitive": false,
				"find_history":
				[
					"stratum",
					"initSntpTimer",
					"printbufStd",
					"initSlaves failed",
					"B05.BISmpl.bi_in05",
					"CanIvt",
					"return",
					"error",
					"initTmr",
					"PRINT",
					"regLv3SyncFunc",
					"runSyncVar",
					"regLv3SyncFunc",
					"cnt",
					"growstepbystep",
					"B05.Vol.fourier_ua",
					"B05",
					"growstepbystep",
					"1",
					"regLv3SyncFunc",
					"runSyncVar",
					"regLv3SyncFunc",
					"i",
					"syncSrc",
					"syncDst",
					"syncSrc",
					"VAR_SYNC_MAX",
					"growstepbystep",
					"B05.Vol.factor_ua",
					"B05.BOModule.chan02",
					"canStartTx",
					"growstepbystep",
					"addTask",
					"growstepbystep",
					"INT32",
					"LOCAL",
					"dst",
					"src",
					"reg_table",
					"INT8",
					"endif",
					"#if BOARD_TYPE==SY2102",
					"qdbg",
					"__LINE",
					"RESET_ORDER",
					"sent",
					"SEND_CPUCAN_OVT",
					"B05.ADSample.set_i_chan",
					"04014145",
					"B05.ADSample.set_i_chan",
					"B05.ADSample.set_u_chan01",
					"B05.ADSample.set_u_chan04",
					"B05.ADSample.set_i_chan01",
					"B05.ADSample.set_i_chan04",
					"PARA_GROUP",
					"B05.ADSample.set_i_chan01",
					"B38",
					"PARA_GROUP",
					"error",
					"Error",
					"error",
					"time_src_board",
					"0x3d    0x65",
					"msg sub_type is",
					"line 285",
					"line 124",
					"initSlave",
					"module 5",
					"line 80",
					"line 116",
					"initSlave",
					"app new error",
					"rttask",
					"sy.src",
					"canRx",
					"can't send",
					"can't send set ",
					"begin to init",
					"DEFAULT_PROCESSOR_NUMBER",
					"char_bits",
					"EXT_CODE",
					"EXT_DATA",
					"EXT_CODE",
					"EXT_DATA",
					"EXT_CODE",
					"EXT_DATA",
					"EXT_CODE",
					"EXT_",
					"lcdUiStatusDrawItem",
					"PIC33",
					"Mqx_main",
					"WS_DIR",
					"runTimerTask",
					"REL_ROOT_DIR",
					"SYS_INC",
					"canwrt_cnt",
					"*(INT8 *)&(looked->value) = (value>>i) & 1",
					"sent",
					"k",
					"addr",
					"遥控",
					"ptr_ptr",
					"getIvtByCommWay",
					"cpu_can_ivt",
					"B42.Vol0.smpl_ua",
					"=\"",
					"\"B42.Vol0.smpl_u",
					"B42.Vol0.smpl_ua_sta",
					"B42.Vol0.smpl_ua",
					"Vol0",
					"H_PRIM_IE",
					"H_OC1_t1",
					"单位",
					"闰",
					"printEventChangeState",
					"printEventInitStateItem",
					"printEventInitState",
					"printDrawoffTripRptItemUart",
					"printDrawoffTripRptUart",
					"printDrawoffTripRpt",
					"return",
					"tran_val",
					"readPrintShmCmd",
					"getUsCnt",
					"printTimerTask",
					"tran_val",
					"p_ref_info_ana",
					"printTimerTask"
				],
				"highlight": true,
				"in_selection": false,
				"preserve_case": false,
				"regex": true,
				"replace_history":
				[
					"sync_table",
					"B05",
					"MK64",
					"sntpTask",
					"LCD_PSD_DBG_MSG",
					"",
					"LCD_MAX_FACTOR_ADJUST",
					"crc_table_ini",
					"LCD_FILE_INI",
					"LCD_INI_BUFFER_SIZE",
					"LCD_INI_DEBUG",
					"INI_BUFFER_SIZE",
					"PRINTINFO",
					"crc32_calc_ini",
					"crc_table_ini",
					"BUFFER_SIZE",
					"printf",
					"U",
					"INT8",
					"INT32",
					"int",
					"unsigned int",
					"short",
					"char",
					"UINT",
					"INT8",
					"INT32",
					"UINT8",
					"INT8",
					"B7",
					"B6",
					"dec_ans",
					"",
					" ",
					",",
					" ",
					",",
					"",
					"swc_1_horgw1",
					"swc_2_horgw1",
					"swc_3_horgw1",
					"add",
					"set",
					" ",
					"",
					" ",
					"service",
					" "
				],
				"reverse": false,
				"show_context": true,
				"use_buffer2": true,
				"whole_word": false,
				"wrap": false
			},
			"incremental_find":
			{
				"height": 36.0
			},
			"input":
			{
				"height": 36.0
			},
			"menu_visible": true,
			"output.exec":
			{
				"height": 30.0
			},
			"output.find_results":
			{
				"height": 0.0
			},
			"output.unsaved_changes":
			{
				"height": 142.0
			},
			"pinned_build_system": "Packages/D/D.sublime-build",
			"replace":
			{
				"height": 66.0
			},
			"save_all_on_build": true,
			"select_file":
			{
				"height": 0.0,
				"last_filter": "",
				"selected_items":
				[
					[
						"",
						"sy.release\\sy.sys\\common.gnu\\inc\\cmd_confdefs.h"
					]
				],
				"width": 0.0
			},
			"select_project":
			{
				"height": 746.0,
				"last_filter": "",
				"selected_items":
				[
					[
						"",
						"D:\\workspace\\U21\\U21.sublime-project"
					]
				],
				"width": 1366.0
			},
			"select_symbol":
			{
				"height": 392.0,
				"last_filter": "",
				"selected_items":
				[
				],
				"width": 520.0
			},
			"show_minimap": true,
			"show_open_files": false,
			"show_tabs": true,
			"side_bar_visible": true,
			"side_bar_width": 274.0,
			"status_bar_visible": true,
			"template_settings":
			{
			}
		},
		"new_window_width": 751.0
	},
	"windows":
	[
		{
			"auto_complete":
			{
				"selected_items":
				[
					[
						"ar",
						"arg_len"
					],
					[
						"U",
						"UINT8"
					],
					[
						"__",
						"__LINE__"
					],
					[
						"h",
						"header_str"
					],
					[
						"pr",
						"print_type"
					],
					[
						"grp",
						"grp_index"
					],
					[
						"printEventInitStateI",
						"printEventInitStateItem"
					],
					[
						"tran",
						"tran_val"
					],
					[
						"time",
						"time_us"
					],
					[
						"ti",
						"time_us"
					],
					[
						"UNIT",
						"UINT32"
					],
					[
						"wr",
						"writing_flag"
					],
					[
						"w",
						"writing_cnt"
					],
					[
						"0x",
						"0xffffff"
					],
					[
						"INT",
						"INT64"
					],
					[
						"rec",
						"recv_proc_len"
					],
					[
						"re",
						"recv"
					],
					[
						"p",
						"p_gin"
					],
					[
						"gen",
						"gen_entry_num"
					],
					[
						"getGen",
						"getGenGrpByGrpNo"
					],
					[
						"f",
						"f_value"
					],
					[
						"u",
						"u_value"
					],
					[
						"by",
						"byte_num"
					],
					[
						"da",
						"datafield"
					],
					[
						"sett",
						"setting_grp_no"
					],
					[
						"sys_",
						"sys_grp_no"
					],
					[
						"gin",
						"gin_entry"
					],
					[
						"local_s",
						"local_set_value"
					],
					[
						"start",
						"start_sec_index"
					],
					[
						"op",
						"lcdOpWireDiagram"
					],
					[
						"show",
						"show_sec_num"
					],
					[
						"Print",
						"PrintLangDesc"
					],
					[
						"trans",
						"s_print_translate_array"
					],
					[
						"print_",
						"print_item_num"
					],
					[
						"se",
						"section_index"
					],
					[
						"sub",
						"sub_grp_num"
					],
					[
						"it",
						"item_num"
					],
					[
						"gr",
						"grp_index"
					],
					[
						"led",
						"led_cmd"
					],
					[
						"si",
						"signal_num"
					],
					[
						"C",
						"CALC"
					],
					[
						"init",
						"initLcdStep1"
					],
					[
						"sec",
						"sec_num"
					],
					[
						"g_",
						"g_lcd_timer_task"
					],
					[
						"fir",
						"first_sec"
					],
					[
						"g",
						"graph_page"
					],
					[
						"DBG",
						"LCD_DEBUG_MSG"
					],
					[
						"WI",
						"LCD_WIRE_DIAGRAM_DEBUG"
					],
					[
						"tm",
						"tmp_child"
					],
					[
						"p_",
						"p_section"
					],
					[
						"W",
						"LCD_WIRE_DIAGRAM_DEBUG"
					],
					[
						"LCD_WI",
						"LCD_WIRE_DIAGRAM_DEBUG"
					],
					[
						"_",
						"__FILE__"
					],
					[
						"row",
						"row_num"
					],
					[
						"L",
						"LCD_MAX_FACTOR"
					],
					[
						"n",
						"nfactor"
					],
					[
						"b",
						"buffer"
					],
					[
						"IN",
						"INT8"
					],
					[
						"B",
						"BUFFER_SIZE"
					],
					[
						"fac",
						"factorOut"
					],
					[
						"f_f",
						"f_factor"
					],
					[
						"f_",
						"f_coeff"
					],
					[
						"sour",
						"source1"
					],
					[
						"print",
						"printf\tprintf …"
					],
					[
						"buf",
						"buffer"
					],
					[
						"fa",
						"factorOut"
					],
					[
						"l",
						"lcd_temp"
					],
					[
						"LCD_MAX",
						"LCD_MAX_FACTOR_ADJUST"
					],
					[
						"factor",
						"factor_temp"
					],
					[
						"cr",
						"crc_ini"
					],
					[
						"crc",
						"crc_ini"
					],
					[
						"c",
						"crc"
					],
					[
						"a",
						"accoeff"
					],
					[
						"S",
						"Section_Name"
					],
					[
						"s",
						"section"
					],
					[
						"section",
						"Section_Name"
					],
					[
						"K",
						"Key_Name"
					],
					[
						"de",
						"dest"
					],
					[
						"st",
						"strcat"
					],
					[
						"d",
						"d_ptr"
					],
					[
						"max",
						"max_all"
					],
					[
						"arr",
						"arr1"
					],
					[
						"str",
						"strlen"
					],
					[
						"va",
						"value"
					],
					[
						"r",
						"right"
					],
					[
						"all",
						"allocp"
					],
					[
						"al",
						"allocbuf"
					],
					[
						"ma",
						"maxlines"
					],
					[
						"t",
						"t_tail"
					],
					[
						"M",
						"MAXLINE"
					],
					[
						"bu",
						"buf_sign"
					],
					[
						"get",
						"getchar"
					],
					[
						"m",
						"MAXLINE　100"
					],
					[
						"mask",
						"mask_x"
					],
					[
						"i",
						"inc\t#include \"…\""
					],
					[
						"inc",
						"include"
					],
					[
						"he",
						"hexa"
					],
					[
						"H",
						"HEAD1"
					],
					[
						"in",
						"inspace"
					],
					[
						"ele",
						"ele_src"
					],
					[
						"ds",
						"dst"
					],
					[
						"res_b",
						"res_b"
					],
					[
						"res",
						"res_a"
					],
					[
						"D",
						"Distance_a"
					]
				]
			},
			"buffers":
			[
				{
					"file": "sy.src/sy.hmi/Makefile",
					"settings":
					{
						"buffer_size": 1832,
						"encoding": "UTF-8",
						"line_ending": "Windows"
					}
				},
				{
					"contents": "/*==========================================================================*\n * 文件模块说明: LCD配置文件lcdconfig.xml解析\t\t\t\t\t\t\t\t\t*\n * 文件版本: V 1.00\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t*\n * 开发人员: 戴刚\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t*\n * 创建时间: 2014-10-08\t\t\t\t\t\t\t\t\t\t\t\t\t\t*\n * Copyright(c) 1993-2014 Shanghai SHR Electrical Power Technology Co. Ltd. *\n *==========================================================================*\n * 程序修改记录:\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t*\n *==========================================================================*/\n\n#include \"lcdconfig.h\"\n#include \"lcdmenu.h\"\n#include \"lcdservice.h\"\n#include \"lcd.h\"\n#include \"lcdpage.h\"\n\n#include \"tinystr.h\"\n#include \"tinyxml.h\"\n\n\n// 本模块私有函数\nLOCAL INT32 lcdParseMenu(TiXmlElement *xml, LcdMenu *parent, TiXmlElement *page, Lcd *lcd);  // 菜单解析\nLOCAL INT32 lcdParsePage(TiXmlElement *xml, LcdMenu *menu, Lcd *lcd);\t\t// 自定义页面解析\nLOCAL void lcdOpStatusValidObtainRecur(LcdMenu *parent);\t\t\t\t\t// 隐藏模拟量菜单\n\n\n// 本模块公有函数定义\n/*****************************************************************************\n * 函 数 名: lcdLoadFile\n * 描    述: 加载解析LCD配置文件lcdconfig.xml\n * 调 用 者: lcd.c\n * 输    入: szfile表示配置文件名字；lcd表示本模块全局结构体\n * 返 回 值: 0表示解析成功，-1表示解析失败\n * 日    期: 2014-10-08\n * 修改记录:\n ****************************************************************************/\nINT32 lcdLoadFile(const INT8 *szfile, Lcd *lcd)\n{\n\tTiXmlElement *root = NULL, *menu = NULL;\n\tTiXmlDocument doc(szfile);\n\n\t// 读取LCD配置文件\n\tif(!doc.LoadFile())\n\t{\n\t\tLCD_EXCEPTION1(\"[lcd]: (_func_lcdLoadFile) Open file %s failed!\", szfile);\n\t\treturn -1;\n\t}\n\n\t// 根据LCD文件配置格式，进行解析处理\n\troot = doc.FirstChildElement(\"LCD\");\n\tif(NULL == root)\n\t{\n\t\tLCD_EXCEPTION(\"[lcd]: (_func_lcdLoadFile) Can't find xml node(\\\"LCD\\\").\");\n\t\treturn -1;\n\t}\n\n\tmenu = root->FirstChildElement(\"MENUS\");\n\tif (NULL == menu)\n\t{\n\t\tLCD_EXCEPTION(\"[lcd]: (_func_lcdLoadFile) Can't find xml node(\\\"MENUS\\\").\");\n\t\treturn -1;\n\t}\n\n\tif(0 != lcdParseMenu(menu, &lcd->root_menu, root->FirstChildElement(\"PAGES\"), lcd))\n\t{\n\t\tLCD_TRACE(\"[lcd]: (_func_lcdLoadFile) lcdParseMenu failed!\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/*****************************************************************************\n * 函 数 名: lcdOpStatusValidObtain\n * 描    述: 解析模拟量菜单，如果没有子菜单，则剔除本级菜单\n * 调 用 者: \n * 输    入: lcd为元件指针\n * 返 回 值: 无\n * 日    期: 2014-12-09\n * 修改记录:\n ****************************************************************************/\nvoid lcdOpStatusValidObtain(Lcd *lcd)\n{\n\tLcdMenu *p_menu = &lcd->root_menu;\n\n\tlcdOpStatusValidObtainRecur(p_menu);\n\n\treturn;\n}\n\n// 本模块私有函数定义\n/* 菜单解析 */\nLOCAL INT32 lcdParseMenu(TiXmlElement *xml, LcdMenu *parent, TiXmlElement *page, Lcd *lcd)\n{\n\tLcdMenu *p_menu = NULL;\n\tTiXmlElement *ele = NULL;\n\tconst INT8 *p_id = NULL, *p_abbr = NULL, *p_str = NULL;\n\tINT16 len = 0;\n\tLcdService *p_svr = NULL;\n\tINT8 hide_flag = 0;\n\n\t// 顺序扫描xml的所有子节点\n\tfor (ele = xml->FirstChildElement(); NULL != ele; ele = ele->NextSiblingElement())\n\t{\n\t\t// 菜单是否可见\n\t\tif(0 == LCD_STRCMP(ele->Attribute(\"visible\"), \"0\"))\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\t// 菜单ID类型\n\t\tp_id = ele->Attribute(\"id\");\t\n\t\tif (NULL == p_id)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\thide_flag = 0;\n\n\t\t// 子菜单是否隐藏，不支持根菜单隐藏\n\t\tp_str = ele->Attribute(\"hide_attr\");\n\t\tif ((NULL == p_str) || (0 == LCD_ATOI(p_str)))\n\t\t{\n\t\t\t// 新建一个菜单\n\t\t\tp_menu = lcdNewMenu(parent);\n\t\t\tif (NULL == p_menu)\n\t\t\t{\n\t\t\t\tLCD_EXCEPTION(\"[lcd]: _func_lcdParseMenu lcdNewMenu failed!\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t// 读取一二次值字段\n\t\t\tp_str = ele->Attribute(\"ps\");\n\t\t\tif ((NULL != p_str) && (0 != LCD_ATOI(p_str)))\n\t\t\t{\n\t\t\t\tp_menu->flag |= LCD_MENU_FLAG_PS;\n\t\t\t}\n\n\t\t\t// 菜单缩略语\n\t\t\tp_abbr = ele->Attribute(\"abbr\");\n\t\t\tif (NULL == p_abbr)\n\t\t\t{\n\t\t\t\tp_abbr = p_id;\n\t\t\t}\n\t\t\tLCD_STRCPY(p_menu->abbr, p_abbr);\n\n\t\t\t// 菜单名称\n\t\t\tp_str = LCD_TRANSLATE_STRING(p_abbr);\n\t\t\tif ((NULL == p_str) || (p_str == p_abbr))\n\t\t\t{\n\t\t\t\tp_str = ele->Attribute(\"name\");\n\t\t\t}\n\t\t\tLCD_STRCPY(p_menu->name, NULL != p_str ? p_str : p_abbr);\n\n\t\t\t// 菜单长度\n\t\t\tlen = (INT16)LCD_STRLEN(p_menu->name);\n\t\t\tif(len > parent->child_width)\n\t\t\t{\n\t\t\t\tparent->child_width = len;\n\t\t\t}\n\n\t\t\thide_flag = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\thide_flag = 1;\n\t\t}\n\n\t\t// 菜单与业务关联\n\t\tif (ele->NoChildren())\n\t\t{\t\n\t\t\t// 根据菜单ID寻找预置业务\n\t\t\tp_svr = lcdFindServiceByName(p_id);\n\n\t\t\t// 如果未找到预置业务\n\t\t\tif (NULL == p_svr)\t\t\n\t\t\t{\n\t\t\t\t// 根据菜单函数新建业务\n\t\t\t\tp_svr = lcdNewServiceByFunc(p_id, ele->Attribute(\"func\"));\n\t\t\t}\n\n\t\t\tif (NULL != p_svr)\n\t\t\t{\n\t\t\t\tlcdInitService(lcd, p_svr);\n\n\t\t\t\tif (0 == hide_flag)\n\t\t\t\t{\n\t\t\t\t\tp_menu->p_svr = p_svr;\n\t\t\t\t\tp_menu->event_func = p_svr->menu_func;\n\t\t\t\t\tp_menu->event_param = p_svr->menu_param;\n\t\t\t\t}\t\n\t\t\t}\n\n\t\t\t// 如果未找到预置业务，使用自定义页面\n\t\t\tif ((NULL == p_menu->event_func) && (NULL != page))\n\t\t\t{\n\t\t\t\tlcdParsePage(page, p_menu, lcd);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlcdParseMenu(ele, p_menu, page, lcd);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* 自定义页面解析 */\nLOCAL INT32 lcdParsePage(TiXmlElement *xml, LcdMenu *menu, Lcd *lcd)\n{\n\tLcdPageGraph *p_graph_page = NULL;\n\tLcdGraph *p_graph = NULL, *p_last = NULL;\n\tTiXmlElement *p_child = NULL;\n\tTiXmlElement *ele = xml->FirstChildElement();\n\n\tfor (; NULL != ele; ele = ele->NextSiblingElement())\n\t{\n\t\tif (0 != LCD_STRCMP(ele->Attribute(\"id\"), menu->abbr))\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\t// 新建自定义页面\n\t\tp_graph_page = LCD_NEW(LcdPageGraph);\n\t\tif (NULL == p_graph_page)\n\t\t{\n\t\t\tLCD_EXCEPTION(\"[lcd]: (_func_lcdParsePage) Calloc graph page failed!\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tmemset(p_graph_page, 0, sizeof(LcdPageGraph));\n\t\tp_last = NULL;\n\t\tfor (p_child = ele->FirstChildElement(); NULL != p_child; p_child = p_child->NextSiblingElement())\n\t\t{\n\t\t\tp_graph = NULL;\n\t\t\tif (0 == LCD_STRCMP(p_child->Value(), \"RECT\"))\n\t\t\t{\n\t\t\t\t// 矩形\n\t\t\t\tp_graph = LCD_NEW(LcdGraph);\n\t\t\t\tif (NULL == p_graph)\n\t\t\t\t{\n\t\t\t\t\tLCD_EXCEPTION(\"[lcd]: (_func_lcdParsePage) Calloc graph rect failed!\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tmemset(p_graph, 0, sizeof(LcdGraph));\n\n\t\t\t\tp_graph->type = LCD_GRAPH_RECT;\n\t\t\t\tp_graph->show_flag = 1;\n\t\t\t\tp_graph->data.rect.x1 = (INT16)LCD_ATOI(p_child->Attribute(\"x1\"));\n\t\t\t\tp_graph->data.rect.y1 = (INT16)LCD_ATOI(p_child->Attribute(\"y1\"));\n\t\t\t\tp_graph->data.rect.x2 = (INT16)LCD_ATOI(p_child->Attribute(\"x2\"));\n\t\t\t\tp_graph->data.rect.y2 = (INT16)LCD_ATOI(p_child->Attribute(\"y2\"));\n\t\t\t\tp_graph->data.rect.filled = (INT16)LCD_ATOI(p_child->Attribute(\"filled\"));\n\n\t\t\t\tif (1 == p_graph->data.rect.filled)\n\t\t\t\t{\n\t\t\t\t\tp_graph->type = LCD_GRAPH_RECT_SOLID;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (0 == LCD_STRCMP(p_child->Value(), \"TEXT\"))\n\t\t\t{\n\t\t\t\t// 文本\n\t\t\t\tp_graph = LCD_NEW(LcdGraph);\n\t\t\t\tif (NULL == p_graph)\n\t\t\t\t{\n\t\t\t\t\tLCD_EXCEPTION(\"[lcd]: (_func_lcdParsePage) Calloc graph text failed!\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tmemset(p_graph, 0, sizeof(LcdGraph));\n\n\t\t\t\tp_graph->type = LCD_GRAPH_TEXT;\n\t\t\t\tp_graph->show_flag = 1;\n\t\t\t\tp_graph->data.text.x = (INT16)LCD_ATOI(p_child->Attribute(\"x\"));\n\t\t\t\tp_graph->data.text.y = (INT16)LCD_ATOI(p_child->Attribute(\"y\"));\n\t\t\t\tp_graph->data.text.text = LCD_NEW_STR(p_child->Attribute(\"label\"));\n\t\t\t}\n\t\t\telse if (0 == LCD_STRCMP(p_child->Value(), \"LINE\"))\n\t\t\t{\n\t\t\t\t// 直线\n\t\t\t\tp_graph = LCD_NEW(LcdGraph);\n\t\t\t\tif (NULL == p_graph)\n\t\t\t\t{\n\t\t\t\t\tLCD_EXCEPTION(\"[lcd]: (_func_lcdParsePage) Calloc graph line failed!\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tmemset(p_graph, 0, sizeof(LcdGraph));\n\n\t\t\t\tp_graph->type = LCD_GRAPH_LINE;\n\t\t\t\tp_graph->show_flag = 1;\n\t\t\t\tp_graph->data.line.x1 = (INT16)LCD_ATOI(p_child->Attribute(\"x1\"));\n\t\t\t\tp_graph->data.line.y1 = (INT16)LCD_ATOI(p_child->Attribute(\"y1\"));\n\t\t\t\tp_graph->data.line.x2 = (INT16)LCD_ATOI(p_child->Attribute(\"x2\"));\n\t\t\t\tp_graph->data.line.y2 = (INT16)LCD_ATOI(p_child->Attribute(\"y2\"));\n\t\t\t}\n\t\t\telse if (0 == LCD_STRCMP(p_child->Value(), \"POINT\"))\n\t\t\t{\n\t\t\t\t// 点\n\t\t\t\tp_graph = LCD_NEW(LcdGraph);\n\t\t\t\tif (NULL == p_graph)\n\t\t\t\t{\n\t\t\t\t\tLCD_EXCEPTION(\"[lcd]: (_func_lcdParsePage) Calloc graph point failed!\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tmemset(p_graph, 0, sizeof(LcdGraph));\n\n\t\t\t\tp_graph->type = LCD_GRAPH_POINT;\n\t\t\t\tp_graph->show_flag = 1;\n\t\t\t\tp_graph->data.point.x = (INT16)LCD_ATOI(p_child->Attribute(\"x\"));\n\t\t\t\tp_graph->data.point.y = (INT16)LCD_ATOI(p_child->Attribute(\"y\"));\n\t\t\t}\n\t\t\telse if (0 == LCD_STRCMP(p_child->Value(), \"ARC\"))\n\t\t\t{\n\t\t\t\t// 半圆弧\n\t\t\t\tp_graph = LCD_NEW(LcdGraph);\n\t\t\t\tif (NULL == p_graph)\n\t\t\t\t{\n\t\t\t\t\tLCD_EXCEPTION(\"[lcd]: (_func_lcdParsePage) Calloc graph arc failed!\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tmemset(p_graph, 0, sizeof(LcdGraph));\n\n\t\t\t\tp_graph->type = LCD_GRAPH_ARC;\n\t\t\t\tp_graph->show_flag = 1;\n\t\t\t\tp_graph->data.arc.x = (INT16)LCD_ATOI(p_child->Attribute(\"x\"));\n\t\t\t\tp_graph->data.arc.y = (INT16)LCD_ATOI(p_child->Attribute(\"y\"));\n\t\t\t\tp_graph->data.arc.r = (INT16)LCD_ATOI(p_child->Attribute(\"r\"));\n\t\t\t\tp_graph->data.arc.dir = (INT16)LCD_ATOI(p_child->Attribute(\"dir\"));\n\t\t\t}\n\t\t\telse if (0 == LCD_STRCMP(p_child->Value(), \"DIAMOND\"))\n\t\t\t{\n\t\t\t\t// 菱形\n\t\t\t\tp_graph = LCD_NEW(LcdGraph);\n\t\t\t\tif (NULL == p_graph)\n\t\t\t\t{\n\t\t\t\t\tLCD_EXCEPTION(\"[lcd]: (_func_lcdParsePage) Calloc graph diamond failed!\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tmemset(p_graph, 0, sizeof(LcdGraph));\n\n\t\t\t\tp_graph->type = LCD_GRAPH_DIAMOND;\n\t\t\t\tp_graph->show_flag = 1;\n\t\t\t\tp_graph->data.diamond.x = (INT16)LCD_ATOI(p_child->Attribute(\"x\"));\n\t\t\t\tp_graph->data.diamond.y = (INT16)LCD_ATOI(p_child->Attribute(\"y\"));\n\t\t\t\tp_graph->data.diamond.w = (INT16)LCD_ATOI(p_child->Attribute(\"w\"));\n\t\t\t\tp_graph->data.diamond.h = (INT16)LCD_ATOI(p_child->Attribute(\"h\"));\n\t\t\t\tp_graph->data.diamond.filled = (INT16)LCD_ATOI(p_child->Attribute(\"filled\"));\n\t\t\t}\n\t\t\telse if(0 == LCD_STRCMP(p_child->Value(), \"TRIANGLE\"))\n\t\t\t{\n\t\t\t\t// 三角形\n\t\t\t\tp_graph = LCD_NEW(LcdGraph);\n\t\t\t\tif (NULL == p_graph)\n\t\t\t\t{\n\t\t\t\t\tLCD_EXCEPTION(\"[lcd]: (_func_lcdParsePage) Calloc graph triangle failed!\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tmemset(p_graph, 0, sizeof(LcdGraph));\n\n\t\t\t\tp_graph->type = LCD_GRAPH_TRIANGLE;\n\t\t\t\tp_graph->show_flag = 1;\n\t\t\t\tp_graph->data.triangle.x = (INT16)LCD_ATOI(p_child->Attribute(\"x\"));\n\t\t\t\tp_graph->data.triangle.y = (INT16)LCD_ATOI(p_child->Attribute(\"y\"));\n\t\t\t\tp_graph->data.triangle.w = (INT16)LCD_ATOI(p_child->Attribute(\"w\"));\n\t\t\t\tp_graph->data.triangle.h = (INT16)LCD_ATOI(p_child->Attribute(\"h\"));\n\t\t\t\tp_graph->data.triangle.filled = (INT16)LCD_ATOI(p_child->Attribute(\"filled\"));\n\t\t\t}\n\t\t\telse if (0 == LCD_STRCMP(p_child->Value(), \"ELLIPSE\"))\n\t\t\t{\n\t\t\t\t// 椭圆\n\t\t\t\tp_graph = LCD_NEW(LcdGraph);\n\t\t\t\tif (NULL == p_graph)\n\t\t\t\t{\n\t\t\t\t\tLCD_EXCEPTION(\"[lcd]: (_func_lcdParsePage) Calloc graph ellipse failed!\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tmemset(p_graph, 0, sizeof(LcdGraph));\n\n\t\t\t\tp_graph->type = LCD_GRAPH_ELLIPSE;\n\t\t\t\tp_graph->show_flag = 1;\n\t\t\t\tp_graph->data.ellipse.x = (INT16)LCD_ATOI(p_child->Attribute(\"x\"));\n\t\t\t\tp_graph->data.ellipse.y = (INT16)LCD_ATOI(p_child->Attribute(\"y\"));\n\t\t\t\tp_graph->data.ellipse.a = (INT16)LCD_ATOI(p_child->Attribute(\"a\"));\n\t\t\t\tp_graph->data.ellipse.b = (INT16)LCD_ATOI(p_child->Attribute(\"b\"));\n\t\t\t\tp_graph->data.ellipse.filled = (INT16)LCD_ATOI(p_child->Attribute(\"filled\"));\n\t\t\t}\n\n\t\t\tif (NULL != p_graph)\n\t\t\t{\n\t\t\t\tif (NULL == p_graph_page->first_graph)\n\t\t\t\t{\n\t\t\t\t\tp_graph_page->first_graph = p_graph;\n\t\t\t\t\tp_last = p_graph;\n\t\t\t\t\tp_graph_page->graph_num = 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tp_last->next = p_graph;\n\t\t\t\t\tp_last = p_graph;\n\t\t\t\t\tp_graph_page->graph_num++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 自定义页面业务入口\n\t\tlcdGraphSvrEntry(menu, p_graph_page, lcd);\n\t\tbreak;\n\t}\n\t\n\treturn 0;\n}\n\n/* 隐藏模拟量菜单 */\nLOCAL void lcdOpStatusValidObtainRecur(LcdMenu *parent)\n{\n\tLcdMenu *p_menu = NULL, *p_next = NULL, *p_prev = NULL;\n\tLcdRefTable *p_ref = NULL;\n\tDataFields *p_datafield = NULL;\n\tLcdSplitStringList *lst = NULL;\n\tINT32 i = 0, j = 0, valid_num = 0, sub_num = 0;\n\n\tfor (i = 0; i < parent->child_num; i++)\n\t{\n\t\tif (0 == i)\n\t\t{\n\t\t\tp_menu = parent->first_child;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (p_menu)\n\t\t\t{\n\t\t\t\tp_menu = p_menu->next;\n\t\t\t}\n\t\t}\n\n\t\tif (NULL == p_menu)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (lcdOpStatusShow == p_menu->p_svr->menu_func)\n\t\t{\n\t\t\tvalid_num = 0;\n\t\t\tp_ref = (LcdRefTable *)p_menu->p_svr->menu_param;\n\n\t\t\tif (NULL != p_ref)\n\t\t\t{\n\t\t\t\tfor (j = 0; j < p_ref->item_num; j++)\n\t\t\t\t{\n\t\t\t\t\tlst = lcdSplitStringStatic(p_ref->p_ref_info->item[j], ':');\n\t\t\t\t\tp_datafield = getSignalOutWithName(lst->item[0]);\n\t\t\t\t\tif (DESC_LCD_VISIBLE(p_datafield))\n\t\t\t\t\t{\n\t\t\t\t\t\tvalid_num++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (0 == valid_num)\n\t\t\t{\n\t\t\t\tp_prev = p_menu->prev;\n\t\t\t\tp_next = p_menu->next;\n\n\t\t\t\tif (p_prev)\n\t\t\t\t{\n\t\t\t\t\tif(p_next)\n\t\t\t\t\t{\n\t\t\t\t\t\tp_prev->next = p_next;\n\t\t\t\t\t\tp_next->prev = p_prev;\n\t\t\t\t\t\tsub_num++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tp_prev->next = NULL;\n\t\t\t\t\t\tparent->last_child = p_prev;\n\t\t\t\t\t\tsub_num++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (p_next)\n\t\t\t\t\t{\n\t\t\t\t\t\tp_next->prev = NULL;\n\t\t\t\t\t\tparent->first_child = p_next;\n\t\t\t\t\t\tsub_num++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tparent->first_child = NULL;\n\t\t\t\t\t\tparent->last_child = NULL;\n\t\t\t\t\t\tsub_num++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (p_menu->first_child)\n\t\t{\n\t\t\tlcdOpStatusValidObtainRecur(p_menu);\n\t\t}\n\t}\n\n\tif (parent->child_num >= sub_num)\n\t{\n\t\tparent->child_num -= sub_num;\n\t}\n\n\treturn;\n}\n",
					"file": "sy.src/sy.hmi/lcd/src/lcdconfig.cpp",
					"file_size": 13563,
					"file_write_time": 131262575996331026,
					"settings":
					{
						"buffer_size": 12683,
						"line_ending": "Windows",
						"scratch": true
					}
				},
				{
					"file": "sy.src/sy.hmi/rttask/src/led.c",
					"settings":
					{
						"buffer_size": 15288,
						"encoding": "UTF-8",
						"line_ending": "Windows"
					}
				},
				{
					"file": "sy.src/sy.hmi/rttask/inc/led.h",
					"settings":
					{
						"buffer_size": 1703,
						"encoding": "UTF-8",
						"line_ending": "Windows"
					}
				},
				{
					"contents": "/*==========================================================================*\n * 文件模块说明: LCD模块打印处理\t\t\t\t\t\t\t\t\t\t\t\t*\n * 文件版本: V 1.00\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t*\n * 开发人员: 戴刚\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t*\n * 创建时间: 2014-10-09\t\t\t\t\t\t\t\t\t\t\t\t\t\t*\n * Copyright(c) 1993-2014 Shanghai SHR Electrical Power Technology Co. Ltd. *\n *==========================================================================*\n * 程序修改记录:\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t*\n *==========================================================================*/\n\n#include \"lcdprinter.h\"\n#include \"lcd.h\"\n#include \"lcdedit.h\"\n#include \"lcduigen.h\"\n#include \"lcdset.h\"\n#include \"lcddraw.h\"\n#include \"lcdgrid.h\"\n#include \"lcdreport.h\"\n\n\n// 本模块私有变量定义\nLOCAL const INT8 *s_lcd_print_wave_args[4] = \n{\n\t\"PRINT_WAVE_CHECK\", \n\t\"PRINT_WAVE_BIN\", \n\t\"PRINT_WAVE_SHAPE\", \n\t\"PRINT_WAVE_SETTING\"\n\t//\"PRINT_WAVE_SMPL\"  //由于会打印中断，暂取消打印采样值选项\n};\n\nLOCAL const INT8 *s_lcd_print_trip_type[2] = \n{\n\t\"DRAWOFF_SIMPLE_TRIP_REPORT\", \n\t\"DRAWOFF_DETAIL_TRIP_REPORT\"\n};\n// 本模块私有结构体定义\n/* 一般打印页面结构体 */\ntypedef struct _lcd_page_normal_print\n{\n\tLCD_PAGE_BASE;\n\tLcdCtrlEdit zone_edit;\t\t\t\t\t\t// 区号编辑框控件\n\tINT32 print_type;\t\t\t\t\t\t\t// 打印类别\n\tUINT32 first_rpt;\t\t\t\t\t\t\t// 第一条报告\n\tUINT32 last_rpt;\t\t\t\t\t\t\t// 最后一条报告\n\tUINT16 rpt_num;\t\t\t\t\t\t\t\t// 报告数目\n\tUINT16 rpt_type;\t\t\t\t\t\t\t// 报告类型\n\tINT16 set_zone;\t\t\t\t\t\t\t\t// 定值区\n\tINT16 set_group;\t\t\t\t\t\t\t// 定值组\n\tINT16 set_group_show;\t\t\t\t\t\t// 显示的定值组\n\tINT16 set_group_select;\t\t\t\t\t\t// 选中的定值组\n\tINT8 has_zone;\t\t\t\t\t\t\t\t// 有定值区\n\tINT8 need_zone;\t\t\t\t\t\t\t\t// 需要设置定值区\n\tINT8 confirm;\t\t\t\t\t\t\t\t// 打印确认\n\tINT8 result;\t\t\t\t\t\t\t\t// 打印结果\n} LcdPageNormalPrint;\n\n/* 打印取消页面结构体 */\ntypedef struct _lcd_page_print_cancel\n{\n\tLCD_PAGE_BASE;\n\tUINT32 last_time;\t\t\t\t\t\t\t// 页面上一时刻\n\tINT8 confirm;\t\t\t\t\t\t\t\t// 页面确认\n\tINT8 finish;\t\t\t\t\t\t\t\t// 完成标志\n} LcdPagePrintCancel;\n\nLCD_PTRLIST_ARRAY(INT8 *, LcdPrintFaultWords);\n\ntypedef struct _lcd_print_fault_info\n{\n\tLCD_CLASS_DECLARE(LcdPrintFaultInfo);\n\tLcdPrintFaultWords list;\n\tLcdRefTable *ref;\n\tINT8 print_page[16];\n\tINT8 valid_page_num;\t\n} LcdPrintFaultInfo;\n\n/* 打印整组页面结构体 */\ntypedef struct _lcd_page_print_fault\n{\n\tLCD_PAGE_BASE;\n\tLcdFaultReport *p_fault;\t\t\t\t\t// 整组报告指针\n\tLcdPrintFaultInfo *p_info;\t\t\t\t\t// 整组故障信息\n\tINT16 fault_index;\t\t\t\t\t\t\t// 整组故障序号\n\tINT16 show_fault_item;\t\t\t\t\t\t// 显示的整组号\n\tINT16 show_grp;\t\t\t\t\t\t\t\t// 显示组号\n\tINT16 select_grp;\t\t\t\t\t\t\t// 选择的组号\n\tINT8 print_fault;\t\t\t\t\t\t\t// 是否打印整组\n\tINT8 print_wave_id;\t\t\t\t\t\t\t// 打印波形ID号\n\tINT8 need_print;\t\t\t\t\t\t\t// 是否打印\n\tINT8 need_fault;\t\t\t\t\t\t\t// 是否整组\n\tINT8 print_result;\t\t\t\t\t\t\t// 打印结果\n\tINT8 print_arg_index;\t\t\t\t\t\t// 打印参数索引\n\tINT8 print_args[4];\t\t\t\t\t\t\t// 打印参数\n\tINT8 print_arg_index2;\t\t\t\t\t\t// 整组报告类别索引\n\tINT8 need_classify ;\t\t\t\t\t    // 分类打印\n} LcdPagePrintFault;\n\n// 本模块私有函数声明\n/* 检查打印机状态 */\nLOCAL INT8 lcdUiCheckPrinterStatus(Lcd *lcd);\n\n/* 一般打印页面显示函数 */\nLOCAL void lcdUiNormalPrintShow(void *param);\n\n/* 一般打印页面按键处理函数 */\nLOCAL void lcdUiNormalPrintKey(void *param);\n\n/* 执行一般打印命令 */\nLOCAL void lcdUiNormalPrintExecute(LcdPageNormalPrint *page);\n\n/* 发送打印命令 */\nLOCAL INT8 lcdUiSendPrintCmd(const INT8 *cmd, INT32 arg_num, INT8 *args, INT32 arg_len);\n\n/* 打印取消页面显示函数 */\nLOCAL void lcdUiPrintCancelShow(void *param);\n\n/* 打印取消页面按键函数 */\nLOCAL void lcdUiPrintCancelKey(void *param);\n\n/* 打印取消页面定时事件 */\nLOCAL void lcdUiPrintCancelTimer(void *param);\n\n/* 整组故障引用表回调函数 */\nLOCAL INT32 lcdPrintFaultRefFunc(INT32 i, LcdSplitStringList *lst, LcdRefTable *ref, void *param);\n\n/* 打印整组故障页面显示函数 */\nLOCAL void lcdUiPrintFaultShow(void *param);\n\n/* 打印整组故障页面按键函数 */\nLOCAL void lcdUiPrintFaultKey(void *param);\n\n/* 获取整组有效数目 */\nLOCAL INT32 lcdUiGetPrintValidPageNum(LcdPagePrintFault *page);\n\n/* 整组故障条目绘制 */\nLOCAL void lcdUiPrintFaultDrawGroup(INT16 x, INT16 y, INT16 row, INT16 col, void *param);\n\n/* 根据描述找到特定的定值组 */\nLOCAL void lcdPrintSetFindGroup(LcdPageNormalPrint *set, const INT8 *desc);\n\n\n// 本模块公有函数定义\n/*****************************************************************************\n * 函 数 名: lcdOpPrintNormal\n * 描    述: 一般打印处理\n * 调 用 者: lcdservice.c\n * 输    入: param为参数\n * 返 回 值: 无\n * 日    期: 2014-10-11\n * 修改记录:\n ****************************************************************************/\nvoid lcdOpPrintNormal(void* param)\n{\n\tLcdParamMenu *par = LCD_PARAM_MENU(param);\n\tLcd *lcd = par->lcd;\n\tLcdPageNormalPrint *page = LCD_NEW_DYNAMIC_PAGE(LcdPageNormalPrint, lcd);\n\tSettingGrps *p_grps = getDevSettingGrps();\n\tSettingGrp *p_grp = NULL;\n\n\tif (0 != lcdUiCheckPrinterStatus(par->lcd))\n\t{\n#ifdef LCD_PRINT_DEBUG\n\t\tLCD_TRACE(\"[lcd]: (_func_lcdOpPrintNormal) Check printer status uncorrect!\\n\");\n#endif\n\t\treturn;\n\t}\n\n\t// 页面初始化\n\tpage->show_func = lcdUiNormalPrintShow;\n\tpage->key_func = lcdUiNormalPrintKey;\n\tpage->print_type = par->p_svr->id;\n\tpage->rpt_num = 1;\n\n\tswitch (page->print_type)\n\t{\n\tcase PRINT_ALL_SET:\n\t\tp_grps = getDevSettingGrps();\n\t\tlcdEditSetUint(&page->zone_edit, 1, p_grps->max_section_num, p_grps->cur_section);\n\t\tbreak;\n\n\tcase PRINT_SETTINGS:\n\t\tif (0 == lcdSetInit(lcd))\n\t\t{\n\t\t\tlcdSetInitGroups(lcd->setting);\n\t\t}\n\t\telse\n\t\t{\n#ifdef LCD_PRINT_DEBUG\n\t\t\tLCD_TRACE(\"[lcd]: (_func_lcdOpPrintNormal) Set init failed!\\n\");\n#endif\n\t\t}\n\t\tbreak;\n\n\tcase PRINT_TRIP_RPT:\n\t\tpage->rpt_num = getHisEventNum(EN_TRIP_EVENT, &page->first_rpt, &page->last_rpt);\n\t\tbreak;\n\n\tcase PRINT_CHECK_RPT:\n\t\tpage->rpt_num = getHisEventNum(EN_CHECK_EVENT, &page->first_rpt, &page->last_rpt);\n\t\tbreak;\n\n\tcase PRINT_BIN_RPT:\n\t\tpage->rpt_num = getHisEventNum(EN_BI_EVENT, &page->first_rpt, &page->last_rpt);\n\t\tbreak;\n\n\tcase PRINT_RUN_RPT:\n\t\tpage->rpt_num = getHisEventNum(EN_RUN_EVENT, &page->first_rpt, &page->last_rpt);\n\t\tbreak;\n\n\tcase PRINT_SOE_RPT:\n\t\tpage->rpt_num = getHisEventNum(EN_YX_EVENT, &page->first_rpt, &page->last_rpt);\n\t\tbreak;\n\n\tcase PRINT_OP_RPT:\n\t\tpage->rpt_num = getHisEventNum(EN_ORDER_EVENT, &page->first_rpt, &page->last_rpt);\n\t\tbreak;\n\n\tcase PRINT_CHAN_A_SUPV:\n\t\tpage->rpt_type = 0;\n\t\tpage->rpt_num = getHisEventNum(EN_CHAN_A_CHK_EVENT, &page->first_rpt, &page->last_rpt);\n\t\tbreak;\n\n\tcase PRINT_CHAN_B_SUPV:\n\t\tpage->rpt_type = 1;\n\t\tpage->rpt_num = getHisEventNum(EN_CHAN_B_CHK_EVENT, &page->first_rpt, &page->last_rpt);\n\t\tbreak;\n\n\tcase PRINT_CHAN_C_SUPV:\n\t\tpage->rpt_type = 2;\n\t\tpage->rpt_num = getHisEventNum(EN_CHAN_C_CHK_EVENT, &page->first_rpt, &page->last_rpt);\n\t\tbreak;\n\n\tcase PRINT_CHAN_D_SUPV:\n\t\tpage->rpt_type = 3;\n\t\tpage->rpt_num = getHisEventNum(EN_CHAN_D_CHK_EVENT, &page->first_rpt, &page->last_rpt);\n\t\tbreak;\n\n\tcase PRINT_CHAN_A_STAT:\n\t\tpage->rpt_type = 0;\n\t\tpage->rpt_num = getHisEventNum(EN_CHAN_A_STAT_EVENT, &page->first_rpt, &page->last_rpt);\n\t\tbreak;\n\n\tcase PRINT_CHAN_B_STAT:\n\t\tpage->rpt_type = 1;\n\t\tpage->rpt_num = getHisEventNum(EN_CHAN_B_STAT_EVENT, &page->first_rpt, &page->last_rpt);\n\t\tbreak;\n\n\tcase PRINT_CHAN_C_STAT:\n\t\tpage->rpt_type = 2;\n\t\tpage->rpt_num = getHisEventNum(EN_CHAN_C_STAT_EVENT, &page->first_rpt, &page->last_rpt);\n\t\tbreak;\n\n\tcase PRINT_CHAN_D_STAT:\n\t\tpage->rpt_type = 3;\n\t\tpage->rpt_num = getHisEventNum(EN_CHAN_D_STAT_EVENT, &page->first_rpt, &page->last_rpt);\n\t\tbreak;\n\n\tcase PRINT_EQUIP:\n\tcase PRINT_VALUE:\n\tcase PRINT_BI:\n\tcase PRINT_RECENT_SET:\n\tcase PRINT_REPORT:\n\t\tbreak;\n\t\t\n\tdefault:\n\t\tif (0 == lcdSetInit(lcd))\n\t\t{\n\t\t\tlcdSetInitGroups(lcd->setting);\n\n\t\t\t// 初始化将要显示的定值组\n\t\t\tlcdPrintSetFindGroup(page, par->lcd->p_focus_menu->abbr);\n\n\t\t\t// 如果未找到设备参数定值组\n\t\t\tif (-1 == page->set_group)\n\t\t\t{\n\t\t\t\tlcdMsgbox(lcd, LCD_TRANSLATE_STRING(\"SET_GROUP_FAILED\"));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tp_grp = getDevSettingGrp(page->set_group);\n\t\t\tif (NULL == p_grp)\n\t\t\t{\n\t\t\t\tlcdMsgbox(lcd, LCD_TRANSLATE_STRING(\"SET_GROUP_FAILED\"));\n\t\t\t\treturn;\n\n\t\t\t}\n\t\t\telse if (p_grp->section_num > 1)\n\t\t\t{\n\t\t\t\t// 该定值组有多区\n\t\t\t\tpage->has_zone = 1;\n\t\t\t\tpage->need_zone = 1;\n\t\t\t\tlcdEditSetUint(&page->zone_edit, 1, p_grp->section_num, p_grps->cur_section);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpage->set_zone = 1;\n\t\t\t\tpage->has_zone = 0;\n\t\t\t\tpage->need_zone = 0;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n#ifdef LCD_PRINT_DEBUG\n\t\t\tLCD_TRACE(\"[lcd]: (_func_lcdOpPrintNormal) Set init failed!\\n\");\n#endif\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (page->rpt_num < 1)\n\t{\n\t\tlcdMsgbox(lcd, LCD_TRANSLATE_STRING(\"NONE\"));\n\t}\n\telse\n\t{\n\t\tlcdOpenPage((LcdPage *)page);\n\t}\n\t\n\treturn;\n}\n\n/*****************************************************************************\n * 函 数 名: lcdOpPrintCancel\n * 描    述: 打印取消\n * 调 用 者: lcdservice.c\n * 输    入: param为参数\n * 返 回 值: 无\n * 日    期: 2014-10-11\n * 修改记录:\n ****************************************************************************/\nvoid lcdOpPrintCancel(void* param)\n{\n\tLcdParamMenu *par = LCD_PARAM_MENU(param);\n\tLcdPagePrintCancel *page = LCD_NEW_DYNAMIC_PAGE(LcdPagePrintCancel, par->lcd);\n\n\tpage->show_func = lcdUiPrintCancelShow;\n\tpage->key_func = lcdUiPrintCancelKey;\n\tpage->timer_func = lcdUiPrintCancelTimer;\n\n\tlcdOpenPage((LcdPage *)page);\n\t\n\treturn;\n}\n\n/*****************************************************************************\n * 函 数 名: lcdOpPrintFaultInit\n * 描    述: 打印故障报告初始化\n * 调 用 者: lcdservice.c\n * 输    入: param为参数\n * 返 回 值: 无\n * 日    期: 2014-10-11\n * 修改记录:\n ****************************************************************************/\nvoid lcdOpPrintFaultInit(void* param)\n{\n\tLcdParamInit *par = LCD_PARAM_INIT(param);\n\tLcdPrintFaultInfo *p_info = NULL;\n\n\tlcdFaultRefInit(par->lcd, par->svr);\n\n\tp_info = LCD_NEW_CLASS(LcdPrintFaultInfo);\n\tif (NULL == p_info)\n\t{\n\t\tLCD_EXCEPTION(\"[lcd]: (_func_lcdOpPrintFaultInit) Create class failed!\");\n\t\treturn;\n\t}\n\n\tpar->svr->menu_param = p_info;\n\tif (par->svr->ref_num > 2)\n\t{\n\t\tlcdRefTableInitWithFunc(par->lcd, par->svr->refs[2], lcdPrintFaultRefFunc, p_info);\n\t\tp_info->ref = par->svr->refs[2];\n\t}\n\t\n\treturn;\n}\n\n/*****************************************************************************\n * 函 数 名: lcdOpPrintFault\n * 描    述: 打印故障报告\n * 调 用 者: lcdservice.c\n * 输    入: param为参数\n * 返 回 值: 无\n * 日    期: 2014-10-11\n * 修改记录:\n ****************************************************************************/\nvoid lcdOpPrintFault(void* param)\n{\n\tLcdParamMenu *par = LCD_PARAM_MENU(param);\n\tLcd *lcd = par->lcd;\n\tLcdPagePrintFault *page = LCD_NEW_DYNAMIC_PAGE(LcdPagePrintFault, lcd);\n\n\tif (0 != lcdUiCheckPrinterStatus(lcd))\n\t{\n#ifdef LCD_PRINT_DEBUG\n\t\tLCD_TRACE(\"[lcd]: (_func_lcdOpPrintFault) Printer status is uncorrect!\\n\");\n#endif\n\t\treturn;\n\t}\n\n\t// 页面初始化\n\tpage->show_func = lcdUiPrintFaultShow;\n\tpage->key_func = lcdUiPrintFaultKey;\n\tpage->p_fault = lcd->fault_report;\n\n\tif (PRINT_FAULT_RPT == par->p_svr->id)\n\t{\n\t\tpage->print_fault = 1;\n\t}\n\telse\n\t{\n\t\tpage->p_info = LCD_CLASS_CAST(LcdPrintFaultInfo, par->data);\n\t}\n\n\tlcdOpenPage((LcdPage *)page);\n\t\n\treturn;\n}\n\n// 本模块私有函数定义\n/* 检查打印机状态 */\nLOCAL INT8 lcdUiCheckPrinterStatus(Lcd *lcd)\n{\n\tif (*(lcd->print_offline_in))\n\t{\n\t\tlcdMsgbox(lcd, LCD_TRANSLATE_STRING(\"PRINTER_OFFLINE\"));\n\t\treturn 1;\n\t}\n\telse if (*(lcd->printing_in))\n\t{\n\t\tlcdMsgbox(lcd, LCD_TRANSLATE_STRING(\"PRINTER_BUSY\"));\n\t\treturn 2;\n\t}\n\n\treturn 0;\n}\n\n/* 一般打印页面显示函数 */\nLOCAL void lcdUiNormalPrintShow(void *param)\n{\n\tLcdParamShow *par = LCD_PARAM_SHOW(param);\n\tLcd *lcd = par->lcd;\n\tLcdPageNormalPrint *page = (LcdPageNormalPrint *)par->page;\n\n\tif (page->confirm < 1)\n\t{\n\t\tif (PRINT_ALL_SET == page->print_type)\n\t\t{\n\t\t\tlcdDrawText(52, 100, LCD_TRANSLATE_STRING(\"INPUT_SETNO\"), 0);\n\t\t\tlcdEditShow(&page->zone_edit, 240, 100, EDIT_FLAG_NORMAL);\n\t\t}\n\t\telse if (PRINT_SETTINGS == page->print_type)\n\t\t{\n\t\t\tif (page->need_zone)\n\t\t\t{\n\t\t\t\tlcdDrawText(52, 100, LCD_TRANSLATE_STRING(\"INPUT_SETNO\"), 0);\n\t\t\t\tlcdEditShow(&page->zone_edit, 240, 100, EDIT_FLAG_NORMAL);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlcdSetGroupShow(lcd, &page->set_group_show, &page->set_group_select);\n\t\t\t}\n\t\t}\n\t\telse if((PRINT_EQUIP == page->print_type) || (PRINT_VALUE == page->print_type) ||\n\t\t\t(PRINT_BI == page->print_type) || (PRINT_RECENT_SET == page->print_type) ||\n\t\t\t(PRINT_REPORT == page->print_type))\n\t\t{\n\t\t\tlcdMsgboxShow(LCD_TRANSLATE_STRING(\"PRINT_CONFIRM\"));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (page->need_zone)\n\t\t\t{\n\t\t\t\tlcdDrawText(52, 100, LCD_TRANSLATE_STRING(\"INPUT_SETNO\"), 0);\n\t\t\t\tlcdEditShow(&page->zone_edit, 240, 100, EDIT_FLAG_NORMAL);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlcdMsgboxShow(LCD_TRANSLATE_STRING(\"PRINT_CONFIRM\"));\n\t\t\t}\n\t\t}\n\t}\n\telse if (page->result < 0)\n\t{\n\t\tlcdMsgboxShow(LCD_TRANSLATE_STRING(\"PRINT_FAIL\"));\n\t}\n\telse if (page->result > 0)\n\t{\n\t\tlcdMsgboxShow(LCD_TRANSLATE_STRING(\"PRINT_OK\"));\n\t}\n\n\t// 状态栏显示\n\tlcdFrameShow(lcd, NULL, LCD_FRAME_NORMAL);\n\n\treturn;\n}\n/* 一般打印页面按键处理函数 */\nLOCAL void lcdUiNormalPrintKey(void *param)\n{\n\tLcdParamKey *par = LCD_PARAM_KEY(param);\n\tLcd *lcd = par->lcd;\n\tLcdPageNormalPrint *page = (LcdPageNormalPrint *)par->page;\n\tINT32 key = par->key;\n\tUINT32 val = 0;\n\tSettingGrps *p_grps = NULL;\n\tSettingGrp *p_set_grp = NULL;\n\tLcdRect rect = { 0 };\n\tLcdGrid ctrl = { 0 };\n\n\tif (page->confirm < 1)\n\t{\n\t\tif (PRINT_ALL_SET == page->print_type)\n\t\t{\n\t\t\tlcdEditKey(&page->zone_edit, key);\n\t\t\tif (LCD_KEY_ENTER == key)\n\t\t\t{\n\t\t\t\tlcdEditGetUint(&page->zone_edit, &val);\n\t\t\t\tpage->set_zone = (INT16)val;\n\t\t\t\tif (page->set_zone >= 1)\n\t\t\t\t{\n\t\t\t\t\tlcdUiNormalPrintExecute(page);\n\t\t\t\t}\n\t\t\t\tpage->confirm = 1;\n\t\t\t\tlcdRedraw();\n\t\t\t}\n\t\t}\n\t\telse if (PRINT_SETTINGS == page->print_type)\n\t\t{\n\t\t\tif (page->need_zone)\n\t\t\t{\n\t\t\t\tlcdEditKey(&page->zone_edit, key);\n\t\t\t\tif (LCD_KEY_ENTER == key)\n\t\t\t\t{\n\t\t\t\t\tlcdEditGetUint(&page->zone_edit, &val);\n\t\t\t\t\tpage->set_zone = (INT16)val;\n\t\t\t\t\tif (page->set_zone >= 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tlcdUiNormalPrintExecute(page);\n\t\t\t\t\t}\n\t\t\t\t\tpage->confirm = 1;\n\t\t\t\t\tlcdRedraw();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// GRID控件按键处理\n\t\t\t\tlcdClientRect(&rect, LCD_FRAME_NORMAL);\n\t\t\t\tlcdGridInit(&ctrl, &rect, lcd->setting->show_grp_num, GRID_SELECT);\n\t\t\t\tctrl.show_row = page->set_group_show;\n\t\t\t\tctrl.select_row = page->set_group_select;\n\t\t\t\tlcdGridKey(&ctrl, key);\n\t\t\t\tpage->set_group_show = ctrl.show_row;\n\t\t\t\tpage->set_group_select = ctrl.select_row;\n\n\t\t\t\tif (LCD_KEY_ENTER == key)\n\t\t\t\t{\n\t\t\t\t\tpage->set_group = lcd->setting->p_set_grps.items[page->set_group_select];\n\t\t\t\t\tp_grps = getDevSettingGrps();\n\t\t\t\t\tp_set_grp = getDevSettingGrp(page->set_group);\n\n\t\t\t\t\tif (NULL == p_set_grp)\n\t\t\t\t\t{\n\t\t\t\t\t\tlcdClosePage((LcdPage *)page);\n\t\t\t\t\t\tlcdMsgbox(lcd, LCD_TRANSLATE_STRING(\"SET_GROUP_FAILED\"));\n\t\t\t\t\t}\n\t\t\t\t\telse if (p_set_grp->section_num > 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tpage->has_zone = 1;\n\t\t\t\t\t\tpage->need_zone = 1;\n\t\t\t\t\t\tlcdEditSetUint(&page->zone_edit, 1, p_set_grp->section_num, p_grps->cur_section);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tpage->set_zone = 1;\n\t\t\t\t\t\tpage->has_zone = 0;\n\t\t\t\t\t\tpage->need_zone = 0;\n\t\t\t\t\t\tlcdUiNormalPrintExecute(page);\n\t\t\t\t\t\tpage->confirm = 1;\n\t\t\t\t\t}\n\t\t\t\t\tlcdRedraw();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ((LCD_KEY_ENTER == key) && \n\t\t\t((PRINT_EQUIP == page->print_type) || (PRINT_VALUE == page->print_type) ||\n\t\t\t(PRINT_BI == page->print_type) || (PRINT_RECENT_SET == page->print_type) ||\n\t\t\t(PRINT_REPORT == page->print_type)))\n\t\t{\n\t\t\tif (PRINT_SETTINGS != page->print_type)\n\t\t\t{\n\t\t\t\tlcdUiNormalPrintExecute(page);\n\t\t\t}\n\t\t\tpage->confirm = 1;\n\t\t\tlcdRedraw();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (page->need_zone)\n\t\t\t{\n\t\t\t\tlcdEditKey(&page->zone_edit, key);\n\t\t\t\tif (LCD_KEY_ENTER == key)\n\t\t\t\t{\n\t\t\t\t\tlcdEditGetUint(&page->zone_edit, &val);\n\t\t\t\t\tpage->set_zone = (INT16)val;\n\t\t\t\t\tif (page->set_zone >= 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tlcdUiNormalPrintExecute(page);\n\t\t\t\t\t}\n\t\t\t\t\tpage->confirm = 1;\n\t\t\t\t\tlcdRedraw();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (LCD_KEY_ENTER == key)\n\t\t\t\t{\n\t\t\t\t\tlcdUiNormalPrintExecute(page);\n\t\t\t\t\tpage->confirm = 1;\n\t\t\t\t\tlcdRedraw();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (LCD_KEY_ESC == key)\n\t{\n\t\tlcdClosePage((LcdPage *)page);\n\t}\n\n\treturn;\n}\n\n/* 执行一般打印命令 */\nLOCAL void lcdUiNormalPrintExecute(LcdPageNormalPrint *page)\n{\n\tINT32 offset = 0;\n\tINT8 buf[16] = { 0 };\n\n\tswitch(page->print_type)\n\t{\n\tcase PRINT_EQUIP:\n\t\tpage->result = lcdUiSendPrintCmd(\"printIdentityNo\", 0, NULL, 0);\n\t\tbreak;\n\n\tcase PRINT_VALUE:\n\t\tpage->result = lcdUiSendPrintCmd(\"printPresentValue\", 0, NULL, 0);\nprintf(\"[%s, %d]: printPresentValue\\n\", __FUNCTION__, __LINE__);\n\t\tbreak;\n\n\tcase PRINT_BI:\n\t\tpage->result = lcdUiSendPrintCmd(\"printBiValue\", 0, NULL, 0);\n\t\tbreak;\n\n\tcase PRINT_SETTINGS:\n\t\tbuf[0] = (INT8)page->set_zone;\n\t\tbuf[1] = (INT8)page->set_group;\n\t\tpage->result = lcdUiSendPrintCmd(\"printSettings\", 2, buf, 2);\n\t\tbreak;\n\n\tcase PRINT_ALL_SET:\n\t\tbuf[0] = (INT8)page->set_zone;\n\t\tbuf[1] = 0xff;\n\t\tpage->result = lcdUiSendPrintCmd(\"printSettings\", 2, buf, 2);\n\t\tbreak;\n\n\tcase PRINT_RECENT_SET:\n\t\tpage->result = lcdUiSendPrintCmd(\"printRecentModifySet\", 0, NULL, 0);\n\t\tbreak;\n\n\tcase PRINT_PROTOCOL:\n\t\tpage->result = lcdUiSendPrintCmd(\"printIec103Proto\", 0, NULL, 0);\n\t\tbreak;\n\n\tcase PRINT_TRIP_RPT:\n\t\tputInt16(buf, &offset, page->rpt_num);\n\t\tputInt32(buf, &offset, page->first_rpt);\n\t\tputInt32(buf, &offset, page->last_rpt);\n\t\tpage->result = lcdUiSendPrintCmd(\"printTripRpt\", 3, buf, 10);\nprintf(\"[%s, %d]: printTripRpt\\n\", __FUNCTION__, __LINE__);\n\t\tbreak;\n\n\tcase PRINT_RUN_RPT:\n\t\tputInt16(buf, &offset, page->rpt_num);\n\t\tputInt32(buf, &offset, page->first_rpt);\n\t\tputInt32(buf, &offset, page->last_rpt);\n\t\tpage->result = lcdUiSendPrintCmd(\"printRunRpt\", 3, buf, 10);\n\t\tbreak;\n\n\tcase PRINT_CHECK_RPT:\n\t\tputInt16(buf, &offset, page->rpt_num);\n\t\tputInt32(buf, &offset, page->first_rpt);\n\t\tputInt32(buf, &offset, page->last_rpt);\n\t\tpage->result = lcdUiSendPrintCmd(\"printSelfsupervRpt\", 3, buf, 10);\n\t\tbreak;\n\n\tcase PRINT_BIN_RPT:\n\t\tputInt16(buf, &offset, page->rpt_num);\n\t\tputInt32(buf, &offset, page->first_rpt);\n\t\tputInt32(buf, &offset, page->last_rpt);\n\t\tpage->result = lcdUiSendPrintCmd(\"printBinchgRpt\", 3, buf, 10);\n\t\tbreak;\n\t\t\n\tcase PRINT_SOE_RPT:\n\t\tputInt16(buf, &offset, page->rpt_num);\n\t\tputInt32(buf, &offset, page->first_rpt);\n\t\tputInt32(buf, &offset, page->last_rpt);\n\t\tpage->result = lcdUiSendPrintCmd(\"printSoeRpt\", 3, buf, 10);\n\t\tbreak;\n\n\tcase PRINT_OP_RPT:\n\t\tputInt16(buf, &offset, page->rpt_num);\n\t\tputInt32(buf, &offset, page->first_rpt);\n\t\tputInt32(buf, &offset, page->last_rpt);\n\t\tpage->result = lcdUiSendPrintCmd(\"printOpRpt\", 3, buf, 10);\n\t\tbreak;\n\n\tcase PRINT_CHAN_A_SUPV:\n\tcase PRINT_CHAN_B_SUPV:\n\tcase PRINT_CHAN_C_SUPV:\n\tcase PRINT_CHAN_D_SUPV:\n\t\tputInt16(buf, &offset, page->rpt_num);\n\t\tputInt32(buf, &offset, page->first_rpt);\n\t\tputInt32(buf, &offset, page->last_rpt);\n\t\tbuf[10] = (INT8)page->rpt_type;\n\t\tpage->result = lcdUiSendPrintCmd(\"printChanSupervRpt\", 4, buf, 11);\n\t\tbreak;\n\n\tcase PRINT_CHAN_A_STAT:\n\tcase PRINT_CHAN_B_STAT:\n\tcase PRINT_CHAN_C_STAT:\n\tcase PRINT_CHAN_D_STAT:\n\t\tputInt16(buf, &offset, page->rpt_num);\n\t\tputInt32(buf, &offset, page->first_rpt);\n\t\tputInt32(buf, &offset, page->last_rpt);\n\t\tbuf[10] = (INT8)page->rpt_type;\n\t\tpage->result = lcdUiSendPrintCmd(\"printChanStatisticRpt\", 4, buf, 11);\n\t\tbreak;\n\n\tdefault:\n\t\tbuf[0] = (INT8)page->set_zone;\n\t\tbuf[1] = (INT8)page->set_group;\n\t\tpage->result = lcdUiSendPrintCmd(\"printSettings\", 2, buf, 2);\n\t\tbreak;\n\t}\n\n\treturn;\n}\n\n/* 发送打印命令 */\nLOCAL INT8 lcdUiSendPrintCmd(const INT8 *cmd, INT32 arg_num, INT8 *args, INT32 arg_len)\n{\n\nUINT8 i;\n\n\tLOCAL PrintShmContent print_cmd = { 0 };\n\nfor (i = 0; i < arg_len; i++)\n\tprintf(\"para[%d] = %#x\\n\", i, args[i]);\n\n\tLCD_STRCPY(print_cmd.print_cmd_str, cmd);\n\tprint_cmd.print_para_num = (UINT8)arg_num;\n\n\tif ((NULL != args) && (arg_len > 0))\n\t{\n\t\tmemcpy(print_cmd.print_para_val, args, arg_len);\n\t}\n\n\tprint_cmd.print_para_num2 = 0;\n\n\treturn ((0 == writePrintShmCmd(&print_cmd)) ? 1 : -1);\n}\n\n/* 打印取消页面显示函数 */\nLOCAL void lcdUiPrintCancelShow(void *param)\n{\n\tLcdParamShow *par = LCD_PARAM_SHOW(param);\n\tLcd *lcd = par->lcd;\n\tLcdPagePrintCancel *page = (LcdPagePrintCancel *)par->page;\n\n\tif (page->confirm < 1)\n\t{\n\t\tlcdMsgboxShow(LCD_TRANSLATE_STRING(\"PRINT_CANCEL_CONFIRM\"));\n\t}\n\telse if (page->finish < 1)\n\t{\n\t\tlcdMsgboxShow(LCD_TRANSLATE_STRING(\"WAITING\"));\n\t}\n\telse\n\t{\n\t\tlcdMsgboxShow(LCD_TRANSLATE_STRING(\"WORK_SUCCEEDED\"));\n\t}\n\n\tlcdFrameShow(lcd, NULL, LCD_FRAME_NORMAL);\n\n\treturn;\n}\n\n/* 打印取消页面按键函数 */\nLOCAL void lcdUiPrintCancelKey(void *param)\n{\n\tLcdParamKey *par = LCD_PARAM_KEY(param);\n\tLcd *lcd = par->lcd;\n\tLcdPagePrintCancel *page = (LcdPagePrintCancel *)par->page;\n\tINT32 key = par->key;\n\n\tif (page->confirm < 1)\n\t{\n\t\tif (LCD_KEY_ESC == key)\n\t\t{\n\t\t\tlcdClosePage((LcdPage *)page);\n\t\t}\n\t\telse if (LCD_KEY_ENTER == key)\n\t\t{\n\t\t\tpage->confirm = 1;\n\t\t\tlcd->print_cancel_out = 1;\n\t\t\tlcd->key_locked = 1;\n\t\t\tlcdRedraw();\n\t\t}\n\t}\n\telse if (page->finish < 1)\n\t{\n\t}\n\telse\n\t{\n\t\tif ((LCD_KEY_ESC == key) || (LCD_KEY_ENTER == key))\n\t\t{\n\t\t\tlcdClosePage((LcdPage *)page);\n\t\t}\n\t}\n\n\treturn;\n}\n\n/* 打印取消页面定时事件 */\nLOCAL void lcdUiPrintCancelTimer(void *param)\n{\n\tLcdParamTimer *par = LCD_PARAM_TIMER(param);\n\tLcd *lcd = par->lcd;\n\tLcdPagePrintCancel *page = (LcdPagePrintCancel *)par->page;\n\n\tif ((page->confirm > 0) && (page->finish < 1))\n\t{\n\t\tif (0 == page->last_time)\n\t\t{\n\t\t\tpage->last_time = par->us;\n\t\t}\n\t\telse if (LCD_UINT32_SPAN(par->us, page->last_time) > 2000 * 1000)\n\t\t{\n\t\t\tpage->last_time = 0;\n\t\t\tpage->finish = 1;\n\t\t\tlcd->print_cancel_out = 0;\n\t\t\tlcd->key_locked = 0;\n\t\t\tlcdRedraw();\n\t\t}\n\t}\n\n\treturn;\n}\n\n/* 整组故障引用表回调函数 */\nLOCAL INT32 lcdPrintFaultRefFunc(INT32 i, LcdSplitStringList *lst, LcdRefTable *ref, void *param)\n{\n\tLcdPrintFaultInfo *p_info = LCD_CLASS_CAST(LcdPrintFaultInfo, param);\n\n\tif (NULL == p_info->list.items)\n\t{\n\t\tp_info->list.count = ref->item_num;\n\t\tp_info->list.items = LCD_NEW_ARRAY(INT8 *, p_info->list.count);\n\t\tif (NULL == p_info->list.items)\n\t\t{\n\t\t\tLCD_EXCEPTION(\"[lcd]: (_func_lcdPrintFaultRefFunc) New array err!\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tp_info->list.items[i] = LCD_NEW_STR(lst->item[0]);\n\tif (NULL == p_info->list.items[i])\n\t{\n\t\tLCD_EXCEPTION(\"[lcd]: (_func_lcdPrintFaultRefFunc) New string err!\");\n\t\treturn 2;\n\t}\n\n\treturn 0;\n}\n/* 打印整组故障页面显示函数 */\nLOCAL void lcdUiPrintFaultShow(void *param)\n{\n\tLcdParamShow *par = LCD_PARAM_SHOW(param);\n\tLcd *lcd = par->lcd;\n\tLcdPagePrintFault *page = (LcdPagePrintFault *)par->page;\n\tUINT16 num = 0;\n\tINT16 i = 0;\n\tINT8 *ptr = NULL;\n\tconst INT8 *p_str = NULL;\n\tHisEventReadCtrl read_ctrl = { 0 };\n\tLcdRect rect = { 0 };\n\tLcdGrid ctrl = { 0 };\n\n\tif (page->need_print)\n\t{\n\t\tptr = (INT8 *)lcdPullText(1, 0);\n\t\tfor (i = 0; i < LCD_ARRAY_NUM(page->print_args); i++)\n\t\t{\n\t\t\tptr += 2 * LCD_TEXT_COLNUM;\n\t\t\tLCD_STRCPY(ptr + 4, LCD_TRANSLATE_STRING(s_lcd_print_wave_args[i]));\n\n\t\t\tp_str = page->print_args[i] ? LCD_TRANSLATE_STRING(\"yes\") : LCD_TRANSLATE_STRING(\"no\");\n\t\t\tLCD_STRCPY(ptr + 30, p_str);\n\n\t\t\tif (i == page->print_arg_index)\n\t\t\t{\n\t\t\t\tlcdInvertText(i * 2 + 3, 30, LCD_STRLEN(p_str));\n\t\t\t}\n\t\t}\n\t}\n\telse if (page->need_classify)\n\t{\n\t\tptr = (INT8 *)lcdPullText(1, 0);\n\t\tfor (i = 0; i < 2; i++)\n\t\t{\n\t\t\tptr += 2 * LCD_TEXT_COLNUM;\n\t\t\tLCD_STRCPY(ptr + 13, LCD_TRANSLATE_STRING(s_lcd_print_trip_type[i]));\n\t\t\tp_str = LCD_TRANSLATE_STRING(s_lcd_print_trip_type[i]);\n\n\t\t\tif (i == page->print_arg_index2)\n\t\t\t{\n\t\t\t\tlcdInvertText(i * 2 + 3, 13, LCD_STRLEN(p_str));\n\t\t\t}\n\t\t}\n\t}\n\telse if (page->print_fault || page->need_fault)\n\t{\n\t\tnum = getHisFaultNum(&read_ctrl.start_no, &read_ctrl.last_no);\n\t\tif (0 == num)\n\t\t{\n\t\t\tlcdMsgboxShow(LCD_TRANSLATE_STRING(\"NONE\"));\n\t\t\tlcdFrameShow(lcd, NULL, LCD_FRAME_NORMAL);\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tread_ctrl.order = 1;\n\t\t\tread_ctrl.off = (UINT16)page->fault_index;\n\t\t\tif (0 != lcdFaultRead(&read_ctrl, page->p_fault))\n\t\t\t{\n\t\t\t\tlcdMsgboxShow(LCD_TRANSLATE_STRING(\"NONE\"));\n\t\t\t\tlcdFrameShow(lcd, NULL, LCD_FRAME_NORMAL);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlcdClientRect(&rect, LCD_FRAME_NORMAL);\n\t\t\t\tlcdFaultDraw(&rect, page->p_fault, page->show_fault_item);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (page->p_info->list.count > 0)\n\t\t{\n\t\t\tpage->p_info->valid_page_num = (INT8)lcdUiGetPrintValidPageNum(page);\n\t\t\tlcdClientRect(&rect, LCD_FRAME_NORMAL);\n\t\t\tlcdGridInit(&ctrl, &rect, page->p_info->valid_page_num, GRID_SELECT);\n\t\t\tctrl.show_row = page->show_grp;\n\t\t\tctrl.select_row = page->select_grp;\n\t\t\tlcdGridShow(&ctrl, lcdUiPrintFaultDrawGroup, page->p_info);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlcdMsgboxShow(LCD_TRANSLATE_STRING(\"NONE_CONFIG\"));\n\t\t}\n\t}\n\n\tif ((0 == page->print_fault) &&\n\t\t(page->need_fault || page->need_print) &&\n\t\t(page->p_info->list.count > 0) &&\n\t\t(page->print_wave_id < page->p_info->valid_page_num))\n\t{\n\t\tlcdFrameShow(lcd, LCD_FMTSTR(\"%s:%s\", lcdPageTitle(lcd), LCD_TRANSLATE_STRING(page->p_info->list.items[page->print_wave_id])), LCD_FRAME_NORMAL);\n\t}\n\telse\n\t{\n\t\tlcdFrameShow(lcd, NULL, LCD_FRAME_NORMAL);\n\t}\n\n\treturn;\n}\n\n/* 获取整组有效数目 */\nLOCAL INT32 lcdUiGetPrintValidPageNum(LcdPagePrintFault *page)\n{\n\tINT32 i = 0, num = 0;\n\tDataFields *p_datafield = NULL;\n\n\tfor (i = 0; i < page->p_info->list.count; i++)\n\t{\n\t\tif (page->p_info->ref->flag[i])\n\t\t{\n\t\t\tpage->p_info->print_page[num++] = i;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tp_datafield = page->p_info->ref->fields[i];\n\t\t\tif (DESC_LCD_VISIBLE(p_datafield))\n\t\t\t{\n\t\t\t\tpage->p_info->print_page[num++] = i;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn num;\n}\n\n/* 整组故障条目绘制 */\nLOCAL void lcdUiPrintFaultDrawGroup(INT16 x, INT16 y, INT16 row, INT16 col, void *param)\n{\n\tLcdPrintFaultInfo *p_info = LCD_CLASS_CAST(LcdPrintFaultInfo, param);\n\tINT8 *ptr = NULL;\n\n\tptr = (INT8 *)lcdPullTextPixel(x, y);\n\tLCD_STRCPY(ptr, LCD_TRANSLATE_STRING(p_info->list.items[p_info->print_page[row]]));\n\n\tif (col > 0)\n\t{\n\t}\n\n\treturn;\n}\n\n/* 打印整组故障页面按键函数 */\nLOCAL void lcdUiPrintFaultKey(void *param)\n{\n\tLcdParamKey *par = LCD_PARAM_KEY(param);\n\tLcd *lcd = par->lcd;\n\tINT32 key = par->key;\n\tLcdPagePrintFault *page = (LcdPagePrintFault *)par->page;\n\tUINT32 num = 0, start = 0, last = 0;\n\tLcdRect rect = { 0 };\n\tINT8 buf[16] = { 0 };\n\tLcdGrid ctrl = { 0 };\n\tINT32 i = 0;\n\n\tif (page->need_print)\n\t{\n\t\tif (LCD_KEY_DOWN == key)\n\t\t{\n\t\t\tif (page->print_arg_index < LCD_ARRAY_NUM(page->print_args) - 1)\n\t\t\t{\n\t\t\t\tpage->print_arg_index++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpage->print_arg_index = 0;\n\t\t\t}\n\t\t\tlcdRedraw();\n\t\t}\n\t\telse if (LCD_KEY_UP == key)\n\t\t{\n\t\t\tif (page->print_arg_index > 0)\n\t\t\t{\n\t\t\t\tpage->print_arg_index--;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpage->print_arg_index = LCD_ARRAY_NUM(page->print_args) - 1;\n\t\t\t}\n\n\t\t\tlcdRedraw();\n\t\t}\n\t\telse if ((LCD_KEY_ADD == key) || (LCD_KEY_SUB == key))\n\t\t{\n\t\t\tpage->print_args[page->print_arg_index] = page->print_args[page->print_arg_index] ? 0 : 1;\n\t\t\tlcdRedraw();\n\t\t}\n\t\telse if (LCD_KEY_ESC == key)\n\t\t{\n\t\t\tpage->need_print = 0;\n\t\t\tlcdRedraw();\n\t\t}\n\t\telse if (LCD_KEY_ENTER == key)\n\t\t{\n\t\t\tnum = 0;\n\t\t\tputInt16(buf, (INT32 *)&num, page->fault_index);\n\t\t\tbuf[2] = page->print_args[0];\n\t\t\tbuf[2] |= page->print_args[1] << 1;\n\t\t\tbuf[2] |= page->print_args[2] << 2;\n\t\t\tbuf[2] |= page->print_args[3] << 3;\n\t\t\t//buf[2] |= page->print_args[4] << 4;\n\t\t\tif ((page->p_info->list.count > 2) && (page->print_wave_id == page->p_info->list.count-1))\n\t\t\t{\n\t\t\t    for(i = 0; i < page->print_wave_id; i++)\n\t\t\t        buf[i+3] = i & 0x0f;\nprintf(\"[%s, %d]: will print Oscillogram\\n\", __FUNCTION__, __LINE__);\n\t\t\t\tpage->print_result = lcdUiSendPrintCmd(\"printOscillogram\", i+2, buf, i+3);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    buf[3] = page->print_wave_id & 0x0f;\nprintf(\"[%s, %d]: will print Oscillogram\\n\", __FUNCTION__, __LINE__);\n\t\t\t    page->print_result = lcdUiSendPrintCmd(\"printOscillogram\", 3, buf, 4);\n\t\t\t}\n\t\t\n\t\t\tif (page->print_result < 0)\n\t\t\t{\n\t\t\t\tlcdClosePage((LcdPage *)page);\n\t\t\t\tlcdMsgbox(lcd, LCD_TRANSLATE_STRING(\"PRINT_FAIL\"));\n\t\t\t}\n\t\t\telse if (page->print_result > 0)\n\t\t\t{\n\t\t\t\tlcdClosePage((LcdPage *)page);\n\t\t\t\tlcdMsgbox(lcd, LCD_TRANSLATE_STRING(\"PRINT_OK\"));\n\t\t\t}\n\t\t}\n\t}\n\telse if (page->need_classify)\n\t{\n\t\tif (LCD_KEY_DOWN == key)\n\t\t{\n\t\t\tif (page->print_arg_index2 == 0)\n\t\t\t{\n\t\t\t\tpage->print_arg_index2++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpage->print_arg_index2 = 0;\n\t\t\t}\n\t\t\tlcdRedraw();\n\t\t}\n\t\telse if (LCD_KEY_UP == key)\n\t\t{\n\t\t\tif (page->print_arg_index2 == 1)\n\t\t\t{\n\t\t\t\tpage->print_arg_index2--;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpage->print_arg_index2 = 1;\n\t\t\t}\n\n\t\t\tlcdRedraw();\n\t\t}\n\t\telse if ((LCD_KEY_ADD == key) || (LCD_KEY_SUB == key))\n\t\t{\n\t\t\tlcdRedraw();\n\t\t}\n\t\telse if (LCD_KEY_ESC == key)\n\t\t{\n\t\t\tpage->need_classify= 0;\n\t\t\tlcdRedraw();\n\t\t}\n\t\telse if (LCD_KEY_ENTER == key)\n\t\t{\n\t\t\tnum = 0;\n\t\t\tputInt16(buf, (INT32 *)&num, page->fault_index);\n\t\t\tif (page->print_arg_index2 == 0)\n\t\t\t\tpage->print_result = lcdUiSendPrintCmd(\"printDrawoffSimpleTripRpt\", 1, buf, 2);\n\t\t\telse\n\t\t\t{\n\t\t\t\t//modified by 王志超 on Feb 20, 2017， 根据U22六统一变压器要求\n\t\t\t\t//动作行为报告需包含启动前开入量状态和启动后开关量变位状态\n\t\t\t    // page->print_result = lcdUiSendPrintCmd(\"printDrawoffTripRpt\", 1, buf, 2);\n\t\t\t    buf[2] = 0x02;\t\t\t\t//只打印开入量的参数\n\t\t\t    page->print_result = lcdUiSendPrintCmd(\"printAllDrawoffTripRpt\", 3, buf, 4);\nprintf(\"[%s, %d]: printDrawoffTripRpt\\n\", __FUNCTION__, __LINE__);\n\t\t\t}\n\t\t\t\n\t\t\tif (page->print_result < 0)\n\t\t\t{\n\t\t\t\tlcdClosePage((LcdPage *)page);\n\t\t\t\tlcdMsgbox(lcd, LCD_TRANSLATE_STRING(\"PRINT_FAIL\"));\n\t\t\t}\n\t\t\telse if (page->print_result)\n\t\t\t{\n\t\t\t\tlcdClosePage((LcdPage *)page);\n\t\t\t\tlcdMsgbox(lcd, LCD_TRANSLATE_STRING(\"PRINT_OK\"));\n\t\t\t}\n\t\t}\n\t}\n\telse if (page->print_fault || page->need_fault)\n\t{\n\t\tswitch(key)\n\t\t{\n\t\tcase LCD_KEY_ADD:\n\t\tcase LCD_KEY_SUB:\n\t\t\tnum = getHisFaultNum(&start, &last);\n\t\t\tif (num > 0)\n\t\t\t{\n\t\t\t\tlcdClientRect(&rect, LCD_FRAME_NORMAL);\n\t\t\t\tlcdFaultKey(&rect, page->p_fault, key, &page->show_fault_item);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase LCD_KEY_DOWN:\n\t\t\tnum = getHisFaultNum(&start, &last);\n\t\t\tif (page->fault_index > 0)\n\t\t\t{\n\t\t\t\tpage->fault_index--;\n\t\t\t\tlcdRedraw();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpage->fault_index = (INT32)num - 1;\n\t\t\t\tlcdRedraw();\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase LCD_KEY_UP:\n\t\t\tnum = getHisFaultNum(&start, &last);\n\t\t\tif ((num > 0) && (page->fault_index < (INT32)num - 1))\n\t\t\t{\n\t\t\t\tpage->fault_index++;\n\t\t\t\tlcdRedraw();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpage->fault_index = 0;\n\t\t\t\tlcdRedraw();\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase LCD_KEY_ENTER:\n\t\t\tif (page->print_fault)\n\t\t\t{\n\t\t\t    page->need_classify= 1;\n\t\t\t\tlcdRedraw();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpage->need_print = 1;\n\t\t\t\tlcdRedraw();\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase LCD_KEY_ESC:\n\t\t\tif (page->print_fault)\n\t\t\t{\n\t\t\t\tlcdClosePage((LcdPage *)page);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpage->need_fault = 0;\n\t\t\t\tlcdRedraw();\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (page->p_info->list.count > 0)\n\t\t{\n\t\t\tlcdClientRect(&rect, LCD_FRAME_NORMAL);\n\t\t\tlcdGridInit(&ctrl, &rect, page->p_info->valid_page_num, GRID_SELECT);\n\t\t\tctrl.show_row = page->show_grp;\n\t\t\tctrl.select_row = page->select_grp;\n\t\t\tlcdGridKey(&ctrl, key);\n\t\t\tpage->show_grp = ctrl.show_row;\n\t\t\tpage->select_grp = ctrl.select_row;\n\n\t\t\tif (LCD_KEY_ENTER == key)\n\t\t\t{\n\t\t\t\tpage->print_wave_id = (INT8)page->p_info->print_page[ctrl.select_row];\n\t\t\t\tpage->need_fault = 1;\n\t\t\t\tlcdRedraw();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlcdUiNormalKey(param);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlcdUiNormalKey(param);\n\n\t\t}\n\t}\n\t\n\treturn;\n}\n\n/* 根据描述找到特定的定值组 */\nLOCAL void lcdPrintSetFindGroup(LcdPageNormalPrint *set, const INT8 *desc)\n{\n\tSettingGrps *p_setting_grps = getDevSettingGrps();\n\tSettingGrp *p_grp = NULL;\n\tDataFields *p_datafield = NULL;\n\tINT32 i = 0, j = 0, show_grp_num = 0, show_item_num = 0;\n\n\tfor (i = 0; i < p_setting_grps->group_num; i++)\n\t{\n\t\tp_grp = getDevSettingGrp(i);\n\n\t\t// 定值组为空\n\t\tif (NULL == p_grp)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (0 == strcmp(p_grp->name, desc))\n\t\t{\n\t\t\tset->set_group = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == p_setting_grps->group_num)\n\t{\n\t\tLCD_TRACE1(\"[lcd]: (_func_lcdPrintSetFindGroup) Can't find grp %s!\\n\", desc);\n\t\tset->set_group = -1;\n\t}\n\n\treturn;\n}",
					"file": "sy.src/sy.hmi/lcd/src/lcdprinter.c",
					"file_size": 32678,
					"file_write_time": 131320628067980544,
					"settings":
					{
						"buffer_size": 30586,
						"encoding": "Western (Windows 1252)",
						"line_ending": "Windows",
						"scratch": true
					}
				},
				{
					"contents": "/*==========================================================================*\n * 文件模块说明: PRINT模块打印业务处理函数\t\t\t\t\t\t\t\t\t*\n * 文件版本: V 1.00\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t*\n * 开发人员: 戴刚\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t*\n * 创建时间: 2015-01-19\t\t\t\t\t\t\t\t\t\t\t\t\t\t*\n * Copyright(c) 1993-2015 Shanghai SHR Electrical Power Technology Co. Ltd. *\n *==========================================================================*\n * 程序修改记录:\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t*\n *==========================================================================*/\n\n#include \"printsvr.h\"\n#include \"print.h\"\n#include \"printglobal.h\"\n\n// 本模块引用外部模块函数及变量声明\nEXTERN void sysGetUniqueId(INT8 *str);\n\n\n// 本模块私有结构体定义\n/* 语言描述结构体 */\ntypedef struct _print_lang_desc\n{\n\tINT8 desc[3][NAME_STRING_LEN];\n} PrintLangDesc;\n\ntypedef struct _print_translate_str\n{\n\tPrintLangDesc *p_lang_desc;\n\tINT8 *p_abbr_str;\n} PrintTranslateStr;\n\n/* 打印功能函数结构体 */\ntypedef struct _print_fun_str\n{\n\tPrintFunPtr func;\t\t\t\t\t// 功能函数指针\n\tINT8 *print_fun_name;\t\t\t\t// 功能函数名称\n} PrintFunStr;\n\n// 本模块私有函数声明\n/* 在表格空格中加入描述 */\nLOCAL INT32 printTabAddDesc(INT8 *dst, const INT8 *src, INT32 len);\nLOCAL INT32 zero_scale_line;\t\t\t//用以计算0ms时标所对应行数，added by wzc\n/* 打印标识 */\nLOCAL void printIdentityNo(Print *cp);\n\nLOCAL void printIdentityNoUart(Print *cp);\n\nLOCAL void printIdentityNoNet(Print *cp);\n\n/* 打印当前值 */\nLOCAL void printPresentValue(Print *cp);\n\nLOCAL void printPresentValueUart(Print *cp);\n\nLOCAL void printPresentValueNet(Print *cp);\n\n/* 打印开关量及压板状态 */\nLOCAL void printBiValue(Print *cp);\n\nLOCAL void printBiValueUart(Print *cp);\n\nLOCAL void printBiValueNet(Print *cp);\n\n/* 打印定值 */\nLOCAL void printSettings(Print *cp);\n\nLOCAL void printSettingsUart(Print *cp);\n\nLOCAL void printSettingsNet(Print *cp);\n\n/* 打印一组普通定值 */\nLOCAL void printOneGrpSettings(Print *cp, UINT16 grp_index, UINT16 section_index);\n\n/* 打印一组跳闸矩阵定值 */\nLOCAL void printOneGrpSettingMatrixes(Print *cp, UINT16 grp_index, UINT16 section_index);\n\n/* 打印跳闸矩阵描述 */\nLOCAL void printMatrixDesc(Print *cp);\n\n/* 打印最近修改定值 */\nLOCAL void printRecentModifySet(Print *cp);\n\nLOCAL void printRecentModifySetUart(Print *cp);\n\nLOCAL void printRecentModifySetNet(Print *cp);\n\n/* 打印运行报告 */\nLOCAL void printRunRpt(Print *cp);\n\nLOCAL void printRunRptUart(Print *cp);\n\nLOCAL void printRunRptNet(Print *cp);\n\nLOCAL void printRunRptItem(Print *cp, EventData *p_data);\n\n/* 打印动作报告 */\nLOCAL void printTripRpt(Print *cp);\n\nLOCAL void printTripRptUart(Print *cp);\n\nLOCAL void printTripRptNet(Print *cp);\n\nLOCAL void printRptItem(Print *cp, EventData *p_data);\n\n/* 打印动作信息报告 */\nLOCAL void printDrawoffSimpleTripRpt(Print *cp);\n\nLOCAL void printDrawoffSimpleTripRptUart(Print *cp);\n\nLOCAL void printDrawoffSimpleTripRptNet(Print *cp);\n\nLOCAL void printDrawoffSimpleTripRptItem(Print *cp);\n\nLOCAL void printDrawoffSimpleTripRptItemUart(Print *cp);\n\n/* 打印整组报告 */\n//added by 王志超 on Feb 20， 2017， 包含启动前开入量状态和启动后开关量变位状态的整组报告\nLOCAL void printAllDrawoffTripRpt(Print *cp);\n\nLOCAL void printDrawoffTripRpt(Print *cp);\n\nLOCAL void printDrawoffTripRptUart(Print *cp);\n\nLOCAL void printDrawoffTripRptNet(Print *cp);\n\n/* 打印整组报告条目 */\nLOCAL void printDrawoffTripRptItem(Print *cp);\n\nLOCAL void printDrawoffTripRptItemUart(Print *cp);\n\n/* 打印启动自检状态 */\nLOCAL void printEventInitState(Print *cp);\n\n/* 打印启动变位状态 */\nLOCAL void printEventChangeState(Print *cp);\n\nLOCAL void printEventInitStateItem(Print *cp, PrintRefTblCfg *p_ref_tbl_cfg);\n\nLOCAL void printEventChangeStateItem(Print *cp, NoParaEvent *p_event_rpt, UINT16 changed_num, PrintRefTblCfg *p_ref_tbl_cfg);\n\n/* 打印整组报告、波形、定值等 */\nLOCAL void printOscillogram(Print *cp);\n\nLOCAL void printOscillogramUart(Print *cp);\n\nLOCAL void printOscillogramNet(Print *cp);\n\n/* 打印波形采样值 */\nLOCAL void printWaveSmplUart(Print *cp);\n\n/* 打印波形 */\nLOCAL void printWaveNof(Print *cp);\n\nLOCAL void printWaveNofUart(Print *cp);\n\n/* 打印无波形页 */\nLOCAL void printNoSpecificWavePage(Print *cp);\n\nLOCAL void printNoSpecificWavePageUart(Print *cp);\n\n/* 计算打印波形相关参数 */\nLOCAL INT32 printCalcWaveParameter(Print *cp);\n\nLOCAL INT32 printCalcWaveParameterUart(Print *cp);\n\n/* 打印波形标度 */\nLOCAL INT32 printWaveScale(Print *cp);\n\nLOCAL INT32 printWaveScaleUart(Print *cp);\n\n/* 打印数字量描述 */\nLOCAL void printPulseDescrip(Print *cp);\n\nLOCAL void printPulseDescripUart(Print *cp);\n\n/* 打印模拟量描述 */\nLOCAL void printAnalogDescrip(Print *cp);\n\nLOCAL void printAnalogDescripUart(Print *cp);\n\n/* 打印相对时间描述 */\nLOCAL void printRetTimeDescrip(Print *cp);\n\n/* 打印波形头 */\nLOCAL void printWaveHead(Print *cp);\n\nLOCAL void printWaveHeadUart(Print *cp);\n\n/* 打印波形数据 */\nLOCAL void printWaveForm(Print *cp);\n\nLOCAL void printWaveFormUart(Print *cp);\n\nLOCAL void setWaveAxis(Print *cp,UINT32 wave_frequency);\n\nLOCAL INT32 setTripPulse(Print *cp,UINT32 frequency,UINT8 fan_index,\n\t UINT16 print_line_index,INT32 print_dot_num);\n\nLOCAL void processTripPulse(Print *cp,UINT32 frequency,UINT8 fan_index,\n\tUINT16 print_line_index,UINT8 lit_line_index);\n\nLOCAL void setWaveInstant(Print *cp,UINT8 fan_index,UINT16 print_line_index,\n\tINT32 print_dot_num,INT32 fan_print_line_num);\n\nLOCAL void setWaveAmplitude(Print *cp,UINT8 fan_index,UINT16 print_line_index,INT32 print_dot_num);\n\nLOCAL void setWaveDotAxis(Print *cp,UINT8 end_line);\n\n/* 打印瞬时值波形分割线 */\nLOCAL void printSetWaveAxis(Print *cp, UINT32 wave_frequency);\n\n/* 打印数字量 */\nLOCAL INT32 printTripPulse(Print *cp, UINT32 frequency, UINT8 fan_index);\n\nLOCAL void printProcessTripPulse(Print *cp, UINT32 frequency, UINT8 fan_index, UINT8 lit_line_index);\n\n/* 打印瞬时值 */\nLOCAL void printWaveAmpInstant(Print *cp, UINT8 fan_index, INT32 print_line);\n\n/* 打印幅值 */\nLOCAL void printWaveAmplitude(Print *cp, UINT8 fan_index, INT32 print_line);\n\n/* 打印波形尾延长线 */\nLOCAL void printSetWaveDotAxis(Print *cp, UINT8 end_line);\n\n/* 打印自检报告 */\nLOCAL void printSelfsupervRpt(Print *cp);\n\nLOCAL void printSelfsupervRptUart(Print *cp);\n\nLOCAL void printSelfsupervRptNet(Print *cp);\n\nLOCAL void printSelfsupervRptItem(Print *cp, EventData *p_data);\n\n/* 打印变位报告 */\nLOCAL void printBinchgRpt(Print *cp);\n\nLOCAL void printBinchgRptUart(Print *cp);\n\nLOCAL void printBinchgRptNet(Print *cp);\n\nLOCAL void printBinchgRptItem(Print *cp, EventData *p_data);\n\n/* 打印SOE报告 */\nLOCAL void printSoeRpt(Print *cp);\n\nLOCAL void printSoeRptUart(Print *cp);\n\nLOCAL void printSoeRptNet(Print *cp);\n\nLOCAL void printSoeRptItem(Print *cp, EventData *p_data);\n\n/* 打印通道自检报告 */\nLOCAL void printChanSupervRpt(Print *cp);\n\nLOCAL void printChanSupervRptUart(Print *cp);\n\nLOCAL void printChanSupervRptNet(Print *cp);\n\nLOCAL void printChanSupervRptItem(Print *cp, EventData *p_data, INT8 chan_index);\n\n/* 打印通道统计报告 */\nLOCAL void printChanStatisRpt(Print *cp);\n\nLOCAL void printChanStatisRptUart(Print *cp);\n\nLOCAL void printChanStatisRptNet(Print *cp);\n\nLOCAL void printChanStatisticRptItem(Print *cp, EventData *p_data, EventData *p_data_pre, INT8 chan_index, INT8 unfirst_rpt);\n\nLOCAL void printChanStatisticRptItemNet(Print *cp, EventData *p_data, EventData *p_data_pre, INT8 chan_index, INT8 unfirst_rpt);\n\n/* 打印103规约 */\nLOCAL void printIec103Proto(Print *cp);\n\nLOCAL void printIec103ProtoUart(Print *cp);\n\nLOCAL void printIec103ProtoNet(Print *cp);\n\n/* 打印操作报告 */\nLOCAL void printOpRpt(Print *cp);\n\nLOCAL void printOpRptUart(Print *cp);\n\nLOCAL void printOpRptNet(Print *cp);\n\nLOCAL void printOneOpRpt(Print *cp, EventData *p_data);\n\nLOCAL void printOneOpRptNet(Print *cp, EventData *p_data);\n\n/* 打印信息头 */\nLOCAL void printHeaderLineUart(Print *cp, INT8 *header_str);\n\nLOCAL void printHeaderLineNet(Print *cp, INT8 *header_str);\n\n/* 将内容拷贝进打印缓存 */\nLOCAL void printAddStrToBuf(Print *cp, const INT8 *string);\n\nLOCAL void printAddStrToBufAndModifyPtr(Print *cp, const INT8 *string, INT32 offset);\n\n/* 打印字符串 */\nLOCAL void printStrLine(Print *cp, const INT8 *string, INT8 if_return);\n\n/* 格式化字符串 */\nLOCAL INT32 printInvarFormatToBuffer(DataFields* p_datafield, InVar* p_invar, INT8 *p_buffer_left, INT8 *p_buffer_right, INT8 prim_or_second);\n\nLOCAL INT32 printGetFormatbValue(DataFields *p_datafield);\n\nLOCAL INT32 printSetValueFormatToBuffer(DataFields* p_datafield, SettingValue* p_value, INT8* p_buffer_left, INT8* p_buffer_right);\n\nLOCAL INT32 printCheckFormatString(const INT8 *p_format);\n\n/* 获取波形数据 */\nLOCAL INT32 printGetWaveFile(Print *cp);\n\n/* 分配波形所需数据空间 */\nLOCAL INT32 printMallocWaveHeap(Print *cp);\n\n/* 释放波形数据所需空间 */\nLOCAL INT32 printFreeWaveHeap(Print *cp);\n\n/* 自动打印 */\nLOCAL void printAutoTripUart(Print *cp);\n\nLOCAL void printAutoTripNet(Print *cp);\n\nLOCAL void printAutoFaultUart(Print *cp);\n\nLOCAL void printAutoFaultNet(Print *cp);\n\nLOCAL void printAutoSelfsupervUart(Print *cp);\n\nLOCAL void printAutoSelfsupervNet(Print *cp);\n\nLOCAL void printAutoBinchgUart(Print *cp);\n\nLOCAL void printAutoBinchgNet(Print *cp);\n\n// 本模块私有变量定义\n/* 打印指针 */\nINT8 *s_local_ptr = NULL;\n\n/* 表格分隔线 */\nLOCAL const INT8 *print_char_tab1[][EN_LANGUAGE_TYPE_NUM] = \n{\n\t\"┃\", \"| \", \"| \",\n\t\"┃\", \"| \", \"| \"\n};\n\nLOCAL const INT8 *print_char_tab2[][EN_LANGUAGE_TYPE_NUM] = \n{ \n\t\"│\", \"| \", \"| \",\n\t\"│\", \"| \", \"| \"\n};\n\n/* 特殊符号 */\nLOCAL const INT8 *clear_to_set_str[][EN_LANGUAGE_TYPE_NUM] = \n{ \n\t\"0 → 1\", \"0 -> 1\", \"0 -> 1\",\n\t\"0 → 1\", \"0 -> 1\", \"0 -> 1\"\n};\n\nLOCAL const INT8 *set_to_clear_str[][EN_LANGUAGE_TYPE_NUM] = \n{ \n\t\"1 → 0\", \"1 -> 0\", \"1 -> 0\", \n\t\"1 → 0\", \"1 -> 0\", \"1 -> 0\"\n};\n\n/* 通用打印头信息 */\nLOCAL const INT8 *title_line_line[][EN_LANGUAGE_TYPE_NUM] = \n{\n\t\"━━━\", \"------\", \"------\",\n\t\"━━━\", \"------\", \"------\"\n};\n\nLOCAL const INT8 *title_line_tab0[][EN_LANGUAGE_TYPE_NUM] = \n{\n\t\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\",\n\t\"==================================================================================================================\",\n\t\"==================================================================================================================\",\n\t\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\",\n\t\"==================================================================================================================\",\n\t\"==================================================================================================================\"\n};\n\nLOCAL PrintLangDesc slan_print_time_str = { 0 };\nLOCAL PrintLangDesc slan_prog_ver_str = { 0 };\nLOCAL PrintLangDesc slan_subq_no_str = { 0 };\nLOCAL PrintLangDesc slan_develop_no_str = { 0 };\nLOCAL PrintLangDesc slan_device_addr = { 0 };\nLOCAL PrintLangDesc\tslan_fpga_ver = { 0 };\nLOCAL PrintLangDesc\tslan_fpga_time = { 0 };  \nLOCAL PrintLangDesc\tslan_fpga_crc = { 0 }; \n\n/* 打印装置信息 */\nLOCAL PrintLangDesc slan_manufacturer_str = { 0 };\nLOCAL PrintLangDesc slan_equip_desc_str = { 0 };\nLOCAL PrintLangDesc slan_serial_no_str = { 0 };\nLOCAL PrintLangDesc slan_desc_str = { 0 };\nLOCAL PrintLangDesc slan_actual_value_str = { 0 };\nLOCAL PrintLangDesc slan_equip_name = { 0 };\nLOCAL PrintLangDesc slan_equip_type = { 0 };\nLOCAL PrintLangDesc slan_prog_time = { 0 };\nLOCAL PrintLangDesc slan_prog_chksum = { 0 };\nLOCAL PrintLangDesc slan_dev_icd_crc = { 0 };\nLOCAL PrintLangDesc slan_dev_scd_crc = { 0 };\nLOCAL PrintLangDesc slan_dev_id = { 0 };\nLOCAL PrintLangDesc slan_dev_unique = { 0 };\n\nLOCAL const INT8 *identity_no_line_tab0[][EN_LANGUAGE_TYPE_NUM] = \n{\n\t\"┏━━┯━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\",\n\t\"*=====*=========================================================================================================* \",\n\t\"*=====*=========================================================================================================* \",\n\t\"┏━━┯━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\",\n\t\"*=====*=========================================================================================================* \",\n\t\"*=====*=========================================================================================================* \"\n};\n\nLOCAL INT8 *identity_no_line_tab1[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┃    │                                                          :                                             ┃\",\n\t\"|     |                                                           :                                             | \",\n\t\"|     |                                                           :                                             | \",\n\t\"┃    │                                                          :                                             ┃\",\n\t\"|     |                                                           :                                             | \",\n\t\"|     |                                                           :                                             | \"\n};\n\nLOCAL const INT8 *identity_no_line_tab2[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┠──┼────────────────────────────────────────────────────┨\",\n\t\"|-----|---------------------------------------------------------------------------------------------------------| \",\n\t\"|-----|---------------------------------------------------------------------------------------------------------| \",\n\t\"┠──┼────────────────────────────────────────────────────┨\",\n\t\"|-----|---------------------------------------------------------------------------------------------------------| \",\n\t\"|-----|---------------------------------------------------------------------------------------------------------| \"\n};\n\nLOCAL const INT8 *identity_no_line_tab3[][EN_LANGUAGE_TYPE_NUM] = \n{\n\t\"┗━━┷━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\",\n\t\"*=====*=========================================================================================================* \",\n\t\"*=====*=========================================================================================================* \",\n\t\"┗━━┷━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\",\n\t\"*=====*=========================================================================================================* \",\n\t\"*=====*=========================================================================================================* \"\n};\n\n/* 打印当前值 */\nLOCAL PrintLangDesc slan_prim_value_str = { 0 };\nLOCAL PrintLangDesc slan_second_value_str = { 0 };\nLOCAL PrintLangDesc slan_quality_value_str = { 0 };\nLOCAL PrintLangDesc slan_bi_value_str = { 0 };\n\nLOCAL const INT8 *present_value_line_tab0[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┏━━┯━━━━━━━━━━━━━━━━━━━━━━━━┯━━┯━━━━━━━━━━━━━━━━━━━━━━━━┓\",\n\t\"*-----*-------------------------------------------------*-----*-------------------------------------------------* \",\n\t\"*-----*-------------------------------------------------*-----*-------------------------------------------------* \",\n\t\"┏━━┯━━━━━━━━━━━━━━━━━━━━━━━━┯━━┯━━━━━━━━━━━━━━━━━━━━━━━━┓\",\n\t\"*-----*-------------------------------------------------*-----*-------------------------------------------------* \",\n\t\"*-----*-------------------------------------------------*-----*-------------------------------------------------* \"\n};\n\nLOCAL INT8 *present_value_line_tab1[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┃    │                                 :              │    │                                 :              ┃\",\n\t\"|     |                                  :              |     |                                  :              | \",\n\t\"|     |                                  :              |     |                                  :              | \",\n\t\"┃    │                                 :              │    │                                 :              ┃\",\n\t\"|     |                                  :              |     |                                  :              | \",\n\t\"|     |                                  :              |     |                                  :              | \"\n};\n\nLOCAL INT8 *present_value_line_tab1a[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┃    │                            :              :    │    │                            :              :    ┃\",\n\t\"|     |                             :              :    |     |                             :              :    | \",\n\t\"|     |                             :              :    |     |                             :              :    | \",\n\t\"┃    │                            :              :    │    │                            :              :    ┃\",\n\t\"|     |                             :              :    |     |                             :              :    | \",\n\t\"|     |                             :              :    |     |                             :              :    | \"\n};\n\nLOCAL const INT8 *present_value_line_tab2[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┠──┼────────────────────────┼──┼────────────────────────┨\",\n\t\"|-----|-------------------------------------------------|-----|-------------------------------------------------| \",\n\t\"|-----|-------------------------------------------------|-----|-------------------------------------------------| \",\n\t\"┠──┼────────────────────────┼──┼────────────────────────┨\",\n\t\"|-----|-------------------------------------------------|-----|-------------------------------------------------| \",\n\t\"|-----|-------------------------------------------------|-----|-------------------------------------------------| \"\n};\n\nLOCAL const INT8 *present_value_line_tab3[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┗━━┷━━━━━━━━━━━━━━━━━━━━━━━━┷━━┷━━━━━━━━━━━━━━━━━━━━━━━━┛\",\n\t\"*-----*-------------------------------------------------*-----*-------------------------------------------------* \",\n\t\"*-----*-------------------------------------------------*-----*-------------------------------------------------* \",\n\t\"┗━━┷━━━━━━━━━━━━━━━━━━━━━━━━┷━━┷━━━━━━━━━━━━━━━━━━━━━━━━┛\",\n\t\"*-----*-------------------------------------------------*-----*-------------------------------------------------* \",\n\t\"*-----*-------------------------------------------------*-----*-------------------------------------------------* \"\n};\n\n/* 打印一组定值 */\nLOCAL PrintLangDesc slan_active_section_str = { 0 };\nLOCAL PrintLangDesc slan_unactive_section_str = { 0 };\nLOCAL PrintLangDesc slan_set_control_bit_str = { 0 };\n\nLOCAL const INT8 *one_grp_settings_line_tab0[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┏━━┯━━━━━━━━━━━━━━━━━━━━━━━━┯━━┯━━━━━━━━━━━━━━━━━━━━━━━━┓\",\n\t\"*-----*-------------------------------------------------*-----*-------------------------------------------------* \",\n\t\"*-----*-------------------------------------------------*-----*-------------------------------------------------* \",\n\t\"┏━━┯━━━━━━━━━━━━━━━━━━━━━━━━┯━━┯━━━━━━━━━━━━━━━━━━━━━━━━┓\",\n\t\"*-----*-------------------------------------------------*-----*-------------------------------------------------* \",\n\t\"*-----*-------------------------------------------------*-----*-------------------------------------------------* \"\n};\n\nLOCAL const INT8 *one_grp_settings_line_tab2[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┠──┼────────────────────────┼──┼────────────────────────┨\",\n\t\"|-----|-------------------------------------------------|-----|-------------------------------------------------| \",\n\t\"|-----|-------------------------------------------------|-----|-------------------------------------------------| \",\n\t\"┠──┼────────────────────────┼──┼────────────────────────┨\",\n\t\"|-----|-------------------------------------------------|-----|-------------------------------------------------| \",\n\t\"|-----|-------------------------------------------------|-----|-------------------------------------------------| \"\n};\n\nLOCAL const INT8 *one_grp_settings_line_tab3[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┗━━┷━━━━━━━━━━━━━━━━━━━━━━━━┷━━┷━━━━━━━━━━━━━━━━━━━━━━━━┛\",\n\t\"*-----*-------------------------------------------------*-----*-------------------------------------------------* \",\n\t\"*-----*-------------------------------------------------*-----*-------------------------------------------------* \",\n\t\"┗━━┷━━━━━━━━━━━━━━━━━━━━━━━━┷━━┷━━━━━━━━━━━━━━━━━━━━━━━━┛\",\n\t\"*-----*-------------------------------------------------*-----*-------------------------------------------------* \",\n\t\"*-----*-------------------------------------------------*-----*-------------------------------------------------* \"\n};\n\nLOCAL const INT8 *one_grp_settings_line_tab4[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┠──┴────────────────────────┴──┴────────────────────────┨\",\n\t\"|-----*-------------------------------------------------*-----*-------------------------------------------------| \",\n\t\"|-----*-------------------------------------------------*-----*-------------------------------------------------| \",\n\t\"┠──┴────────────────────────┴──┴────────────────────────┨\",\n\t\"|-----*-------------------------------------------------*-----*-------------------------------------------------| \",\n\t\"|-----*-------------------------------------------------*-----*-------------------------------------------------| \"\n};\n\nLOCAL const INT8 *one_grp_settings_line_tab5[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┠──┬────────────────────────┬──┬────────────────────────┨\",\n\t\"|-----*-------------------------------------------------*-----*-------------------------------------------------| \",\n\t\"|-----*-------------------------------------------------*-----*-------------------------------------------------| \",\n\t\"┠──┬────────────────────────┬──┬────────────────────────┨\",\n\t\"|-----*-------------------------------------------------*-----*-------------------------------------------------| \",\n\t\"|-----*-------------------------------------------------*-----*-------------------------------------------------| \"\n};\n\n/* 打印跳闸矩阵 */\nLOCAL PrintLangDesc slan_matrix_desc_str = { 0 };\nLOCAL PrintLangDesc slan_matrix_bit_str = { 0 };\nLOCAL PrintLangDesc slan_matrix_setting_str = { 0 };\n\nLOCAL const INT8 *matrix_desc_line_tab0[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\",\n\t\"*---------------------------------------------------------------------------------------------------------------* \",\n\t\"*---------------------------------------------------------------------------------------------------------------* \",\n\t\"┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\",\n\t\"*---------------------------------------------------------------------------------------------------------------* \",\n\t\"*---------------------------------------------------------------------------------------------------------------* \"\n};\n\nLOCAL const INT8 *matrix_desc_line_tab1[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\",\n\t\"*---------------------------------------------------------------------------------------------------------------* \",\n\t\"*---------------------------------------------------------------------------------------------------------------* \",\n\t\"┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\",\n\t\"*---------------------------------------------------------------------------------------------------------------* \",\n\t\"*---------------------------------------------------------------------------------------------------------------* \"\n};\n\nLOCAL const INT8 *setting_matrix_line_tab3[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\",\n\t\"*---------------------------------------------------------------------------------------------------------------* \",\n\t\"*---------------------------------------------------------------------------------------------------------------* \",\n\t\"┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\",\n\t\"*---------------------------------------------------------------------------------------------------------------* \",\n\t\"*---------------------------------------------------------------------------------------------------------------* \"\n};\n\nLOCAL const INT8 *setting_matrix_line_tab4[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┃                                      ┃3 3 2 2│2 2 2 2│2 2 2 2│1 1 1 1┃1 1 1 1│1 1 0 0│0 0 0 0│0 0 0 0┃\",\n\t\"|                                       | 3 3 2 2| 2 2 2 2| 2 2 2 2| 1 1 1 1| 1 1 1 1| 1 1 0 0| 0 0 0 0| 0 0 0 0|\",\n\t\"|                                       | 3 3 2 2| 2 2 2 2| 2 2 2 2| 1 1 1 1| 1 1 1 1| 1 1 0 0| 0 0 0 0| 0 0 0 0|\",\n\t\"┃                                      ┃3 3 2 2│2 2 2 2│2 2 2 2│1 1 1 1┃1 1 1 1│1 1 0 0│0 0 0 0│0 0 0 0┃\",\n\t\"|                                       | 3 3 2 2| 2 2 2 2| 2 2 2 2| 1 1 1 1| 1 1 1 1| 1 1 0 0| 0 0 0 0| 0 0 0 0|\",\n\t\"|                                       | 3 3 2 2| 2 2 2 2| 2 2 2 2| 1 1 1 1| 1 1 1 1| 1 1 0 0| 0 0 0 0| 0 0 0 0|\"\n};\n\nLOCAL INT8 *setting_matrix_line_tab5[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┃                                      ┃1 0 9 8│7 6 5 4│3 2 1 0│9 8 7 6┃5 4 3 2│1 0 9 8│7 6 5 4│3 2 1 0┃\",\n\t\"|                                       | 1 0 9 8| 7 6 5 4| 3 2 1 0| 9 8 7 6| 5 4 3 2| 1 0 9 8| 7 6 5 4| 3 2 1 0|\",\n\t\"|                                       | 1 0 9 8| 7 6 5 4| 3 2 1 0| 9 8 7 6| 5 4 3 2| 1 0 9 8| 7 6 5 4| 3 2 1 0|\",\n\t\"┃                                      ┃1 0 9 8│7 6 5 4│3 2 1 0│9 8 7 6┃5 4 3 2│1 0 9 8│7 6 5 4│3 2 1 0┃\",\n\t\"|                                       | 1 0 9 8| 7 6 5 4| 3 2 1 0| 9 8 7 6| 5 4 3 2| 1 0 9 8| 7 6 5 4| 3 2 1 0|\",\n\t\"|                                       | 1 0 9 8| 7 6 5 4| 3 2 1 0| 9 8 7 6| 5 4 3 2| 1 0 9 8| 7 6 5 4| 3 2 1 0|\"\n};\n\nLOCAL const INT8 *setting_matrix_line_tab6[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┠───────────────────┨-------│-------│-------│-------┃-------│-------│-------│-------┃\",\n\t\"|---------------------------------------|--------|--------|--------|------- |--------|--------|--------|--------| \",\n\t\"|---------------------------------------|--------|--------|--------|------- |--------|--------|--------|--------| \",\n\t\"┠───────────────────┨-------│-------│-------│-------┃-------│-------│-------│-------┃\",\n\t\"|---------------------------------------|--------|--------|--------|------- |--------|--------|--------|--------| \",\n\t\"|---------------------------------------|--------|--------|--------|------- |--------|--------|--------|--------| \"\n};\n\nLOCAL const INT8 *setting_matrix_line_tab7[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\",\n\t\"*---------------------------------------------------------------------------------------------------------------* \",\n\t\"*---------------------------------------------------------------------------------------------------------------* \",\n\t\"┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\",\n\t\"*---------------------------------------------------------------------------------------------------------------* \",\n\t\"*---------------------------------------------------------------------------------------------------------------* \"\n};\n\n/* 打印最近修改定值 */\nLOCAL PrintLangDesc slan_latest_modify_header_str = { 0 };\nLOCAL PrintLangDesc slan_set_before_modify_str = { 0 };\nLOCAL PrintLangDesc slan_set_after_modify_str = { 0 };\nLOCAL PrintLangDesc slan_set_dimension_str = { 0 };\n\nLOCAL const INT8 *latest_modify_line_tab0[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┏━━┯━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\",\n\t\"*-----*---------------------------------------------------------------------------------------------------------* \",\n\t\"*-----*---------------------------------------------------------------------------------------------------------* \",\n\t\"┏━━┯━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\",\n\t\"*-----*---------------------------------------------------------------------------------------------------------* \",\n\t\"*-----*---------------------------------------------------------------------------------------------------------* \"\n};\n\nLOCAL INT8 *latest_modify_line_tab1[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┃    │                                          :                                                             ┃\",\n\t\"|     |                                           :                                                             | \",\n\t\"|     |                                           :                                                             | \",\n\t\"┃    │                                          :                                                             ┃\",\n\t\"|     |                                           :                                                             | \",\n\t\"|     |                                           :                                                             | \"\n};\n\nLOCAL const INT8 *latest_modify_line_tab2[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┠──┼────────────────────────────────────────────────────┨\",\n\t\"|-----|---------------------------------------------------------------------------------------------------------| \",\n\t\"|-----|---------------------------------------------------------------------------------------------------------| \",\n\t\"┠──┼────────────────────────────────────────────────────┨\",\n\t\"|-----|---------------------------------------------------------------------------------------------------------| \",\n\t\"|-----|---------------------------------------------------------------------------------------------------------| \"\n};\n\nLOCAL const INT8 *latest_modify_line_tab3[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┗━━┷━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\",\n\t\"*-----*---------------------------------------------------------------------------------------------------------* \",\n\t\"*-----*---------------------------------------------------------------------------------------------------------* \",\n\t\"┗━━┷━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\",\n\t\"*-----*---------------------------------------------------------------------------------------------------------* \",\n\t\"*-----*---------------------------------------------------------------------------------------------------------* \"\n};\n\n/* 打印条目报告 */\nLOCAL const INT8 *item_rpt_line_tab2[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┠────┼──────────────────┼─────────────────────────┼─────┨\",\n\t\"|---------|-------------------------------------|---------------------------------------------------|-----------| \",\n\t\"|---------|-------------------------------------|---------------------------------------------------|-----------| \",\n\t\"┠────┼──────────────────┼─────────────────────────┼─────┨\",\n\t\"|---------|-------------------------------------|---------------------------------------------------|-----------| \",\n\t\"|---------|-------------------------------------|---------------------------------------------------|-----------| \"\n};\n\n/* 打印动作报告 */\nLOCAL PrintLangDesc slan_item_trip_rpt_header_str = { 0 };\nLOCAL PrintLangDesc slan_trip_time_str = { 0 };\nLOCAL PrintLangDesc slan_trip_element_str = { 0 };\nLOCAL PrintLangDesc slan_trip_value_str = { 0 };\nLOCAL PrintLangDesc slan_trip_phase_str = { 0 };\n\nLOCAL const INT8 *item_trip_rpt_line_tab0[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┏━━━━┯━━━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━━━━━━━━━┯━━━━━┓\",\n\t\"*---------*-------------------------------------*---------------------------------------------------*-----------* \",\n\t\"*---------*-------------------------------------*---------------------------------------------------*-----------* \",\n\t\"┏━━━━┯━━━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━━━━━━━━━┯━━━━━┓\",\n\t\"*---------*-------------------------------------*---------------------------------------------------*-----------* \",\n\t\"*---------*-------------------------------------*---------------------------------------------------*-----------* \"\n};\n\nLOCAL INT8 *item_trip_rpt_line_tab1[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┃        │                                    │                                                  │          ┃\",\n\t\"|         |                                     |                                                   |           | \",\n\t\"|         |                                     |                                                   |           | \",\n\t\"┃        │                                    │                                                  │          ┃\",\n\t\"|         |                                     |                                                   |           | \",\n\t\"|         |                                     |                                                   |           | \"\n};\n\nLOCAL const INT8 *item_trip_rtp_line_tab4[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┗━━━━┷━━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━━━━━━━━┷━━━━━┛\",\n\t\"*---------*-------------------------------------*---------------------------------------------------*-----------* \",\n\t\"*---------*-------------------------------------*---------------------------------------------------*-----------* \",\n\t\"┗━━━━┷━━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━━━━━━━━┷━━━━━┛\",\n\t\"*---------*-------------------------------------*---------------------------------------------------*-----------* \",\n\t\"*---------*-------------------------------------*---------------------------------------------------*-----------* \"\n};\n\n/* 打印整组报告 */\nLOCAL PrintLangDesc slan_drawoff_trip_rpt_header_str = { 0 };\nLOCAL PrintLangDesc slan_drawoff_simple_trip_rpt_header_str = { 0 };\nLOCAL PrintLangDesc slan_pickup_time_str = { 0 };\nLOCAL PrintLangDesc slan_relative_time_str = { 0 };\n\nLOCAL const INT8 *drawoff_trip_rpt_line_tab0[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┏━━━━┯━━━━━━━━━━━━━━┯━━━━━┯━━━━━┯━━━━━━━━━━━━━━━━━━━━━━━┓\",\n\t\"*---------*-----------------------------*-----------*-----------*-----------------------------------------------* \",\n\t\"*---------*-----------------------------*-----------*-----------*-----------------------------------------------* \",\n\t\"┏━━━━┯━━━━━━━━━━━━━━┯━━━━━┯━━━━━┯━━━━━━━━━━━━━━━━━━━━━━━┓\",\n\t\"*---------*-----------------------------*-----------*-----------*-----------------------------------------------* \",\n\t\"*---------*-----------------------------*-----------*-----------*-----------------------------------------------* \"\n};\n\nLOCAL INT8 *drawoff_trip_rpt_line_tab1[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┃        │                            │          │          │                                              ┃\",\n\t\"|         |                             |           |           |                                               | \",\n\t\"|         |                             |           |           |                                               | \",\n\t\"┃        │                            │          │          │                                              ┃\",\n\t\"|         |                             |           |           |                                               | \",\n\t\"|         |                             |           |           |                                               | \"\n};\n\nLOCAL const INT8 *drawoff_trip_rpt_line_tab2[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┠────┼──────────────┼─────┼─────┼───────────────────────┨\",\n\t\"|---------|-----------------------------|-----------|-----------|-----------------------------------------------| \",\n\t\"|---------|-----------------------------|-----------|-----------|-----------------------------------------------| \",\n\t\"┠────┼──────────────┼─────┼─────┼───────────────────────┨\",\n\t\"|---------|-----------------------------|-----------|-----------|-----------------------------------------------| \",\n\t\"|---------|-----------------------------|-----------|-----------|-----------------------------------------------| \"\n};\n\nLOCAL const INT8 *drawoff_trip_rpt_line_tab3[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┃        │                            ├─────┼─────┼───────────────────────┨\",\n\t\"|---------|                             |-----------|-----------|-----------------------------------------------| \",\n\t\"|---------|                             |-----------|-----------|-----------------------------------------------| \",\n\t\"┃        │                            ├─────┼─────┼───────────────────────┨\",\n\t\"|---------|                             |-----------|-----------|-----------------------------------------------| \",\n\t\"|---------|                             |-----------|-----------|-----------------------------------------------| \"\n};\n\nLOCAL const INT8 *drawoff_trip_rpt_line_tab3a[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┃        │                            ├─────┼─────┬───────────────────────┨\",\n\t\"|---------|                             |-----------|-----------|-----------------------------------------------| \",\n\t\"|---------|                             |-----------|-----------|-----------------------------------------------| \",\n\t\"┃        │                            ├─────┼─────┬───────────────────────┨\",\n\t\"|---------|                             |-----------|-----------|-----------------------------------------------| \",\n\t\"|---------|                             |-----------|-----------|-----------------------------------------------| \"\n};\n\nLOCAL const INT8 *drawoff_trip_rpt_line_tab4[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┃        │                            │          ├─────┴───────────────────────┨\",\n\t\"|---------|                             |           |-----------------------------------------------------------| \",\n\t\"|---------|                             |           |-----------------------------------------------------------| \",\n\t\"┃        │                            │          ├─────┴───────────────────────┨\",\n\t\"|---------|                             |           |-----------------------------------------------------------| \",\n\t\"|---------|                             |           |-----------------------------------------------------------| \"\n};\n\nLOCAL const INT8 *drawoff_trip_rpt_line_tab4a[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┃        │                            │          ├─────────────────────────────┨\",\n\t\"|---------|                             |           |-----------------------------------------------------------| \",\n\t\"|---------|                             |           |-----------------------------------------------------------| \",\n\t\"┃        │                            │          ├─────────────────────────────┨\",\n\t\"|---------|                             |           |-----------------------------------------------------------| \",\n\t\"|---------|                             |           |-----------------------------------------------------------| \"\n};\n\nLOCAL const INT8 *drawoff_trip_rpt_line_tab5[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┗━━━━┷━━━━━━━━━━━━━━┷━━━━━┷━━━━━┷━━━━━━━━━━━━━━━━━━━━━━━┛\",\n\t// 一次尝试\n\t// \"┠────┴──────────────┴─────┴─────┴───────────────────────┨\",\n\t\"|---------|-----------------------------|-----------|-----------|-----------------------------------------------| \",\n\t\"|---------|-----------------------------|-----------|-----------|-----------------------------------------------| \",\n\t\"┠────┴──────────────┴─────┴─────┴───────────────────────┨\",\n\t\"|---------|-----------------------------|-----------|-----------|-----------------------------------------------| \",\n\t\"|---------|-----------------------------|-----------|-----------|-----------------------------------------------| \"\n};\n\nLOCAL const INT8 *drawoff_trip_rpt_line_tab5a[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┠────┴──────────────┴─────┴─────────────────────────────┨\",\n\t\"|---------|-----------------------------|-----------|-----------------------------------------------------------| \",\n\t\"|---------|-----------------------------|-----------|-----------------------------------------------------------| \",\n\t\"┠────┴──────────────┴─────┴─────────────────────────────┨\",\n\t\"|---------|-----------------------------|-----------|-----------------------------------------------------------| \",\n\t\"|---------|-----------------------------|-----------|-----------------------------------------------------------| \"\n};\n\nLOCAL const INT8 *drawoff_trip_rpt_line_tab6[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\",\n\t\"*---------------------------------------------------------------------------------------------------------------* \",\n\t\"*---------------------------------------------------------------------------------------------------------------* \",\n\t\"┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\",\n\t\"*---------------------------------------------------------------------------------------------------------------* \",\n\t\"*---------------------------------------------------------------------------------------------------------------* \"\n};\n\n/* 打印初始化时事件 */\nLOCAL PrintLangDesc slan_selfcheck_init_state_str = { 0 };\nLOCAL PrintLangDesc slan_binchg_init_state_str = { 0 };\n\nLOCAL const INT8 *event_init_line_tab0[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┏━━┯━━━━━━━━━━━━━━━━━━━━━━━━┯━━┯━━━━━━━━━━━━━━━━━━━━━━━━┓\",\n\t\"*-----*-------------------------------------------------*-----*-------------------------------------------------* \",\n\t\"*-----*-------------------------------------------------*-----*-------------------------------------------------* \",\n\t\"┏━━┯━━━━━━━━━━━━━━━━━━━━━━━━┯━━┯━━━━━━━━━━━━━━━━━━━━━━━━┓\",\n\t\"*-----*-------------------------------------------------*-----*-------------------------------------------------* \",\n\t\"*-----*-------------------------------------------------*-----*-------------------------------------------------* \"\n};\n\nLOCAL INT8 *event_init_line_tab1[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┃    │                                       :        │    │                                       :        ┃\",\n\t\"|     |                                        :        |     |                                        :        | \",\n\t\"|     |                                        :        |     |                                        :        | \",\n\t\"┃    │                                       :        │    │                                       :        ┃\",\n\t\"|     |                                        :        |     |                                        :        | \",\n\t\"|     |                                        :        |     |                                        :        | \"\n};\n\nLOCAL const INT8 *event_init_line_tab2[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┠──┼────────────────────────┼──┼────────────────────────┨\",\n\t\"|-----|-------------------------------------------------|-----|-------------------------------------------------| \",\n\t\"|-----|-------------------------------------------------|-----|-------------------------------------------------| \",\n\t\"┠──┼────────────────────────┼──┼────────────────────────┨\",\n\t\"|-----|-------------------------------------------------|-----|-------------------------------------------------| \",\n\t\"|-----|-------------------------------------------------|-----|-------------------------------------------------| \"\n};\n\nLOCAL const INT8 *event_init_line_tab3[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┗━━┷━━━━━━━━━━━━━━━━━━━━━━━━┷━━┷━━━━━━━━━━━━━━━━━━━━━━━━┛\",\n\t\"*-----*-------------------------------------------------*-----*-------------------------------------------------* \",\n\t\"*-----*-------------------------------------------------*-----*-------------------------------------------------* \",\n\t\"┗━━┷━━━━━━━━━━━━━━━━━━━━━━━━┷━━┷━━━━━━━━━━━━━━━━━━━━━━━━┛\",\n\t\"*-----*-------------------------------------------------*-----*-------------------------------------------------* \",\n\t\"*-----*-------------------------------------------------*-----*-------------------------------------------------* \"\n};\n\n/* 打印事件 */\nLOCAL PrintLangDesc slan_selfcheck_chg_state_str = { 0 };\nLOCAL PrintLangDesc slan_binchg_chg_state_str = { 0 };\n\nLOCAL const INT8 *event_change_line_tab0[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┏━━┯━━━━┯━━━━━━━━━━━━━━━━━━━┯━━┯━━━━┯━━━━━━━━━━━━━━━━━━━┓\",\n\t\"*-----*---------*---------------------------------------*-----*---------*---------------------------------------* \",\n\t\"*-----*---------*---------------------------------------*-----*---------*---------------------------------------* \",\n\t\"┏━━┯━━━━┯━━━━━━━━━━━━━━━━━━━┯━━┯━━━━┯━━━━━━━━━━━━━━━━━━━┓\",\n\t\"*-----*---------*---------------------------------------*-----*---------*---------------------------------------* \",\n\t\"*-----*---------*---------------------------------------*-----*---------*---------------------------------------* \"\n};\n\nLOCAL INT8 *event_change_line_tab1[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┃    │        │                             :        │    │        │                             :        ┃\",\n\t\"|     |         |                              :        |     |         |                              :        | \",\n\t\"|     |         |                              :        |     |         |                              :        | \",\n\t\"┃    │        │                             :        │    │        │                             :        ┃\",\n\t\"|     |         |                              :        |     |         |                              :        | \",\n\t\"|     |         |                              :        |     |         |                              :        | \"\n};\n\nLOCAL const INT8 *event_change_line_tab2[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┠──┼────┼───────────────────┼──┼────┼───────────────────┨\",\n\t\"|-----|---------|---------------------------------------|-----|---------|---------------------------------------| \",\n\t\"|-----|---------|---------------------------------------|-----|---------|---------------------------------------| \",\n\t\"┠──┼────┼───────────────────┼──┼────┼───────────────────┨\",\n\t\"|-----|---------|---------------------------------------|-----|---------|---------------------------------------| \",\n\t\"|-----|---------|---------------------------------------|-----|---------|---------------------------------------| \"\n};\n\nLOCAL const INT8 *event_change_line_tab3[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┗━━┷━━━━┷━━━━━━━━━━━━━━━━━━━┷━━┷━━━━┷━━━━━━━━━━━━━━━━━━━┛\",\n\t\"*-----*---------*---------------------------------------*-----*---------*---------------------------------------* \",\n\t\"*-----*---------*---------------------------------------*-----*---------*---------------------------------------* \",\n\t\"┗━━┷━━━━┷━━━━━━━━━━━━━━━━━━━┷━━┷━━━━┷━━━━━━━━━━━━━━━━━━━┛\",\n\t\"*-----*---------*---------------------------------------*-----*---------*---------------------------------------* \",\n\t\"*-----*---------*---------------------------------------*-----*---------*---------------------------------------* \"\n};\n\n/* 打印波形标度 */\nLOCAL PrintLangDesc slan_wave_analog_group_scale_str = { 0 };\nLOCAL PrintLangDesc slan_wave_analog_channel_str = { 0 };\nLOCAL PrintLangDesc slan_wave_per_unit_descrip = { 0 };\nLOCAL PrintLangDesc slan_wave_time_scale_str = { 0 };\nLOCAL INT8 is_print_zero_scale = 0;\n\nLOCAL const INT8 *wave_scale_line_tab0[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\",\n\t\"*---------------------------------------------------------------------------------------------------------------* \",\n\t\"*---------------------------------------------------------------------------------------------------------------* \",\n\t\"┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\",\n\t\"*---------------------------------------------------------------------------------------------------------------* \",\n\t\"*---------------------------------------------------------------------------------------------------------------* \"\n};\n\nLOCAL const INT8 *wave_scale_line_tab1[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\",\n\t\"*---------------------------------------------------------------------------------------------------------------* \",\n\t\"*---------------------------------------------------------------------------------------------------------------* \",\n\t\"┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\",\n\t\"*---------------------------------------------------------------------------------------------------------------* \",\n\t\"*---------------------------------------------------------------------------------------------------------------* \"\n};\n\n/* 打印数字量描述 */\nLOCAL PrintLangDesc slan_trip_pulse_desc_str = { 0 };\n\nLOCAL const INT8 *pulse_desc_line_tab0[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\",\n\t\"*---------------------------------------------------------------------------------------------------------------* \",\n\t\"*---------------------------------------------------------------------------------------------------------------* \",\n\t\"┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\",\n\t\"*---------------------------------------------------------------------------------------------------------------* \",\n\t\"*---------------------------------------------------------------------------------------------------------------* \"\n};\n\nLOCAL const INT8 *pulse_desc_line_tab1[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\",\n\t\"*---------------------------------------------------------------------------------------------------------------* \",\n\t\"*---------------------------------------------------------------------------------------------------------------* \",\n\t\"┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\",\n\t\"*---------------------------------------------------------------------------------------------------------------* \",\n\t\"*---------------------------------------------------------------------------------------------------------------* \"\n};\n\n/* 打印模拟量描述 */\nLOCAL PrintLangDesc slan_wave_analog_discrip = { 0 };\nLOCAL PrintLangDesc slan_no_specific_wave_page = { 0 };\n\nLOCAL const INT8 *analog_desc_line_tab0[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\",\n\t\"*---------------------------------------------------------------------------------------------------------------* \",\n\t\"*---------------------------------------------------------------------------------------------------------------* \",\n\t\"┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\",\n\t\"*---------------------------------------------------------------------------------------------------------------* \",\n\t\"*---------------------------------------------------------------------------------------------------------------* \"\n};\n\nLOCAL const INT8 *analog_desc_line_tab1[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\",\n\t\"*---------------------------------------------------------------------------------------------------------------* \",\n\t\"*---------------------------------------------------------------------------------------------------------------* \",\n\t\"┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\",\n\t\"*---------------------------------------------------------------------------------------------------------------* \",\n\t\"*---------------------------------------------------------------------------------------------------------------* \"\n};\n\n/* 打印相对时间描述 */\nLOCAL PrintLangDesc slan_wave_ret_time_discrip = { 0 };\n\n/* 自动打印 */\nLOCAL PrintLangDesc slan_selfcheck_header_str = { 0 };\nLOCAL PrintLangDesc slan_selfcheck_alarm_time = { 0 };\nLOCAL PrintLangDesc slan_selfcheck_alarm_element = { 0 };\nLOCAL PrintLangDesc slan_selfcheck_alarm_phase = { 0 };\n\nLOCAL const INT8 *auto_selfcheck_line_tab0[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┏━━━━┯━━━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━━━━━━━━━┯━━━━━┓\",\n\t\"*---------*-------------------------------------*---------------------------------------------------*-----------* \",\n\t\"*---------*-------------------------------------*---------------------------------------------------*-----------* \",\n\t\"┏━━━━┯━━━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━━━━━━━━━┯━━━━━┓\",\n\t\"*---------*-------------------------------------*---------------------------------------------------*-----------* \",\n\t\"*---------*-------------------------------------*---------------------------------------------------*-----------* \"\n};\n\nLOCAL INT8 *auto_selfcheck_line_tab1[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┃        │                                    │                                                  │          ┃\",\n\t\"|         |                                     |                                                   |           | \",\n\t\"|         |                                     |                                                   |           | \",\n\t\"┃        │                                    │                                                  │          ┃\",\n\t\"|         |                                     |                                                   |           | \",\n\t\"|         |                                     |                                                   |           | \"\n};\n\nLOCAL const INT8 *auto_selfcheck_line_tab4[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┗━━━━┷━━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━━━━━━━━┷━━━━━┛\",\n\t\"*---------*-------------------------------------*---------------------------------------------------*-----------* \",\n\t\"*---------*-------------------------------------*---------------------------------------------------*-----------* \",\n\t\"┗━━━━┷━━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━━━━━━━━┷━━━━━┛\",\n\t\"*---------*-------------------------------------*---------------------------------------------------*-----------* \",\n\t\"*---------*-------------------------------------*---------------------------------------------------*-----------* \"\n};\n\n/* 打印 */\nLOCAL const INT8 *selfcheck_line_tab2[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┠────┼──────────────┼─────┼───────────────────────┼─────┨\",\n\t\"|---------|-----------------------------|-----------|-----------------------------------------------|-----------| \",\n\t\"|---------|-----------------------------|-----------|-----------------------------------------------|-----------| \",\n\t\"┠────┼──────────────┼─────┼───────────────────────┼─────┨\",\n\t\"|---------|-----------------------------|-----------|-----------------------------------------------|-----------| \",\n\t\"|---------|-----------------------------|-----------|-----------------------------------------------|-----------| \"\n};\n\nLOCAL const INT8 *selfcheck_line_tab0[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┏━━━━┯━━━━━━━━━━━━━━┯━━━━━┯━━━━━━━━━━━━━━━━━━━━━━━┯━━━━━┓\",\n\t\"*---------*-----------------------------*-----------*-----------------------------------------------*-----------* \",\n\t\"*---------*-----------------------------*-----------*-----------------------------------------------*-----------* \",\n\t\"┏━━━━┯━━━━━━━━━━━━━━┯━━━━━┯━━━━━━━━━━━━━━━━━━━━━━━┯━━━━━┓\",\n\t\"*---------*-----------------------------*-----------*-----------------------------------------------*-----------* \",\n\t\"*---------*-----------------------------*-----------*-----------------------------------------------*-----------* \"\n};\n\nLOCAL INT8 *selfcheck_line_tab1[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┃        │                            │          │                                              │          ┃\",\n\t\"|         |                             |           |                                               |           | \",\n\t\"|         |                             |           |                                               |           | \",\n\t\"┃        │                            │          │                                              │          ┃\",\n\t\"|         |                             |           |                                               |           | \",\n\t\"|         |                             |           |                                               |           | \"\n};\n\nLOCAL const INT8 *selfcheck_line_tab4[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┗━━━━┷━━━━━━━━━━━━━━┷━━━━━┷━━━━━━━━━━━━━━━━━━━━━━━┷━━━━━┛\",\n\t\"*---------*-----------------------------*-----------*-----------------------------------------------*-----------* \",\n\t\"*---------*-----------------------------*-----------*-----------------------------------------------*-----------* \",\n\t\"┗━━━━┷━━━━━━━━━━━━━━┷━━━━━┷━━━━━━━━━━━━━━━━━━━━━━━┷━━━━━┛\",\n\t\"*---------*-----------------------------*-----------*-----------------------------------------------*-----------* \",\n\t\"*---------*-----------------------------*-----------*-----------------------------------------------*-----------* \"\n};\n\n/* 打印变位报告 */\nLOCAL const INT8 *binchg_line_tab2[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┠────┼──────────────────┼─────────────────────────┼─────┨\",\n\t\"|---------|-------------------------------------|---------------------------------------------------|-----------| \",\n\t\"|---------|-------------------------------------|---------------------------------------------------|-----------| \",\n\t\"┠────┼──────────────────┼─────────────────────────┼─────┨\",\n\t\"|---------|-------------------------------------|---------------------------------------------------|-----------| \",\n\t\"|---------|-------------------------------------|---------------------------------------------------|-----------| \"\n};\n\n/* 自动变位打印 */\nLOCAL PrintLangDesc slan_binchg_header_str = { 0 };\nLOCAL PrintLangDesc slan_binchg_time = { 0 };\nLOCAL PrintLangDesc slan_binchg_element = { 0 };\n\nLOCAL const INT8 *binchg_line_tab0[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┏━━━━┯━━━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━━━━━━━━━┯━━━━━┓\",\n\t\"*---------*-------------------------------------*---------------------------------------------------*-----------* \",\n\t\"*---------*-------------------------------------*---------------------------------------------------*-----------* \",\n\t\"┏━━━━┯━━━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━━━━━━━━━┯━━━━━┓\",\n\t\"*---------*-------------------------------------*---------------------------------------------------*-----------* \",\n\t\"*---------*-------------------------------------*---------------------------------------------------*-----------* \"\n};\n\nLOCAL INT8 *binchg_line_tab1[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┃        │                                    │                                                  │          ┃\",\n\t\"|         |                                     |                                                   |           | \",\n\t\"|         |                                     |                                                   |           | \",\n\t\"┃        │                                    │                                                  │          ┃\",\n\t\"|         |                                     |                                                   |           | \",\n\t\"|         |                                     |                                                   |           | \"\n};\n\nLOCAL const INT8 *binchg_line_tab4[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┗━━━━┷━━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━━━━━━━━┷━━━━━┛\",\n\t\"*---------*-------------------------------------*---------------------------------------------------*-----------* \",\n\t\"*---------*-------------------------------------*---------------------------------------------------*-----------* \",\n\t\"┗━━━━┷━━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━━━━━━━━┷━━━━━┛\",\n\t\"*---------*-------------------------------------*---------------------------------------------------*-----------* \",\n\t\"*---------*-------------------------------------*---------------------------------------------------*-----------* \"\n};\n\n/* 打印SOE报告 */\nLOCAL PrintLangDesc slan_soe_header_str = { 0 };\nLOCAL PrintLangDesc slan_soe_time = { 0 };\nLOCAL PrintLangDesc slan_soe_element = { 0 };\n\nLOCAL const INT8 *soe_line_tab2[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┠────┼──────────────────┼─────────────────────────┼─────┨\",\n\t\"|---------|-------------------------------------|---------------------------------------------------|-----------| \",\n\t\"|---------|-------------------------------------|---------------------------------------------------|-----------| \",\n\t\"┠────┼──────────────────┼─────────────────────────┼─────┨\",\n\t\"|---------|-------------------------------------|---------------------------------------------------|-----------| \",\n\t\"|---------|-------------------------------------|---------------------------------------------------|-----------| \"\n};\n\nLOCAL const INT8 *soe_line_tab0[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┏━━━━┯━━━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━━━━━━━━━┯━━━━━┓\",\n\t\"*---------*-------------------------------------*---------------------------------------------------*-----------* \",\n\t\"*---------*-------------------------------------*---------------------------------------------------*-----------* \",\n\t\"┏━━━━┯━━━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━━━━━━━━━┯━━━━━┓\",\n\t\"*---------*-------------------------------------*---------------------------------------------------*-----------* \",\n\t\"*---------*-------------------------------------*---------------------------------------------------*-----------* \"\n};\n\nLOCAL INT8 *soe_line_tab1[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┃        │                                    │                                                  │          ┃\",\n\t\"|         |                                     |                                                   |           | \",\n\t\"|         |                                     |                                                   |           | \",\n\t\"┃        │                                    │                                                  │          ┃\",\n\t\"|         |                                     |                                                   |           | \",\n\t\"|         |                                     |                                                   |           | \"\n};\n\nLOCAL const INT8 *soe_line_tab4[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┗━━━━┷━━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━━━━━━━━┷━━━━━┛\",\n\t\"*---------*-------------------------------------*---------------------------------------------------*-----------* \",\n\t\"*---------*-------------------------------------*---------------------------------------------------*-----------* \",\n\t\"┗━━━━┷━━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━━━━━━━━┷━━━━━┛\",\n\t\"*---------*-------------------------------------*---------------------------------------------------*-----------* \",\n\t\"*---------*-------------------------------------*---------------------------------------------------*-----------* \"\n};\n\n/* 打印一行运行报告 */\nLOCAL const INT8 *run_rpt_line_tab2[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┠────┼──────────────────┼─────────────────────────┼─────┨\",\n\t\"|---------|-------------------------------------|---------------------------------------------------|-----------| \",\n\t\"|---------|-------------------------------------|---------------------------------------------------|-----------| \",\n\t\"┠────┼──────────────────┼─────────────────────────┼─────┨\",\n\t\"|---------|-------------------------------------|---------------------------------------------------|-----------| \",\n\t\"|---------|-------------------------------------|---------------------------------------------------|-----------| \"\n};\n\n/* 打印运行报告 */\nLOCAL PrintLangDesc slan_run_rpt_header_str = { 0 };\nLOCAL PrintLangDesc slan_run_time = { 0 };\nLOCAL PrintLangDesc slan_run_element = { 0 };\n\nLOCAL const INT8 *run_rpt_line_tab0[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┏━━━━┯━━━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━━━━━━━━━┯━━━━━┓\",\n\t\"*---------*-------------------------------------*---------------------------------------------------*-----------* \",\n\t\"*---------*-------------------------------------*---------------------------------------------------*-----------* \",\n\t\"┏━━━━┯━━━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━━━━━━━━━┯━━━━━┓\",\n\t\"*---------*-------------------------------------*---------------------------------------------------*-----------* \",\n\t\"*---------*-------------------------------------*---------------------------------------------------*-----------* \"\n};\n\nLOCAL INT8 *run_rpt_line_tab1[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┃        │                                    │                                                  │          ┃\",\n\t\"|         |                                     |                                                   |           | \",\n\t\"|         |                                     |                                                   |           | \",\n\t\"┃        │                                    │                                                  │          ┃\",\n\t\"|         |                                     |                                                   |           | \",\n\t\"|         |                                     |                                                   |           | \"\n};\n\nLOCAL const INT8 *run_rpt_line_tab4[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┗━━━━┷━━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━━━━━━━━┷━━━━━┛\",\n\t\"*---------*-------------------------------------*---------------------------------------------------*-----------* \",\n\t\"*---------*-------------------------------------*---------------------------------------------------*-----------* \",\n\t\"┗━━━━┷━━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━━━━━━━━┷━━━━━┛\",\n\t\"*---------*-------------------------------------*---------------------------------------------------*-----------* \",\n\t\"*---------*-------------------------------------*---------------------------------------------------*-----------* \"\n};\n\n/* 打印一行通道状态报告 */\nLOCAL const INT8 *chan_superv_line_tab2[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┠────┼────────────────┼─────────────────────────────────┨\",\n\t\"|---------|---------------------------------|-------------------------------------------------------------------| \",\n\t\"|---------|---------------------------------|-------------------------------------------------------------------| \",\n\t\"┠────┼────────────────┼─────────────────────────────────┨\",\n\t\"|---------|---------------------------------|-------------------------------------------------------------------| \",\n\t\"|---------|---------------------------------|-------------------------------------------------------------------| \"\n};\n\n/* 打印通道状态报告 */\nLOCAL PrintLangDesc slan_chan_superv_header_str[PRINT_MAX_CHAN_NUM] = { 0 };\nLOCAL PrintLangDesc slan_chan_superv_time = { 0 };\nLOCAL PrintLangDesc slan_chan_superv_content = { 0 };\n\nLOCAL const INT8 *chan_superv_line_tab0[][EN_LANGUAGE_TYPE_NUM] = \n{\n\t\"┏━━━━┯━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\",\n\t\"*---------*---------------------------------*-------------------------------------------------------------------* \",\n\t\"*---------*---------------------------------*-------------------------------------------------------------------* \",\n\t\"┏━━━━┯━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\",\n\t\"*---------*---------------------------------*-------------------------------------------------------------------* \",\n\t\"*---------*---------------------------------*-------------------------------------------------------------------* \"\n};\n\nLOCAL INT8 *chan_superv_line_tab1[][EN_LANGUAGE_TYPE_NUM] = \n{\n\t\"┃        │                                │                                                                  ┃\",\n\t\"|         |                                 |                                                                   | \",\n\t\"|         |                                 |                                                                   | \",\n\t\"┃        │                                │                                                                  ┃\",\n\t\"|         |                                 |                                                                   | \",\n\t\"|         |                                 |                                                                   | \"\n};\n\nLOCAL const INT8 *chan_superv_line_tab4[][EN_LANGUAGE_TYPE_NUM] = \n{\n\t\"┗━━━━┷━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\",\n\t\"*---------*---------------------------------*-------------------------------------------------------------------* \",\n\t\"*---------*---------------------------------*-------------------------------------------------------------------* \",\n\t\"┗━━━━┷━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\",\n\t\"*---------*---------------------------------*-------------------------------------------------------------------* \",\n\t\"*---------*---------------------------------*-------------------------------------------------------------------* \"\n};\n\n/* 打印一行通道统计 */\nLOCAL PrintLangDesc slan_chan_statis_diff_str = { 0 };\n\nLOCAL const INT8 *chan_statistic_line_tab2[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┠──┼──────────────┼───────────┼───────┼───────────┼───────┨\",\n\t\"|-----|-----------------------------|-----------------------|---------------|-----------------------|---------------| \",\n\t\"|-----|-----------------------------|-----------------------|---------------|-----------------------|---------------| \",\n\t\"┠──┼────────────┼───────────┼───────┼───────────┼───────┨\",\n\t\"|-----|-----------------------|-----------------------|---------------|-----------------------|---------------| \",\n\t\"|-----|-----------------------|-----------------------|---------------|-----------------------|---------------| \"\n};\n\nLOCAL const INT8 *chan_statistic_line_tab3[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┃    │                            ├───────────┼───────┼───────────┼───────┨\",\n\t\"|-----|                             |-----------------------|---------------|-----------------------|---------------| \",\n\t\"|-----|                             |-----------------------|---------------|-----------------------|---------------| \",\n\t\"┃    │                        ├───────────┼───────┼───────────┼───────┨\",\n\t\"|-----|                         |-----------------------|---------------|-----------------------|---------------| \",\n\t\"|-----|                         |-----------------------|---------------|-----------------------|---------------| \"\n};\n\n/* 打印通道统计 */\nLOCAL PrintLangDesc slan_chan_statis_header_str[PRINT_MAX_CHAN_NUM] = { 0 };\nLOCAL PrintLangDesc slan_chan_statis_time = { 0 };\nLOCAL PrintLangDesc slan_chan_statis_element = { 0 };\n\nLOCAL const INT8 *chan_statis_line_tab0[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┏━━┯━━━━━━━━━━━━━━┯━━━━━━━━━━━┯━━━━━━━┯━━━━━━━━━━━┯━━━━━━━┓\",\n\t\"*-----*-----------------------------*-----------------------*---------------*-----------------------*---------------* \",\n\t\"*-----*-----------------------------*---------------------*---------------*---------------------*---------------* \",\n\t\"┏━━┯━━━━━━━━━━━━┯━━━━━━━━━━━┯━━━━━━━┯━━━━━━━━━━━┯━━━━━━━┓\",\n\t\"*-----*-------------------------*-----------------------*---------------*-----------------------*---------------* \",\n\t\"*-----*-------------------------*---------------------*---------------*---------------------*---------------* \"\n};\n\nLOCAL INT8 *chan_statis_line_tab1[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┃    │                            │                      │              │                      │              ┃\",\n\t\"|     |                             |                       |               |                       |               | \",\n\t\"|     |                             |                       |               |                       |               | \",\n\t\"┃    │                        │                      │              │                      │              ┃\",\n\t\"|     |                         |                       |               |                       |               | \",\n\t\"|     |                         |                       |               |                       |               | \"\n};\n\nLOCAL const INT8 *chan_statis_line_tab4[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┗━━┷━━━━━━━━━━━━━━┷━━━━━━━━━━━┷━━━━━━━┷━━━━━━━━━━━┷━━━━━━━┛\",\n\t\"*-----*-----------------------------*-----------------------*---------------*-----------------------*---------------* \",\n\t\"*-----*-----------------------------*-----------------------*---------------*-----------------------*---------------* \",\n\t\"┗━━┷━━━━━━━━━━━━┷━━━━━━━━━━━┷━━━━━━━┷━━━━━━━━━━━┷━━━━━━━┛\",\n\t\"*-----*-------------------------*-----------------------*---------------*-----------------------*---------------* \",\n\t\"*-----*-------------------------*-----------------------*---------------*-----------------------*---------------* \"\n};\n\n/* 打印一行操作报告 */\nLOCAL const INT8 *op_line_tab2[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┠──┼────────────┼──────────┼────────┼────┼────┼──┼────┼───┨\",\n\t\"|----|------------------------|--------------------|----------------|--------|--------|----|--------|-----| \",\n\t\"|----|------------------------|--------------------|----------------|--------|--------|----|--------|-----| \",\n\t\"┠──┼────────────┼──────────┼────────┼────┼─┼──┼────┼───┨\",\n\t\"|----|------------------------|--------------------|----------------|--------|--|----|--------|-----| \",\n\t\"|----|------------------------|--------------------|----------------|--------|--|----|--------|-----| \"\n};\n\n/* 打印操作报告 */\nLOCAL PrintLangDesc slan_op_header_str = { 0 };\nLOCAL PrintLangDesc slan_op_time = { 0 };\nLOCAL PrintLangDesc slan_op_element = { 0 };\nLOCAL PrintLangDesc slan_op_result = { 0 };\nLOCAL PrintLangDesc slan_op_para = { 0 };\nLOCAL PrintLangDesc slan_op_direc = { 0 };\nLOCAL PrintLangDesc slan_op_step = { 0 };\nLOCAL PrintLangDesc slan_op_type = { 0 };\nLOCAL PrintLangDesc slan_op_console_id = { 0 };\nLOCAL PrintLangDesc slan_op_ctrl_result[20] = { 0 };\nLOCAL PrintLangDesc slan_op_ctrl_para[4] = { 0 };\nLOCAL PrintLangDesc slan_op_statis_ctrl_direc[5] = { 0 };\nLOCAL PrintLangDesc slan_op_statis_ctrl_step[4] = { 0 };\nLOCAL PrintLangDesc slan_op_statis_ctrl_type[3] = { 0 };\n\nLOCAL const INT8 *op_statis_line_tab0[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┏━━┯━━━━━━━━━━━━┯━━━━━━━━━━┯━━━━━━━━┯━━━━┯━━━━┯━━┯━━━━┯━━━┓\",\n\t\"*----*------------------------*--------------------*----------------*--------*--------*----*--------*------* \",\n\t\"*----*------------------------*--------------------*----------------*--------*--------*----*--------*------* \",\n\t\"┏━━┯━━━━━━━━━━━━┯━━━━━━━━━━┯━━━━━━━━┯━━━━┯━┯━━┯━━━━┯━━━┓\",\n\t\"*----*------------------------*--------------------*----------------*--------*--*----*--------*------* \",\n\t\"*----*------------------------*--------------------*----------------*--------*--*----*--------*------* \"\n};\n\nLOCAL INT8 *op_statis_line_tab1[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┃    │                        │                    │                │        │        │    │        │      ┃\",\n\t\"|    |                        |                    |                |        |        |    |        |      | \",\n\t\"|    |                        |                    |                |        |        |    |        |      | \",\n\t\"┃    │                        │                    │                │        │  │    │        │      ┃\",\n\t\"|    |                        |                    |                |        |  |    |        |      | \",\n\t\"|    |                        |                    |                |        |  |    |        |      | \"\n};\n\nLOCAL const INT8 *op_statis_line_tab4[][EN_LANGUAGE_TYPE_NUM] =\n{\n\t\"┗━━┷━━━━━━━━━━━━┷━━━━━━━━━━┷━━━━━━━━┷━━━━┷━━━━┷━━┷━━━━┷━━━┛\",\n\t\"*----*------------------------*--------------------*----------------*--------*--------*----*--------*------* \",\n\t\"*----*------------------------*--------------------*----------------*--------*--------*----*--------*------* \",\n\t\"┗━━┷━━━━━━━━━━━━┷━━━━━━━━━━┷━━━━━━━━┷━━━━┷━┷━━┷━━━━┷━━━┛\",\n\t\"*----*------------------------*--------------------*----------------*--------*--*----*--------*------* \",\n\t\"*----*------------------------*--------------------*----------------*--------*--*----*--------*------* \"\n};\n\n// 待翻译字符串，用于实际打印输出\nLOCAL const PrintTranslateStr s_print_translate_array[] =\n{\n\t{&slan_print_time_str,               \"PRINT_PRINT_TIME\",        },\n\t{&slan_prog_ver_str,                 \"PROGRAM_VER\",             },\n\t{&slan_subq_no_str,                  \"PROG_MANAGE\",             },\n\t{&slan_develop_no_str,               \"PROG_DEVELOP\",            },\n\t{&slan_device_addr,                  \"device_addr\",             },\n\n\t{&slan_manufacturer_str,             \"MANUFACTURER\",            },\n\t{&slan_equip_desc_str,               \"EQUIP_DESCRIPTION\",       },\n\t{&slan_serial_no_str,                \"SERIAL_NO\",               },\n\t{&slan_desc_str,                     \"DESCRIPTION\",             },\n\t{&slan_actual_value_str,             \"ACTUAL_VALUE\",            },\n\n\t{&slan_equip_name,                   \"EQUIP_NAME\",              },\n\t{&slan_equip_type,                   \"EQUIP_TYPE\",              },\n\t{&slan_prog_time,                    \"PROGRAM_TIME\",            },\n\t{&slan_prog_chksum,                  \"PROGRAM_CRC\",             },\n\t{&slan_fpga_ver,                     \"FPGA_VER\",           \t\t},\t\t\t//新增三个FPGA相关内容\n\t{&slan_fpga_time,                    \"FPGA_TIME\",             \t},\n\t{&slan_fpga_crc,                  \t \"FPGA_CRC\",           \t\t},\n\t{&slan_dev_icd_crc,                  \"DEV_ICD_CRC\",             },\t\t\t//打印词条和LCD保持一致\n\t{&slan_dev_scd_crc,                  \"STA_ICD_CRC\",             },\t\t\t//打印词条和LCD保持一致\n\t{&slan_dev_id,                       \"DEV_ID\",                  },\n\t{&slan_dev_unique,                   \"UNIQUE_ID\",               },\n\t\n\t{&slan_prim_value_str,               \"PRIMARY_VALUE\",           },\n\t{&slan_second_value_str,             \"SECONDARY_VALUE\",         },\n\t{&slan_quality_value_str,            \"QUALITY_VALUE\",         },\n\t{&slan_bi_value_str,\t\t\t\t \"SHR_PRINT_BI\",         },\n\n\t{&slan_active_section_str,           \"ACTIVE_GROUP_SETTING\",    },\n\t{&slan_unactive_section_str,         \"UNACTIVE_GROUP_SETTING\",  },\n\t{&slan_set_control_bit_str,          \"CTRL_BIT\",                },\n\t{&slan_matrix_desc_str,              \"MATRIX_DESCRIPTION\",      },\n\t{&slan_matrix_bit_str,               \"MATRIX_BIT\",              },\n\t{&slan_matrix_setting_str,           \"MATRIX_SETTING\",          },\n\t{&slan_latest_modify_header_str,     \"LATEST_MODIFY_SETTING\",   },\n\t{&slan_set_before_modify_str,        \"SETTING_BEFORE_MODIFY\",   },\n\t{&slan_set_after_modify_str,         \"SETTING_AFTER_MODIFY\",    },\n\t{&slan_set_dimension_str,            \"DIMENSION\",               },\n\n\t{&slan_item_trip_rpt_header_str,     \"ITEM_OPERATE_REPORT\",     },\n\t{&slan_trip_time_str,                \"TRIP_TIME\",               },\n\t{&slan_trip_element_str,             \"TRIP_ELEMENT\",            },\n\t{&slan_trip_value_str,               \"TRIP_VALUE\",              },\n\t{&slan_trip_phase_str,               \"TRIP_PHASE\",              },\n\t\n\t{&slan_drawoff_trip_rpt_header_str,  \"DRAWOFF_TRIP_REPORT\",     },\n\t{&slan_pickup_time_str,              \"PICKUP_TIME\",             },\n\t{&slan_relative_time_str,            \"RELATIVE_TIME\",           },\n\n\t{&slan_selfcheck_init_state_str,     \"SELFCHECK_INIT_STATE\",    },\n\t{&slan_binchg_init_state_str,        \"BINCHG_INIT_STATE\",       },\n\t{&slan_selfcheck_chg_state_str,      \"SELFCHECK_CHANGE_STATE\",  },\n\t{&slan_binchg_chg_state_str,         \"BINCHG_CHANGE_STATE_STR\", },\n\n\t{&slan_wave_analog_group_scale_str,  \"WAVE_ANALOG_GROUP_SCALE\", },\n\t{&slan_wave_analog_channel_str,      \"WAVE_ANALOG_CHANNEL\",     },\n\t{&slan_wave_per_unit_descrip,        \"WAVE_PER_UNIT\",           },\n\t{&slan_wave_time_scale_str,          \"WAVE_TIME_SCALE\",         },\n\n\t{&slan_trip_pulse_desc_str,          \"TRIP_PULSE_DESCRIPTION\",  },\n\t{&slan_wave_analog_discrip,          \"WAVE_ANALOG_DISCRIPTION\", },\n\t{&slan_no_specific_wave_page,        \"NO_SPECIFIC_WAVE_PAGE\",   },\n\n\t{&slan_wave_ret_time_discrip,        \"RET_TIME_DESCRIPTION\",   },\n\n\t{&slan_selfcheck_header_str,         \"SELFSUPERV_REPORT\",       },\n\t{&slan_selfcheck_alarm_time,         \"SELFSUPERV_ALARM_TIME\",   },\n\t{&slan_selfcheck_alarm_element,      \"SELFSUPERV_ALARM_ELEMENT\",},\n\t{&slan_selfcheck_alarm_phase,        \"SELFSUPERV_ALARM_PHASE\",  },\n\n\t{&slan_binchg_header_str,            \"BINCHG_REPORT\",           },\n\t{&slan_binchg_time,                  \"BINCHG_TIME\",             },\n\t{&slan_binchg_element,               \"BINCHG_ELEMENT\",          },\n\n\t{&slan_soe_header_str,\t\t\t\t \"SOE_REPORT\",\t\t\t\t},\n\t{&slan_soe_time,\t\t\t\t\t \"BINCHG_TIME\",\t\t\t\t},\n\t{&slan_soe_element,\t\t\t\t\t \"BINCHG_ELEMENT\",\t\t\t},\n\n\t{&slan_run_rpt_header_str,           \"RUN_REPORT\",              },\n\t{&slan_run_time,                     \"RUN_TIME\",                },\n\t{&slan_run_element,                  \"RUN_ELEMENT\",             },\n\n\t{&slan_chan_superv_header_str[0],    \"CHANA_SUPERV_REPORT\",     },\n\t{&slan_chan_superv_header_str[1],    \"CHANB_SUPERV_REPORT\",     },\n\t{&slan_chan_superv_header_str[2],    \"CHANC_SUPERV_REPORT\",     },\n\t{&slan_chan_superv_header_str[3],    \"CHAND_SUPERV_REPORT\",     },\n\t{&slan_chan_superv_time,             \"CHAN_SUPERV_TIME\",        },\n\t{&slan_chan_superv_content,          \"CHAN_SUPERV_CONTENT\",     },\n\n\t{&slan_chan_statis_header_str[0],    \"CHANA_STATISTIC_REPORT\",   },\n\t{&slan_chan_statis_header_str[1],    \"CHANB_STATISTIC_REPORT\",   },\n\t{&slan_chan_statis_header_str[2],    \"CHANC_STATISTIC_REPORT\",   },\n\t{&slan_chan_statis_header_str[3],    \"CHAND_STATISTIC_REPORT\",   },\n\t{&slan_chan_statis_time,             \"CHAN_STATISTIC_TIME\",     },\n\t{&slan_chan_statis_element,          \"CHAN_STATISTIC_ELEMENT\",  },\n\t{&slan_chan_statis_diff_str,         \"CHAN_STATISTIC_DIFF_STR\", },\n\n\t{&slan_op_header_str,        \t\t \"ORDER_REPORT\", \t\t    },\n\t{&slan_op_time,             \t\t \"ORDER_TIME\",   \t\t    },\n\t{&slan_op_element,          \t\t \"CTRL_OBJ\", \t\t\t    },\n\t{&slan_op_result,            \t\t \"CTRL_RESULT\", \t\t    },\n\t{&slan_op_para,             \t\t \"CTRL_PARA\", \t\t\t\t},\n\t{&slan_op_direc,            \t\t \"VA\",\t\t\t   \t},\n\t{&slan_op_step,             \t\t \"DGSTEP\", \t\t\t\t\t},\n\t{&slan_op_type,             \t\t \"CTRL_TYPE\",\t\t\t    },\n\t{&slan_op_console_id,              \t \"CONSOLE_ID\",\t\t\t\t},\n\t{&slan_op_ctrl_result[0],           \"OBJ_ON_BUSY\", \t\t\t\t},\n\t{&slan_op_ctrl_result[1],           \"CTRL_INVALID\", \t\t\t},\n\t{&slan_op_ctrl_result[2],           \"EXE_TIME_OUT\", \t\t\t},\n\t{&slan_op_ctrl_result[3],           \"DEV_STATUS_BS\",\t\t    },\n\t{&slan_op_ctrl_result[4],           \"DEV_LOCAL_CTRL\", \t\t\t},\n\t{&slan_op_ctrl_result[5],           \"DEV_TEST\", \t\t\t\t},\n\t{&slan_op_ctrl_result[6],           \"ERROR_OPTION_VALUE\", \t\t},\n\t{&slan_op_ctrl_result[7],           \"ERROR_SEL_VALUE\", \t\t\t},\n\t{&slan_op_ctrl_result[8],           \"ERROR_CLOSE_TYPE\", \t\t},\n\t{&slan_op_ctrl_result[9],           \"ERROR_RELATION_CONDITIION\",},\n\t{&slan_op_ctrl_result[10],          \"ERROR_SYNC_CONDITIION\", \t},\n\t{&slan_op_ctrl_result[11],          \"ERROR_U_LOW\", \t\t\t\t},\n\t{&slan_op_ctrl_result[12],          \"ERROR_PTDX\", \t\t\t\t},\n\t{&slan_op_ctrl_result[13],          \"ERROR_VDIF\", \t\t\t\t},\n\t{&slan_op_ctrl_result[14],          \"ERROR_FDIF\", \t\t\t\t},\n\t{&slan_op_ctrl_result[15],          \"ERROR_DFDIF\",\t\t\t    },\n\t{&slan_op_ctrl_result[16],          \"ERROR_ADIF\", \t\t\t\t},\n\t{&slan_op_ctrl_result[17],          \"ERROR_U_HIG\", \t\t\t\t},\n\t{&slan_op_ctrl_result[18],          \"ERROR_U_CONDITIION\", \t\t},\n\t{&slan_op_ctrl_result[19],          \"CTRL_SUCCESS\", \t\t\t},\n\t{&slan_op_ctrl_para[0],             \"SYNC_CHECK\", \t\t\t\t},\n\t{&slan_op_ctrl_para[1],             \"NO_CHECK\", \t\t\t\t},\n\t{&slan_op_ctrl_para[2],             \"DEAD_CHECK\", \t\t\t\t},\n\t{&slan_op_ctrl_para[3],             \"SYNC_DEAD_CHECK\", \t\t    },\n\t{&slan_op_statis_ctrl_direc[0],     \"CTRL_SEPARATE\", \t\t\t},\n\t{&slan_op_statis_ctrl_direc[1],     \"CTRL_CLOSE\", \t\t\t\t},\n\t{&slan_op_statis_ctrl_direc[2],     \"CTRL_STOP\", \t\t\t\t},\n\t{&slan_op_statis_ctrl_direc[3],     \"CTRL_HIGHER\", \t\t\t\t},\n\t{&slan_op_statis_ctrl_direc[4],     \"CTRL_LOWER\", \t\t\t\t},\n\t{&slan_op_statis_ctrl_step[0],      \"CTRL_IDLE\", \t\t\t\t},\n\t{&slan_op_statis_ctrl_step[1],      \"CTRL_SELECT\", \t\t\t\t},\n\t{&slan_op_statis_ctrl_step[2],      \"CTRL_EXECUTE\", \t\t\t},\n\t{&slan_op_statis_ctrl_step[3],      \"CTRL_CANCEL\", \t\t\t\t},\n\t{&slan_op_statis_ctrl_type[0],      \"Protocol_IEC103\", \t\t\t},\n\t{&slan_op_statis_ctrl_type[1],      \"Protocol_IEC61850\", \t\t},\n\t{&slan_op_statis_ctrl_type[2],      \"Protocol_LCD\", \t\t\t},\n\t{&slan_drawoff_simple_trip_rpt_header_str,  \"DRAWOFF_SIMPLE_TRIP_REPORT\", }\n};\n\n// 打印功能函数数组\nLOCAL const PrintFunStr s_print_fun_array[] = \n{\n\t{(void*)printIdentityNo,           \"printIdentityNo\",           },\n\t{(void*)printPresentValue,         \"printPresentValue\",         },\n\t{(void*)printBiValue,\t\t\t   \"printBiValue\",\t\t\t    },\n\t{(void*)printSettings,             \"printSettings\",             },\n\t{(void*)printRecentModifySet,      \"printRecentModifySet\",      },\n\t{(void*)printRunRpt,               \"printRunRpt\",               },\n\t{(void*)printTripRpt,              \"printTripRpt\",              },\n\t{(void*)printDrawoffSimpleTripRpt, \"printDrawoffSimpleTripRpt\", },\n\t{(void*)printDrawoffTripRpt,       \"printDrawoffTripRpt\",       },\n\t{(void*)printOscillogram,          \"printOscillogram\",          },\n\t{(void*)printSelfsupervRpt,        \"printSelfsupervRpt\",        },\n\t{(void*)printBinchgRpt,            \"printBinchgRpt\",            },\n\t{(void*)printSoeRpt,\t\t\t   \"printSoeRpt\",\t\t\t    },\n\t{(void*)printChanSupervRpt,        \"printChanSupervRpt\",        },\n\t{(void*)printChanStatisRpt,        \"printChanStatisticRpt\",     },\n\t{(void*)printIec103Proto,          \"printIec103Proto\",          },\n\t{(void*)printOpRpt,  \t\t\t   \"printOpRpt\",     \t        },     \n\t{(void*)printAllDrawoffTripRpt,     \"printAllDrawoffTripRpt\",   }\n};\n\n\n// 本模块公有函数定义\n/*****************************************************************************\n * 函 数 名: printTranslateDesc\n * 描    述: 打印模块描述内容翻译\n * 调 用 者: \n * 输    入: 无\n * 返 回 值: 0表示翻译成功，-1表示翻译失败\n * 日    期: 2015-01-21\n * 修改记录:\n ****************************************************************************/\n INT32 printTranslateDesc(void)\n {\n\t INT32 i = 0, j = 0;\n\t INT8 *p_str = NULL;\n\n\t for (i = 0; i < sizeof(s_print_translate_array) / sizeof(PrintTranslateStr); i++)\n\t {\n\t\t for (j = 0; j < EN_LANGUAGE_TYPE_NUM; j++)\n\t\t {\n\t\t\t p_str = (INT8 *)getLocalLangByAbbr(s_print_translate_array[i].p_abbr_str, j);\n\n\t\t\t if (p_str)\n\t\t\t {\n\t\t\t\t strcpy(s_print_translate_array[i].p_lang_desc->desc[j], p_str);\n\t\t\t }\n\t\t }\n\t }\n\n\t return 0;\n }\n\n /*****************************************************************************\n * 函 数 名: printTabInit\n * 描    述: 将翻译的文字内容嵌入至表格中\n * 调 用 者: \n * 输    入: 无\n * 返 回 值: 0表示初始化成功，-1表示初始化失败\n * 日    期: 2015-01-21\n * 修改记录:\n ****************************************************************************/\n INT32 printTabInit(Print *cp)\n {\n\t INT32 i = 0;\n\t INT8 *p_str = NULL;\n\n\t for (i = 0; i < EN_LANGUAGE_TYPE_NUM; i++)\n\t {\n\t\t // \"┃ 序号 │ 描        述 : 实  际  值 ┃\"\n\t\t p_str = identity_no_line_tab1[cp->print_method][i];\n\t\t printTabAddDesc(p_str + 2, slan_serial_no_str.desc[i], 4);\n\t\t printTabAddDesc(p_str + 8, slan_desc_str.desc[i], 60);\n\t\t printTabAddDesc(p_str + 68, slan_actual_value_str.desc[i], 42);\n\n\t\t // \"┃ 序号 │ 描        述 : 实际值  │序号│ 描        述 : 实际值┃\"\n\t\t p_str = present_value_line_tab1[cp->print_method][i];\n\t\t printTabAddDesc(p_str + 2, slan_serial_no_str.desc[i], 4);\n\t\t printTabAddDesc(p_str + 8, slan_desc_str.desc[i], 32);\n\t\t printTabAddDesc(p_str + 42, slan_actual_value_str.desc[i], 14);\n\t\t printTabAddDesc(p_str + 58, slan_serial_no_str.desc[i], 4);\n\t\t printTabAddDesc(p_str + 64, slan_desc_str.desc[i], 34);\n\t\t printTabAddDesc(p_str + 98, slan_actual_value_str.desc[i], 14);\n\n\t\t // \"┃ 序号 │ 描        述 : 实际值 ：q  │序号│ 描        述 : 实际值 : q  ┃\"\n\t\t p_str = present_value_line_tab1a[cp->print_method][i];\n\t\t printTabAddDesc(p_str + 2, slan_serial_no_str.desc[i], 4);\n\t\t printTabAddDesc(p_str + 8, slan_desc_str.desc[i], 28);\n\t\t printTabAddDesc(p_str + 37, slan_actual_value_str.desc[i], 14);\n\t\t printTabAddDesc(p_str + 52, slan_quality_value_str.desc[i], 4);\n\t\t printTabAddDesc(p_str + 58, slan_serial_no_str.desc[i], 4);\n\t\t printTabAddDesc(p_str + 64, slan_desc_str.desc[i], 28);\n\t\t printTabAddDesc(p_str + 93, slan_actual_value_str.desc[i], 14);\n\t\t printTabAddDesc(p_str + 108, slan_quality_value_str.desc[i], 4);\n\n\t\t // \"┃ 描           述┃1 0 9 8│7 6 5 4│3 2 1 0│9 8 7 6┃5 4 3 2│1 0 9 8│7 6 5 4│3 2 1 0┃\"\n\t\t p_str = setting_matrix_line_tab5[cp->print_method][i];\n\t\t printTabAddDesc(p_str + 2, slan_desc_str.desc[i], 38);\n\n\t\t // \"┃序号│描        述:更 改 前 数 值    更 改 后 数 值    量纲   ┃\"\n\t\t p_str = latest_modify_line_tab1[cp->print_method][i];\n\t\t printTabAddDesc(p_str + 2, slan_serial_no_str.desc[i], 4);\n\t\t printTabAddDesc(p_str + 8, slan_desc_str.desc[i], 42);\n\t\t printTabAddDesc(p_str + 52, slan_set_before_modify_str.desc[i], 24);\n\t\t printTabAddDesc(p_str + 77, slan_set_after_modify_str.desc[i], 24);\n\t\t printTabAddDesc(p_str + 103, slan_set_dimension_str.desc[i], 10);\n\n\t\t // \"┃报告序号│ 动   作   时   间│动     作     元     件│ 动作信息 ┃\"\n\t\t p_str = item_trip_rpt_line_tab1[cp->print_method][i];\n\t\t printTabAddDesc(p_str + 2, slan_serial_no_str.desc[i], 8);\n\t\t printTabAddDesc(p_str + 12, slan_trip_time_str.desc[i], 36);\n\t\t printTabAddDesc(p_str + 50, slan_trip_element_str.desc[i], 50);\n\t\t printTabAddDesc(p_str + 102, slan_trip_value_str.desc[i], 10);\n\n\t\t // \"┃报告序号│起   动   时   间│ 相对时间 │ 动作相别 │动     作     元     件┃\"\n\t\t p_str = drawoff_trip_rpt_line_tab1[cp->print_method][i];\n\t\t printTabAddDesc(p_str + 2, slan_serial_no_str.desc[i], 8);\n\t\t printTabAddDesc(p_str + 12, slan_pickup_time_str.desc[i], 28);\n\t\t printTabAddDesc(p_str + 42, slan_relative_time_str.desc[i], 10);\n\t\t printTabAddDesc(p_str + 54, slan_trip_phase_str.desc[i], 10);\n\t\t printTabAddDesc(p_str + 66, slan_trip_element_str.desc[i], 46);\n\n\t\t // \"┃序号│描      述 : 状态值 │序号│ 描      述 : 状态值 ┃\"\n\t\t p_str = event_init_line_tab1[cp->print_method][i];\n\t\t printTabAddDesc(p_str + 2, slan_serial_no_str.desc[i], 4);\n\t\t printTabAddDesc(p_str + 8, slan_desc_str.desc[i], 40);\n\t\t printTabAddDesc(p_str + 48, slan_actual_value_str.desc[i], 8);\n\t\t printTabAddDesc(p_str + 58, slan_serial_no_str.desc[i], 4);\n\t\t printTabAddDesc(p_str + 64, slan_desc_str.desc[i], 40);\n\t\t printTabAddDesc(p_str + 104, slan_actual_value_str.desc[i], 8);\n\n\t\t // \"┃序号│相对时间│描      述 : 变化值 │序号│相对时间│描      述 : 变化值 ┃\"\n\t\t p_str = event_change_line_tab1[cp->print_method][i];\n\t\t printTabAddDesc(p_str + 2, slan_serial_no_str.desc[i], 4);\n\t\t printTabAddDesc(p_str + 8, slan_relative_time_str.desc[i], 8);\n\t\t printTabAddDesc(p_str + 18, slan_desc_str.desc[i], 30);\n\t\t printTabAddDesc(p_str + 48, slan_actual_value_str.desc[i], 8);\n\t\t printTabAddDesc(p_str + 58, slan_serial_no_str.desc[i], 4);\n\t\t printTabAddDesc(p_str + 64, slan_relative_time_str.desc[i], 8);\n\t\t printTabAddDesc(p_str + 74, slan_desc_str.desc[i], 30);\n\t\t printTabAddDesc(p_str + 104, slan_actual_value_str.desc[i], 8);\n\n\t\t // \"┃报告序号│报   警   时   间│报     警     元     件│ 报警信息 ┃\"\n\t\t p_str = auto_selfcheck_line_tab1[cp->print_method][i];\n\t\t printTabAddDesc(p_str + 2, slan_serial_no_str.desc[i], 8);\n\t\t printTabAddDesc(p_str + 12, slan_selfcheck_alarm_time.desc[i], 36);\n\t\t printTabAddDesc(p_str + 50, slan_selfcheck_alarm_element.desc[i], 50);\n\t\t printTabAddDesc(p_str + 102, slan_actual_value_str.desc[i], 10);\n\n\t\t // \"┃报告序号│报   警   时   间│ 报警相别 │报     警     元     件│ 报警信息 ┃\"\n\t\t p_str = selfcheck_line_tab1[cp->print_method][i];\n\t\t printTabAddDesc(p_str + 2, slan_serial_no_str.desc[i], 8);\n\t\t printTabAddDesc(p_str + 12, slan_selfcheck_alarm_time.desc[i], 28);\n\t\t printTabAddDesc(p_str + 42, slan_selfcheck_alarm_phase.desc[i], 10);\n\t\t printTabAddDesc(p_str + 54, slan_selfcheck_alarm_element.desc[i], 46);\n\t\t printTabAddDesc(p_str + 102, slan_actual_value_str.desc[i], 10);\n\n\t\t // \"┃报告序号│变   位   时   间│变     位     元     件│ 变位信息 ┃\"\n\t\t p_str = binchg_line_tab1[cp->print_method][i];\n\t\t printTabAddDesc(p_str + 2, slan_serial_no_str.desc[i], 8);\n\t\t printTabAddDesc(p_str + 12, slan_binchg_time.desc[i], 36);\n\t\t printTabAddDesc(p_str + 50, slan_binchg_element.desc[i], 50);\n\t\t printTabAddDesc(p_str + 102, slan_actual_value_str.desc[i], 10);\n\n\t\t // \"┃报告序号│变   位   时   间│变     位     元     件│ 变位信息 ┃\"\n\t\t p_str = soe_line_tab1[cp->print_method][i];\n\t\t printTabAddDesc(p_str + 2, slan_serial_no_str.desc[i], 8);\n\t\t printTabAddDesc(p_str + 12, slan_soe_time.desc[i], 36);\n\t\t printTabAddDesc(p_str + 50, slan_soe_element.desc[i], 50);\n\t\t printTabAddDesc(p_str + 102, slan_actual_value_str.desc[i], 10);\n\n\t\t // \"┃报告序号│产   生   时   间│运     行     元     件│ 运行信息 ┃\"\n\t\t p_str = run_rpt_line_tab1[cp->print_method][i];\n\t\t printTabAddDesc(p_str + 2, slan_serial_no_str.desc[i], 8);\n\t\t printTabAddDesc(p_str + 12, slan_run_time.desc[i], 36);\n\t\t printTabAddDesc(p_str + 50, slan_run_element.desc[i], 50);\n\t\t printTabAddDesc(p_str + 102, slan_actual_value_str.desc[i], 10);\n\n\t\t // \"┃报告序号│通   道   时   间│通     道     内     容┃\"\n\t\t p_str = chan_superv_line_tab1[cp->print_method][i];\n\t\t printTabAddDesc(p_str + 2, slan_serial_no_str.desc[i], 8);\n\t\t printTabAddDesc(p_str + 12, slan_chan_superv_time.desc[i], 32);\n\t\t printTabAddDesc(p_str + 46, slan_chan_superv_content.desc[i], 66);\n\n\t\t // \"┃序号│统   计   时   间│统 计 元 件│统计值│统 计 元 件│统计值┃\"\n\t\t p_str = chan_statis_line_tab1[cp->print_method][i];\n\t\t if (PRINT_UART_PROTOCOL == cp->print_method)\n\t\t {\n\t\t\t printTabAddDesc(p_str + 2, slan_serial_no_str.desc[i], 4);\n\t\t\t printTabAddDesc(p_str + 8, slan_chan_statis_time.desc[i], 28);\n\t\t\t printTabAddDesc(p_str + 38, slan_chan_statis_element.desc[i], 22);\n\t\t\t printTabAddDesc(p_str + 62, slan_actual_value_str.desc[i], 14);\n\t\t\t printTabAddDesc(p_str + 78, slan_chan_statis_element.desc[i], 22);\n\t\t\t printTabAddDesc(p_str + 102, slan_actual_value_str.desc[i], 14);\n\t\t }\n\t\t else\n\t\t {\n\t\t\t printTabAddDesc(p_str + 2, slan_serial_no_str.desc[i], 4);\n\t\t\t printTabAddDesc(p_str + 6, slan_chan_statis_time.desc[i], 24);\n\t\t\t printTabAddDesc(p_str + 32, slan_chan_statis_element.desc[i], 22);\n\t\t\t printTabAddDesc(p_str + 56, slan_actual_value_str.desc[i], 14);\n\t\t\t printTabAddDesc(p_str + 72, slan_chan_statis_element.desc[i], 22);\n\t\t\t printTabAddDesc(p_str + 96, slan_actual_value_str.desc[i], 14);\n\t\t }\n\t\t \n\n\t\t // \"┃序号│控制时间│操作对象│执行结果│操作参数│值│操作步骤│操作类型│地址┃\"\n\t\t p_str = op_statis_line_tab1[cp->print_method][i];\n\t\t if (PRINT_UART_PROTOCOL == cp->print_method)\n\t\t {\n\t\t\t printTabAddDesc(p_str + 2, slan_serial_no_str.desc[i], 4);\n\t\t\t printTabAddDesc(p_str + 16, slan_op_time.desc[i], 8);\n\t\t\t printTabAddDesc(p_str + 40, slan_op_element.desc[i], 8);\n\t\t\t printTabAddDesc(p_str + 60, slan_op_result.desc[i], 8);\n\t\t\t printTabAddDesc(p_str + 74, slan_op_para.desc[i], 8);\n\t\t\t printTabAddDesc(p_str + 84, slan_op_direc.desc[i], 8);\n\t\t\t printTabAddDesc(p_str + 94, slan_op_step.desc[i], 4);\n\t\t\t printTabAddDesc(p_str + 100, slan_op_type.desc[i], 8);\n\t\t\t printTabAddDesc(p_str + 110, slan_op_console_id.desc[i], 6);\n\t\t }\n\t\t else\n\t\t {\n\t\t\t printTabAddDesc(p_str + 2, slan_serial_no_str.desc[i], 4);\n\t\t\t printTabAddDesc(p_str + 16, slan_op_time.desc[i], 8);\n\t\t\t printTabAddDesc(p_str + 40, slan_op_element.desc[i], 8);\n\t\t\t printTabAddDesc(p_str + 60, slan_op_result.desc[i], 8);\n\t\t\t printTabAddDesc(p_str + 74, slan_op_para.desc[i], 8);\n\t\t\t printTabAddDesc(p_str + 84, slan_op_direc.desc[i], 2);\n\t\t\t printTabAddDesc(p_str + 88, slan_op_step.desc[i], 4);\n\t\t\t printTabAddDesc(p_str + 94, slan_op_type.desc[i], 8);\n\t\t\t printTabAddDesc(p_str + 104, slan_op_console_id.desc[i], 6);\n\t\t }\n\t }\n\n\t return 0;\n }\n\n/*****************************************************************************\n * 函 数 名: printGetFunAddr\n * 描    述: 根据功能函数描述获取功能函数指针\n * 调 用 者: \n * 输    入: fun_str为功能函数描述\n * 返 回 值: NULL表示获取失败，否则返回功能函数指针\n * 日    期: 2015-01-21\n * 修改记录:\n ****************************************************************************/\n PrintFunPtr printGetFunAddr(const INT8 *fun_str)\n {\n\t INT32 i = 0;\n\n\t for (i = 0; i < sizeof(s_print_fun_array) / sizeof(PrintFunStr); i++)\n\t {\n\t\t if (0 == strcmp(fun_str, s_print_fun_array[i].print_fun_name))\n\t\t {\n\t\t\t return s_print_fun_array[i].func;\n\t\t }\n\t }\n\n\t return NULL;\n }\n\n/*****************************************************************************\n * 函 数 名: printAutoTrip\n * 描    述: 自动打印跳闸报告\n * 调 用 者: \n * 输    入: cp为打印元件指针\n * 返 回 值: 无\n * 日    期: 2015-02-02\n * 修改记录:\n ****************************************************************************/\n void printAutoTrip(Print *cp)\n {\n\t if (PRINT_UART_PROTOCOL == cp->print_method)\n\t {\n\t\t printAutoTripUart(cp);\n\t }\n\t else\n\t {\n\t\t printAutoTripNet(cp);\n\t }\n\n\t return;\n }\n\n/*****************************************************************************\n * 函 数 名: printAutoFault\n * 描    述: 自动打印跳闸报告\n * 调 用 者: \n * 输    入: cp为打印元件指针\n * 返 回 值: 无\n * 日    期: 2016-05-23\n * 修改记录:\n ****************************************************************************/\n void printAutoFault(Print *cp)\n {\n\t if (PRINT_UART_PROTOCOL == cp->print_method)\n\t {\n\t\t printAutoFaultUart(cp);\n\t }\n\t else\n\t {\n\t\t printAutoFaultNet(cp);\n\t }\n\n\t return;\n }\n\n/*****************************************************************************\n * 函 数 名: printAutoSelfsuperv\n * 描    述: 自动打印自检报告\n * 调 用 者: \n * 输    入: cp为打印元件指针\n * 返 回 值: 无\n * 日    期: 2015-02-02\n * 修改记录:\n ****************************************************************************/\n void printAutoSelfsuperv(Print *cp)\n {\n\t if (PRINT_UART_PROTOCOL == cp->print_method)\n\t {\n\t\t printAutoSelfsupervUart(cp);\n\t }\n\t else\n\t {\n\t\t printAutoSelfsupervNet(cp);\n\t }\n\n\t return;\n }\n\n/*****************************************************************************\n * 函 数 名: printAutoBinchg\n * 描    述: 自动打印变位报告\n * 调 用 者: \n * 输    入: cp为打印元件指针\n * 返 回 值: 无\n * 日    期: 2015-02-02\n * 修改记录:\n ****************************************************************************/\n void printAutoBinchg(Print *cp)\n {\n\t if (PRINT_UART_PROTOCOL == cp->print_method)\n\t {\n\t\t printAutoBinchgUart(cp);\n\t }\n\t else\n\t {\n\t\t printAutoBinchgNet(cp);\n\t }\n\n\t return;\n }\n\n // 本模块私有函数定义\n /* 在表格空格中加入描述 */\n LOCAL INT32 printTabAddDesc(INT8 *dst, const INT8 *src, INT32 len)\n {\n\t INT32 src_len = strlen(src);\n\n\t // 源字符串太长，不拷贝\n\t if (src_len > len)\n\t {\n\t\t PRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printTabAddDesc) Str %s is too long!\\n\", src);\n\t\t return -1;\n\t }\n\n\t // 居中拷贝\n\t dst += ((len - src_len) >> 1);\n\t memcpy(dst, src, src_len);\n\n\t return 0;\n }\n\n /* 打印标识 */\n LOCAL void printIdentityNo(Print *cp)\n {\n\t if (PRINT_UART_PROTOCOL == cp->print_method)\n\t {\n\t\t printIdentityNoUart(cp);\n\t }\n\t else if (PRINT_ETH_PROTOCOL == cp->print_method)\n\t {\n\t\t printIdentityNoNet(cp);\n\t }\n\n\t return;\n }\n\n LOCAL void printIdentityNoUart(Print *cp)\n {\n\t INT8 local_item_valid = 0;\n\t INT32 i = 0;\n\t INT8 *p_desc = NULL, *p_value = NULL, tmp_str[64] = { 0 };\n\t DevInfo *p_dev_inf = NULL;\n\n\t p_dev_inf = getDevInfo();\n\t if (NULL == p_dev_inf)\n\t {\n\t\t return;\n\t }\n\n\t // 打印标题\n\t printHeaderLineUart(cp, slan_equip_desc_str.desc[cp->dev_cfg.lang_sel]);\n\n\t // 表格线\n\t printStrLine(cp, identity_no_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t printStrLine(cp, identity_no_line_tab1[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t i = 0;\n\t while(1)\n\t {\n\t\t local_item_valid = 1;\n\n\t\t if (0 == i)\n\t\t {\n\t\t\t p_desc = (INT8 *)slan_equip_type.desc[cp->dev_cfg.lang_sel];\n\t\t\t p_value = p_dev_inf->dev_type;\n\t\t }\n\t\t else if (1 == i)\n\t\t {\n\t\t\t p_desc = (INT8 *)slan_equip_name.desc[cp->dev_cfg.lang_sel];\n\t\t\t p_value = p_dev_inf->dev_name;\n\t\t }\n\t\t /*去除生产厂家，与lcd显示信息保持一致*/\n\t\t /*else if (2 == i)\n\t\t {\n\t\t\t p_desc = (INT8 *)slan_manufacturer_str.desc[cp->dev_cfg.lang_sel];\n\t\t\t p_value = p_dev_inf->factory;\n\t\t }*/\n\t\t else if (2 == i)\n\t\t {\n\t\t\t p_desc = (INT8 *)slan_prog_ver_str.desc[cp->dev_cfg.lang_sel];\n\t\t\t p_value = p_dev_inf->ver;\n\t\t }\n\t\t else if (3 == i)\n\t\t {\n\t\t\t p_desc = (INT8 *)slan_prog_time.desc[cp->dev_cfg.lang_sel];\n\t\t\t p_value = p_dev_inf->dev_prog_time_str;\n\t\t }\n\t\t else if (4 == i)\n\t\t {\n\t\t\t p_desc = (INT8 *)slan_prog_chksum.desc[cp->dev_cfg.lang_sel];\n\t\t\t p_value = p_dev_inf->dev_prog_crc_str;\n\t\t }\n\t\t //以下三个为\"FPGA版本\"新增内容, add by wzc 2016.9.28\n\t\t else if (5 == i)\n\t\t {\n\t\t\t p_desc = (INT8 *)slan_fpga_ver.desc[cp->dev_cfg.lang_sel];\n\t\t\t strcpy(tmp_str, \"V1.00\");\n\t\t\t p_value = tmp_str;\n\t\t }\n\t\t else if (6 == i)\n\t\t {\n\t\t\t p_desc = (INT8 *)slan_fpga_time.desc[cp->dev_cfg.lang_sel];\n\t\t\t strcpy(tmp_str, \"2016-2-26 17:28:35\");\n\t\t\t p_value = tmp_str;\n\t\t }\n\t\t else if (7 == i)\n\t\t {\n\t\t\t p_desc = (INT8 *)slan_fpga_crc.desc[cp->dev_cfg.lang_sel];\n\t\t\t strcpy(tmp_str, \"7E2FA60B\");\n\t\t\t p_value = tmp_str;\n\t\t }\n\t\t //新增二次单号，和LCD模块保持一致\n\t\t else if (8 == i)\n\t\t {\n\t\t\t p_desc = (INT8 *)slan_develop_no_str.desc[cp->dev_cfg.lang_sel];\n\t\t\t p_value = p_dev_inf->rd_no;\n\t\t }\n\t\t else if (9 == i)\n\t\t {\n\t\t\t p_desc = (INT8 *)slan_subq_no_str.desc[cp->dev_cfg.lang_sel];\n\t\t\t p_value = p_dev_inf->subq_no;\n\t\t }\n\t\t else if (10 == i)\n\t\t {\n\t\t\t p_desc = (INT8 *)slan_dev_icd_crc.desc[cp->dev_cfg.lang_sel];\n\t\t\t p_value = p_dev_inf->dev_icd_crc_str;\n\t\t }\n\t\t else if (11 == i)\n\t\t {\n\t\t\t p_desc = (INT8 *)slan_dev_scd_crc.desc[cp->dev_cfg.lang_sel];\n\t\t\t p_value = p_dev_inf->dev_scd_crc_str;\n\t\t }\n\t\t else if (12 == i)\n\t\t {\n\t\t\t p_desc = (INT8 *)slan_dev_unique.desc[cp->dev_cfg.lang_sel];\n\t\t\t sysGetUniqueId(tmp_str);\n\t\t\t p_value = tmp_str;\n\t\t }\n\t\t else\n\t\t {\n\t\t\t p_desc = NULL;\n\t\t\t p_value = NULL;\n\t\t }\n\n\t\t i++;\n\n\t\t if (local_item_valid)\n\t\t {\n\t\t\t printStrLine(cp, identity_no_line_tab2[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t\t\t // 序号\n\t\t\t cp->print_ptr += 1;\n\t\t\t sprintf(cp->print_ptr, \"%02d\", i);\n\t\t\t cp->print_ptr += 2;\n\t\t\t *cp->print_ptr++ = ' ';\n\t\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t\t\t cp->print_ptr += 6;\n\t\t\t printAddStrToBufAndModifyPtr(cp, p_desc, 52);\n\t\t\t *cp->print_ptr++ = ':';\n\t\t\t cp->print_ptr += 2;\n\t\t\t printAddStrToBufAndModifyPtr(cp, p_value, 43);\n\n\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t printCharLine(cp, WITH_RETURN);\n\t\t }\n\n\t\t if (i >= 13)\t\t\t//增加三个FPGA内容\t\n\t\t {\n\t\t\t break;\n\t\t }\n\t }\n\n\t printStrLine(cp, identity_no_line_tab3[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\nprintf(\"[%s, %d]\\n\", __FUNCTION__, __LINE__);\nprintf(\"method = %d, lang_sel = %d\\n\", cp->print_method, cp->dev_cfg.lang_sel);\n\n\t printCharLine(cp, WITH_RETURN);\n\n\t return;\n }\n\nLOCAL void printIdentityNoNet(Print *cp)\n{\n\tINT8 local_item_valid = 0;\n\tINT32 i = 0;\n\tINT8 *p_desc = NULL, *p_value = NULL, tmp_str[64] = { 0 };\n\tDevInfo *p_dev_inf = NULL;\n\n\tp_dev_inf = getDevInfo();\n\tif (NULL == p_dev_inf)\n\t{\n\t\treturn;\n\t}\n\n\t// 打印标题\n\tprintHeaderLineNet(cp, slan_equip_desc_str.desc[cp->dev_cfg.lang_sel]);\n\n\t// 表格线\n\tprintStrLine(cp, identity_no_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\tprintStrLine(cp, identity_no_line_tab1[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\ti = 0;\n\twhile(1)\n\t{\n\t\tlocal_item_valid = 1;\n\n\t\tif (0 == i)\n\t\t{\n\t\t\tp_desc = (INT8 *)slan_equip_type.desc[cp->dev_cfg.lang_sel];\n\t\t\tp_value = p_dev_inf->dev_type;\n\t\t}\n\t\telse if (1 == i)\n\t\t{\n\t\t\tp_desc = (INT8 *)slan_equip_name.desc[cp->dev_cfg.lang_sel];\n\t\t\tp_value = p_dev_inf->dev_name;\n\t\t}\n\t\telse if (2 == i)\n\t\t{\n\t\t\tp_desc = (INT8 *)slan_manufacturer_str.desc[cp->dev_cfg.lang_sel];\n\t\t\tp_value = p_dev_inf->factory;\n\t\t}\n\t\telse if (3 == i)\n\t\t{\n\t\t\tp_desc = (INT8 *)slan_prog_ver_str.desc[cp->dev_cfg.lang_sel];\n\t\t\tp_value = p_dev_inf->ver;\n\t\t}\n\t\telse if (4 == i)\n\t\t{\n\t\t\tp_desc = (INT8 *)slan_prog_time.desc[cp->dev_cfg.lang_sel];\n\t\t\tp_value = p_dev_inf->dev_prog_time_str;\n\t\t}\n\t\telse if (5 == i)\n\t\t{\n\t\t\tp_desc = (INT8 *)slan_prog_chksum.desc[cp->dev_cfg.lang_sel];\n\t\t\tp_value = p_dev_inf->dev_prog_crc_str;\n\t\t}\n\t\telse if (6 == i)\n\t\t{\n\t\t\tp_desc = (INT8 *)slan_subq_no_str.desc[cp->dev_cfg.lang_sel];\n\t\t\tp_value = p_dev_inf->subq_no;\n\t\t}\n\t\telse if (7 == i)\n\t\t{\n\t\t\tp_desc = (INT8 *)slan_dev_icd_crc.desc[cp->dev_cfg.lang_sel];\n\t\t\tp_value = p_dev_inf->dev_icd_crc_str;\n\t\t}\n\t\telse if (8 == i)\n\t\t{\n\t\t\tp_desc = (INT8 *)slan_dev_scd_crc.desc[cp->dev_cfg.lang_sel];\n\t\t\tp_value = p_dev_inf->dev_scd_crc_str;\n\t\t}\n\t\telse if (9 == i)\n\t\t{\n\t\t\tp_desc = (INT8 *)slan_dev_id.desc[cp->dev_cfg.lang_sel];\n\t\t\tp_value = p_dev_inf->dev_id_str;\n\t\t}\n\t\telse if (10 == i)\n\t\t{\n\t\t\tp_desc = (INT8 *)slan_dev_unique.desc[cp->dev_cfg.lang_sel];\n\t\t\tsysGetUniqueId(tmp_str);\n\t\t\tp_value = tmp_str;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tp_desc = NULL;\n\t\t\tp_value = NULL;\n\t\t}\n\n\t\ti++;\n\n\t\tif (local_item_valid)\n\t\t{\n\t\t\tprintStrLine(cp, identity_no_line_tab2[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t\t\tprintAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t\t\t// 序号\n\t\t\tcp->print_ptr += 1;\n\t\t\tsprintf(cp->print_ptr, \"%02d\", i);\n\t\t\tcp->print_ptr += 2;\n\t\t\t*cp->print_ptr++ = ' ';\n\t\t\tprintAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t\t\tcp->print_ptr += 6;\n\t\t\tprintAddStrToBufAndModifyPtr(cp, p_desc, 52);\n\t\t\t*cp->print_ptr++ = ':';\n\t\t\tcp->print_ptr += 2;\n\t\t\tprintAddStrToBufAndModifyPtr(cp, p_value, 43);\n\n\t\t\tprintAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\tprintCharLine(cp, WITH_RETURN);\n\t\t}\n\n\t\tif (i >= 11)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprintStrLine(cp, identity_no_line_tab3[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\tprintCharLine(cp, WITH_RETURN);\n\n\treturn;\n}\n\n /* 打印当前值 */\n LOCAL void printPresentValue(Print *cp)\n {\n\t if (PRINT_UART_PROTOCOL == cp->print_method)\n\t {\n\t\t printPresentValueUart(cp);\n\t }\n\t else if (PRINT_ETH_PROTOCOL == cp->print_method)\n\t {\n\t\t printPresentValueNet(cp);\n\t }\n\n\t return;\n }\n\n LOCAL void printPresentValueUart(Print *cp)\n {\n\t DataFields *p_datafield = NULL;\n\t INT32 i = 0, j = 0, m = 0, n = 0, row_num = 0, sum_index = 0, print_item_num = 0;\n\t INT8 local_buf[64] = { 0 };\n\t InVar *p_invar = NULL, *p_quality_invar = NULL;\n\t UINT16 each_group_num_max = 0;\n\t INT32 local_no = 0, show_primary_secondary_flag = 0;\n\t RefParameterItems *p_ref_tbl_item = NULL;\n\t PrintRefInfo *p_ref_info_title = NULL, *p_ref_info_ana = NULL;\n\t UINT8 tran_val = 0;\n\n\t p_ref_info_title = (PrintRefInfo *)s_ref_tbl_cfg[EN_REF_TBL_ANALOG_TITLE].p_ref_info;\n\t p_ref_tbl_item = p_ref_info_title->p_tbl;\n\t p_ref_info_ana = (PrintRefInfo *)s_ref_tbl_cfg[EN_REF_TBL_ANALOG].p_ref_info;\n\nprintf(\"[%s, %d]: \\n\", __FUNCTION__, __LINE__);\n\n\t // 分组循环\n\t for(m = 0; m < p_ref_tbl_item->num; m++)\n\t {\n\t\t sum_index = 0;\n\t\t for (j = 0; j < m; j++)\n\t\t {\n\t\t\t sum_index += cp->analog_item_num[j];\n\t\t }\n\n\t\t show_primary_secondary_flag = 0;\n\t\t print_item_num = 0;\n\t\t for (i = 0; i < cp->analog_item_num[m]; i++)\n\t\t {\n\t\t\t p_datafield = p_ref_info_ana->p_item[sum_index + i].p_datafield;\n\t\t\t if (DESC_PRINT_VISIBLE(p_datafield))\n\t\t\t {\n\t\t\t\t cp->p_analog_item_offset[print_item_num] = sum_index + i;\n\n\t\t\t\t if (strstr(p_datafield->unit, \"A\") || strstr(p_datafield->unit, \"V\"))\n\t\t\t\t {\n\t\t\t\t\t show_primary_secondary_flag = 1;\n\t\t\t\t }\n\n\t\t\t\t print_item_num++;\n\t\t\t }\n\t\t }\n\n\t\t if (0 == print_item_num)\n\t\t {\n\t\t\t continue;\n\t\t }\n\n\t\t if (cp->print_shm_content.print_para_num)\n\t\t {\n\t\t\t for (i = 0; i < cp->print_shm_content.print_para_num; i++)\n\t\t\t {\n\t\t\t\t if (m == cp->print_shm_content.print_para_val[i])\n\t\t\t\t {\n\t\t\t\t\t break;\n\t\t\t\t }\n\t\t\t }\n\n\t\t\t if (i == cp->print_shm_content.print_para_num)\n\t\t\t {\n\t\t\t\t continue;\n\t\t\t }\n\t\t }\n\n\t\t // 打印标题\n\t\t printHeaderLineUart(cp, getLocalLangByAbbr(p_ref_tbl_item->item[m], cp->dev_cfg.lang_sel));\n\nprintf(\"m = %d, header_str is %s\\n\", m, getLocalLangByAbbr(p_ref_tbl_item->item[m], cp->dev_cfg.lang_sel));\n\n\t\t if (show_primary_secondary_flag)\n\t\t {\n\t\t\t strcpy(local_buf, \"(\");\n\n\t\t\t if (1 == printGetInVar(EN_IN_SIG_PRIM_OR_SEC))\n\t\t\t {\n\t\t\t\t strcat(local_buf, slan_prim_value_str.desc[cp->dev_cfg.lang_sel]);\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t strcat(local_buf, slan_second_value_str.desc[cp->dev_cfg.lang_sel]);\n\t\t\t }\n\n\t\t\t strcat(local_buf, \")\");\n\n\t\t\t printAddStrToBuf(cp, local_buf);\n\t\t\t printCharLine(cp, WITH_RETURN);\n\t\t }\n\n\t\t printStrLine(cp, (INT8 *)present_value_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t\t printStrLine(cp, (INT8 *)present_value_line_tab1a[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t\t row_num = (print_item_num + 1) >> 1;\n\n\t\t // 行循环\n\t\t for (i = 0; i < row_num; i++)\n\t\t {\n\t\t\t printStrLine(cp, present_value_line_tab2[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t\t\t // 两列循环\n\t\t\t for (n = 0; n < 2; n++)\n\t\t\t {\n\t\t\t\t if (0 == n)\n\t\t\t\t {\n\t\t\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t\t }\n\t\t\t\t else\n\t\t\t\t {\n\t\t\t\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t\t }\n\n\t\t\t\t // 序号\n\t\t\t\t if (0 == n)\n\t\t\t\t {\n\t\t\t\t\t local_no = i + 1;\n\t\t\t\t }\n\t\t\t\t else\n\t\t\t\t {\n\t\t\t\t\t local_no = i + 1 + row_num;\n\t\t\t\t }\n\n\t\t\t\t if (local_no < 100)\n\t\t\t\t {\n\t\t\t\t\t cp->print_ptr += 1;\n\t\t\t\t\t sprintf(cp->print_ptr, \"%02d\", local_no);\n\t\t\t\t\t cp->print_ptr += 2;\n\t\t\t\t }\n\t\t\t\t else\n\t\t\t\t {\n\t\t\t\t\t sprintf(cp->print_ptr, \"%03d\", local_no);\n\t\t\t\t\t cp->print_ptr += 3;\n\t\t\t\t }\n\n\t\t\t\t *cp->print_ptr++ = ' ';\n\t\t\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t\t\t\t if (0 == n)\n\t\t\t\t {\n\t\t\t\t\t p_datafield = p_ref_info_ana->p_item[cp->p_analog_item_offset[i]].p_datafield;\n\t\t\t\t }\n\t\t\t\t else\n\t\t\t\t {\n\t\t\t\t\t p_datafield = p_ref_info_ana->p_item[cp->p_analog_item_offset[i + row_num]].p_datafield;\n\t\t\t\t }\n\n\t\t\t\t printAddStrToBufAndModifyPtr(cp, p_datafield->desc, 28);\n\t\t\t\t \n                 if (strlen(p_datafield->desc) > 28)\n                 {\n\t\t\t\t \tcp->print_ptr += (strlen(p_datafield->desc) - 28);\n\t\t\t\t \t*cp->print_ptr++ = ':';\n\t\t\t\t\t*cp->print_ptr++ = ' ';\n\t\t\t\t\tcp->print_ptr -= (strlen(p_datafield->desc) - 28);\n                 }\n\t\t\t\t else\n\t\t\t\t {\n\t\t\t\t     *cp->print_ptr++ = ':';\n\t\t\t\t     *cp->print_ptr++ = ' ';\n\t\t\t\t }\n\n\t\t\t\t // 实际值\n\t\t\t\t if (0 == n)\n\t\t\t\t {\n\t\t\t\t\t p_invar = p_ref_info_ana->p_item[cp->p_analog_item_offset[i]].p_invar;\n\t\t\t\t\t p_quality_invar = p_ref_info_ana->p_item[cp->p_analog_item_offset[i]].p_quality_invar;\n\t\t\t\t }\n\t\t\t\t else\n\t\t\t\t {\n\t\t\t\t\t p_invar = p_ref_info_ana->p_item[cp->p_analog_item_offset[i + row_num]].p_invar;\n\t\t\t\t\t p_quality_invar = p_ref_info_ana->p_item[cp->p_analog_item_offset[i + row_num]].p_quality_invar;\n\t\t\t\t }\n\n\t\t\t\t if (p_invar)\n\t\t\t\t {\n\t\t\t\t\t printInvarFormatToBuffer(p_datafield, p_invar, cp->print_ptr, cp->print_ptr + 8 - 1, printGetInVar(EN_IN_SIG_PRIM_OR_SEC) - 1);\n\t\t\t\t }\n\n\t\t\t\t cp->print_ptr += 9;\n\n\t\t\t\t printAddStrToBufAndModifyPtr(cp, p_datafield->unit, 4);\n\n\t\t\t\t *cp->print_ptr++ = ':';\n\n\t\t\t\t if (NULL == p_quality_invar)\n\t\t\t\t {\n\t\t\t\t\t printAddStrToBufAndModifyPtr(cp, \" \", 4);\n\t\t\t\t }\n\t\t\t\t else if ((BITS_TYPE == p_datafield->type) || (INT8_TYPE == p_datafield->type) ||\n\t\t\t\t\t (UINT8_TYPE == p_datafield->type))\n\t\t\t\t {\n\t\t\t\t\t GET_INVAL_VAL(&tran_val, p_quality_invar);\n\t\t\t\t\t if (GOOSE_Q_VALID != (tran_val & GOOSE_Q_VALID))\n\t\t\t\t\t {\n\t\t\t\t\t\t printAddStrToBufAndModifyPtr(cp, \"I\", 1);\n\t\t\t\t\t }\n\t\t\t\t\t else\n\t\t\t\t\t {\n\t\t\t\t\t\t printAddStrToBufAndModifyPtr(cp, \" \", 1);\n\t\t\t\t\t }\n\n\t\t\t\t\t if (GOOSE_Q_RX_TEST == (tran_val & GOOSE_Q_RX_TEST))\n\t\t\t\t\t {\n\t\t\t\t\t\t printAddStrToBufAndModifyPtr(cp, \"T\", 1);\n\t\t\t\t\t }\n\t\t\t\t\t else\n\t\t\t\t\t {\n\t\t\t\t\t\t printAddStrToBufAndModifyPtr(cp, \" \", 1);\n\t\t\t\t\t }\n\n\t\t\t\t\t if (GOOSE_Q_LINK_OK != (tran_val & GOOSE_Q_LINK_OK))\n\t\t\t\t\t {\n\t\t\t\t\t\t printAddStrToBufAndModifyPtr(cp, \"L\", 1);\n\t\t\t\t\t }\n\t\t\t\t\t else\n\t\t\t\t\t {\n\t\t\t\t\t\t printAddStrToBufAndModifyPtr(cp, \" \", 1);\n\t\t\t\t\t }\n\n\t\t\t\t\t printAddStrToBufAndModifyPtr(cp, \" \", 1);\n\t\t\t\t }\n\t\t\t\t else\n\t\t\t\t {\n\t\t\t\t\t GET_INVAL_VAL(&tran_val, p_quality_invar);\n\n\t\t\t\t\t if (SV_Q_VALID != (tran_val & SV_Q_VALID))\n\t\t\t\t\t {\n\t\t\t\t\t\t printAddStrToBufAndModifyPtr(cp, \"I\", 1);\n\t\t\t\t\t }\n\t\t\t\t\t else\n\t\t\t\t\t {\n\t\t\t\t\t\t printAddStrToBufAndModifyPtr(cp, \" \", 1);\n\t\t\t\t\t }\n\n\t\t\t\t\t if (SV_Q_RX_TEST == (tran_val & SV_Q_RX_TEST))\n\t\t\t\t\t {\n\t\t\t\t\t\t printAddStrToBufAndModifyPtr(cp, \"T\", 1);\n\t\t\t\t\t }\n\t\t\t\t\t else\n\t\t\t\t\t {\n\t\t\t\t\t\t printAddStrToBufAndModifyPtr(cp, \" \", 1);\n\t\t\t\t\t }\n\n\t\t\t\t\t if (SV_Q_OVERFLOW == (tran_val & SV_Q_OVERFLOW))\n\t\t\t\t\t {\n\t\t\t\t\t\t printAddStrToBufAndModifyPtr(cp, \"O\", 1);\n\t\t\t\t\t }\n\t\t\t\t\t else\n\t\t\t\t\t {\n\t\t\t\t\t\t printAddStrToBufAndModifyPtr(cp, \" \", 1);\n\t\t\t\t\t }\n\n\t\t\t\t\t printAddStrToBufAndModifyPtr(cp, \" \", 1);\n\t\t\t\t }\n\n\t\t\t\t if ((i == row_num - 1) && (print_item_num & 0x01))\n\t\t\t\t {\n\t\t\t\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t\t\t cp->print_ptr += 4;\n\t\t\t\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t\t\t cp->print_ptr += 28;\n\t\t\t\t\t *cp->print_ptr++ = ':';\n\t\t\t\t\t cp->print_ptr += 14;\n\t\t\t\t\t *cp->print_ptr++ = ':';\n\t\t\t\t\t cp->print_ptr += 4;\n\t\t\t\t\t break;\n\t\t\t\t }\n\t\t\t }\n\n\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t printCharLine(cp, WITH_RETURN);\n\t\t }\n\n\t\t printStrLine(cp, present_value_line_tab3[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t\t printCharLine(cp, WITH_RETURN);\n\t }\n\n\t return;\n }\n\nLOCAL void printPresentValueNet(Print *cp)\n{\n\tDataFields *p_datafield = NULL;\n\tINT32 i = 0, j = 0, m = 0, n = 0, row_num = 0, sum_index = 0, print_item_num = 0;\n\tINT8 local_buf[64] = { 0 };\n\tInVar *p_invar = NULL, *p_quality_invar = NULL;\n\tUINT16 each_group_num_max = 0;\n\tINT32 local_no = 0, show_primary_secondary_flag = 0;\n\tRefParameterItems *p_ref_tbl_item = NULL;\n\tPrintRefInfo *p_ref_info_title = NULL, *p_ref_info_ana = NULL;\n\tUINT8 tran_val = 0;\n\n\tp_ref_info_title = (PrintRefInfo *)s_ref_tbl_cfg[EN_REF_TBL_ANALOG_TITLE].p_ref_info;\n\tp_ref_tbl_item = p_ref_info_title->p_tbl;\n\tp_ref_info_ana = (PrintRefInfo *)s_ref_tbl_cfg[EN_REF_TBL_ANALOG].p_ref_info;\n\n\t// 分组循环\n\tfor(m = 0; m < p_ref_tbl_item->num; m++)\n\t{\n\t\tsum_index = 0;\n\t\tfor (j = 0; j < m; j++)\n\t\t{\n\t\t\tsum_index += cp->analog_item_num[j];\n\t\t}\n\n\t\tshow_primary_secondary_flag = 0;\n\t\tprint_item_num = 0;\n\t\tfor (i = 0; i < cp->analog_item_num[m]; i++)\n\t\t{\n\t\t\tp_datafield = p_ref_info_ana->p_item[sum_index + i].p_datafield;\n\t\t\tif (DESC_PRINT_VISIBLE(p_datafield))\n\t\t\t{\n\t\t\t\tcp->p_analog_item_offset[print_item_num] = sum_index + i;\n\n\t\t\t\tif (strstr(p_datafield->unit, \"A\") || strstr(p_datafield->unit, \"V\"))\n\t\t\t\t{\n\t\t\t\t\tshow_primary_secondary_flag = 1;\n\t\t\t\t}\n\n\t\t\t\tprint_item_num++;\n\t\t\t}\n\t\t}\n\n\t\tif (0 == print_item_num)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (cp->print_shm_content.print_para_num)\n\t\t{\n\t\t\tfor (i = 0; i < cp->print_shm_content.print_para_num; i++)\n\t\t\t{\n\t\t\t\tif (m == cp->print_shm_content.print_para_val[i])\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (i == cp->print_shm_content.print_para_num)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t// 打印标题\n\t\tprintHeaderLineNet(cp, getLocalLangByAbbr(p_ref_tbl_item->item[m], cp->dev_cfg.lang_sel));\n\n\t\tif (show_primary_secondary_flag)\n\t\t{\n\t\t\tstrcpy(local_buf, \"(\");\n\n\t\t\tif (1 == printGetInVar(EN_IN_SIG_PRIM_OR_SEC))\n\t\t\t{\n\t\t\t\tstrcat(local_buf, slan_prim_value_str.desc[cp->dev_cfg.lang_sel]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstrcat(local_buf, slan_second_value_str.desc[cp->dev_cfg.lang_sel]);\n\t\t\t}\n\n\t\t\tstrcat(local_buf, \")\");\n\n\t\t\tprintAddStrToBuf(cp, local_buf);\n\t\t\tprintCharLine(cp, WITH_RETURN);\n\t\t}\n\n\t\tprintStrLine(cp, (INT8 *)present_value_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t\tprintStrLine(cp, (INT8 *)present_value_line_tab1a[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t\trow_num = (print_item_num + 1) >> 1;\n\n\t\t// 行循环\n\t\tfor (i = 0; i < row_num; i++)\n\t\t{\n\t\t\tprintStrLine(cp, present_value_line_tab2[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t\t\t// 两列循环\n\t\t\tfor (n = 0; n < 2; n++)\n\t\t\t{\n\t\t\t\tif (0 == n)\n\t\t\t\t{\n\t\t\t\t\tprintAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tprintAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t\t}\n\n\t\t\t\t// 序号\n\t\t\t\tif (0 == n)\n\t\t\t\t{\n\t\t\t\t\tlocal_no = i + 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlocal_no = i + 1 + row_num;\n\t\t\t\t}\n\n\t\t\t\tif (local_no < 100)\n\t\t\t\t{\n\t\t\t\t\tcp->print_ptr += 1;\n\t\t\t\t\tsprintf(cp->print_ptr, \"%02d\", local_no);\n\t\t\t\t\tcp->print_ptr += 2;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsprintf(cp->print_ptr, \"%03d\", local_no);\n\t\t\t\t\tcp->print_ptr += 3;\n\t\t\t\t}\n\n\t\t\t\t*cp->print_ptr++ = ' ';\n\t\t\t\tprintAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t\t\t\tif (0 == n)\n\t\t\t\t{\n\t\t\t\t\tp_datafield = p_ref_info_ana->p_item[cp->p_analog_item_offset[i]].p_datafield;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tp_datafield = p_ref_info_ana->p_item[cp->p_analog_item_offset[i + row_num]].p_datafield;\n\t\t\t\t}\n\n\t\t\t\t printAddStrToBufAndModifyPtr(cp, p_datafield->desc, 28);\n\t\t\t\t \n                 if (strlen(p_datafield->desc) > 28)\n                 {\n\t\t\t\t \tcp->print_ptr += (strlen(p_datafield->desc) - 28);\n\t\t\t\t \t*cp->print_ptr++ = ':';\n\t\t\t\t\t*cp->print_ptr++ = ' ';\n\t\t\t\t\tcp->print_ptr -= (strlen(p_datafield->desc) - 28);\n                 }\n\t\t\t\t else\n\t\t\t\t {\n\t\t\t\t     *cp->print_ptr++ = ':';\n\t\t\t\t     *cp->print_ptr++ = ' ';\n\t\t\t\t }\n\n\t\t\t\t// 实际值\n\t\t\t\tif (0 == n)\n\t\t\t\t{\n\t\t\t\t\tp_invar = p_ref_info_ana->p_item[cp->p_analog_item_offset[i]].p_invar;\n\t\t\t\t\tp_quality_invar = p_ref_info_ana->p_item[cp->p_analog_item_offset[i]].p_quality_invar;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tp_invar = p_ref_info_ana->p_item[cp->p_analog_item_offset[i + row_num]].p_invar;\n\t\t\t\t\tp_quality_invar = p_ref_info_ana->p_item[cp->p_analog_item_offset[i + row_num]].p_quality_invar;\n\t\t\t\t}\n\n\t\t\t\tif (p_invar)\n\t\t\t\t{\n\t\t\t\t\tprintInvarFormatToBuffer(p_datafield, p_invar, cp->print_ptr, cp->print_ptr + 8 - 1, printGetInVar(EN_IN_SIG_PRIM_OR_SEC) - 1);\n\t\t\t\t}\n\n\t\t\t\tcp->print_ptr += 9;\n\n\t\t\t\tprintAddStrToBufAndModifyPtr(cp, p_datafield->unit, 4);\n\n\t\t\t\t*cp->print_ptr++ = ':';\n\n\t\t\t\tif (NULL == p_quality_invar)\n\t\t\t\t{\n\t\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \" \", 4);\n\t\t\t\t}\n\t\t\t\telse if ((BITS_TYPE == p_datafield->type) || (INT8_TYPE == p_datafield->type) ||\n\t\t\t\t\t\t (UINT8_TYPE == p_datafield->type))\n\t\t\t\t{\n\t\t\t\t\tGET_INVAL_VAL(&tran_val, p_quality_invar);\n\t\t\t\t\tif (GOOSE_Q_VALID != (tran_val & GOOSE_Q_VALID))\n\t\t\t\t\t{\n\t\t\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \"I\", 1);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \" \", 1);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (GOOSE_Q_RX_TEST == (tran_val & GOOSE_Q_RX_TEST))\n\t\t\t\t\t{\n\t\t\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \"T\", 1);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \" \", 1);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (GOOSE_Q_LINK_OK != (tran_val & GOOSE_Q_LINK_OK))\n\t\t\t\t\t{\n\t\t\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \"L\", 1);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \" \", 1);\n\t\t\t\t\t}\n\n\t\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \" \", 1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tGET_INVAL_VAL(&tran_val, p_quality_invar);\n\n\t\t\t\t\tif (SV_Q_VALID != (tran_val & SV_Q_VALID))\n\t\t\t\t\t{\n\t\t\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \"I\", 1);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \" \", 1);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (SV_Q_RX_TEST == (tran_val & SV_Q_RX_TEST))\n\t\t\t\t\t{\n\t\t\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \"T\", 1);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \" \", 1);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (SV_Q_OVERFLOW == (tran_val & SV_Q_OVERFLOW))\n\t\t\t\t\t{\n\t\t\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \"O\", 1);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \" \", 1);\n\t\t\t\t\t}\n\n\t\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \" \", 1);\n\t\t\t\t}\n\n\t\t\t\tif ((i == row_num - 1) && (print_item_num & 0x01))\n\t\t\t\t{\n\t\t\t\t\tprintAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t\t\tcp->print_ptr += 4;\n\t\t\t\t\tprintAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t\t\tcp->print_ptr += 28;\n\t\t\t\t\t*cp->print_ptr++ = ':';\n\t\t\t\t\tcp->print_ptr += 14;\n\t\t\t\t\t*cp->print_ptr++ = ':';\n\t\t\t\t\tcp->print_ptr += 4;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprintAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\tprintCharLine(cp, WITH_RETURN);\n\t\t}\n\n\t\tprintStrLine(cp, present_value_line_tab3[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t\tprintCharLine(cp, WITH_RETURN);\n\t}\n\t\n\treturn;\n}\n\n/* 打印开关量及压板状态 */\nLOCAL void printBiValue(Print *cp)\n{\n\tif (PRINT_UART_PROTOCOL == cp->print_method)\n\t{\n\t\tprintBiValueUart(cp);\n\t}\n\telse if (PRINT_ETH_PROTOCOL == cp->print_method)\n\t{\n\t\tprintBiValueNet(cp);\n\t}\n\n\treturn;\n}\n\nLOCAL void printBiValueUart(Print *cp)\n{\n\tPrintRefInfo *p_ref_info = NULL;\n\tRefParameterItems *p_ref_tbl_item = NULL;\n\tInVar *p_invar = NULL, *p_quality_invar = NULL;\n\tINT32 local_no = 0, row_num = 0;\n\tINT32 i = 0, n = 0, print_item_num = 0;\n\tDataFields *p_datafield = NULL;\n\tUINT16 local_bool_value = 0;\n\tUINT8 tran_val = 0;\n\tUINT16 *local_item_offset = NULL;\n\n\tp_ref_info = (PrintRefInfo *)s_ref_tbl_cfg[EN_REF_TBL_BINCHG].p_ref_info;\n\tp_ref_tbl_item = p_ref_info->p_tbl;\n\tlocal_item_offset = (UINT16 *)HOPEMALLOC(p_ref_tbl_item->num * sizeof(UINT16));\n\tif (NULL == local_item_offset)\n\t{\n\t\tPRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printBiValueUart) Malloc failed!\\n\");\n\t\treturn;\n\t}\n\n\t// 打印标题\n\tprintHeaderLineUart(cp, slan_bi_value_str.desc[cp->dev_cfg.lang_sel]);\n\n\t//printStrLine(cp, slan_binchg_init_state_str.desc[cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\tprintStrLine(cp, present_value_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\tprintStrLine(cp, present_value_line_tab1a[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t//print_item_num = p_ref_tbl_item->num;\n\tfor (i = 0; i < p_ref_tbl_item->num; i++)\n\t{\n\t    if ( DESC_PRINT_VISIBLE(p_ref_info->p_item[i].p_datafield) )\n\t    {\n\t        local_item_offset[print_item_num] = i;\n\t\t\tprint_item_num++;\n\t    }\n\t}\n\n\t// 行循环\n\trow_num = (print_item_num + 1) >> 1;\n\tfor (i = 0; i < row_num; i++)\n\t{\n\t\tprintStrLine(cp, present_value_line_tab2[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t\t// 两列循环\n\t\tfor (n = 0; n < 2; n++)\n\t\t{\n\t\t\tif (0 == n)\n\t\t\t{\n\t\t\t\tprintAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t}\n\n\t\t\t// 序号\n\t\t\tif (0 == n)\n\t\t\t{\n\t\t\t\tlocal_no = i + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlocal_no = i + 1 + row_num;\n\t\t\t}\n\n\t\t\tif (local_no < 100)\n\t\t\t{\n\t\t\t\tcp->print_ptr += 1;\n\t\t\t\tsprintf(cp->print_ptr, \"%02d\", local_no);\n\t\t\t\tcp->print_ptr += 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsprintf(cp->print_ptr, \"%03d\", local_no);\n\t\t\t\tcp->print_ptr += 3;\n\t\t\t}\n\n\t\t\t*cp->print_ptr++ = ' ';\n\t\t\tprintAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t\t\tif (0 == n)\n\t\t\t{\n\t\t\t\tp_datafield = p_ref_info->p_item[local_item_offset[i]].p_datafield;\n\t\t\t\tp_invar = p_ref_info->p_item[local_item_offset[i]].p_invar;\n\t\t\t\tp_quality_invar = p_ref_info->p_item[local_item_offset[i]].p_quality_invar;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tp_datafield = p_ref_info->p_item[local_item_offset[i + row_num]].p_datafield;\n\t\t\t\tp_invar = p_ref_info->p_item[local_item_offset[i + row_num]].p_invar;\n\t\t\t\tp_quality_invar = p_ref_info->p_item[local_item_offset[i + row_num]].p_quality_invar;\n\t\t\t}\n\n\t\t\t// 描述\n\t\t\tcp->print_ptr += 2;\n\t\t\tprintAddStrToBufAndModifyPtr(cp, p_datafield->desc, strlen(p_datafield->desc));\n\n\t\t\t*cp->print_ptr++ = ':';\n\t\t\tcp->print_ptr += (39 - strlen(p_datafield->desc));\n\n\t\t\tif (p_invar)\n\t\t\t{\n\t\t\t\tGET_INVAL_VAL(&local_bool_value, p_invar);\n\t\t\t}\n\n\t\t\tif (local_bool_value)\n\t\t\t{\n\t\t\t\t*cp->print_ptr = '1';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t*cp->print_ptr = '0';\n\t\t\t}\n\n\t\t\tcp->print_ptr ++;\n\n\t\t\t*cp->print_ptr++ = ':';\n\n\t\t\tif (NULL == p_quality_invar)\n\t\t\t{\n\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \" \", 4);\n\t\t\t}\n\t\t\telse if ((BITS_TYPE == p_datafield->type) || (INT8_TYPE == p_datafield->type) ||\n\t\t\t\t(UINT8_TYPE == p_datafield->type))\n\t\t\t{\n\t\t\t\tGET_INVAL_VAL(&tran_val, p_quality_invar);\n\t\t\t\tif (GOOSE_Q_VALID != (tran_val & GOOSE_Q_VALID))\n\t\t\t\t{\n\t\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \"I\", 1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \" \", 1);\n\t\t\t\t}\n\n\t\t\t\tif (GOOSE_Q_RX_TEST == (tran_val & GOOSE_Q_RX_TEST))\n\t\t\t\t{\n\t\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \"T\", 1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \" \", 1);\n\t\t\t\t}\n\n\t\t\t\tif (GOOSE_Q_LINK_OK != (tran_val & GOOSE_Q_LINK_OK))\n\t\t\t\t{\n\t\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \"L\", 1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \" \", 1);\n\t\t\t\t}\n\n\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \" \", 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tGET_INVAL_VAL(&tran_val, p_quality_invar);\n\n\t\t\t\tif (SV_Q_VALID != (tran_val & SV_Q_VALID))\n\t\t\t\t{\n\t\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \"I\", 1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \" \", 1);\n\t\t\t\t}\n\n\t\t\t\tif (SV_Q_RX_TEST == (tran_val & SV_Q_RX_TEST))\n\t\t\t\t{\n\t\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \"T\", 1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \" \", 1);\n\t\t\t\t}\n\n\t\t\t\tif (SV_Q_OVERFLOW == (tran_val & SV_Q_OVERFLOW))\n\t\t\t\t{\n\t\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \"O\", 1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \" \", 1);\n\t\t\t\t}\n\n\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \" \", 1);\n\t\t\t}\n\n\t\t\tif ((i == row_num - 1) && (print_item_num & 0x01))\n\t\t\t{\n\t\t\t\tprintAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t\tcp->print_ptr += 4;\n\t\t\t\tprintAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t\tcp->print_ptr += 28;\n\t\t\t\t*cp->print_ptr++ = ':';\n\t\t\t\tcp->print_ptr += 14;\n\t\t\t\t*cp->print_ptr++ = ':';\n\t\t\t\tcp->print_ptr += 4;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tprintAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\tprintCharLine(cp, WITH_RETURN);\n\t}\n\n\tprintStrLine(cp, present_value_line_tab3[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\tHOPEFREE(local_item_offset);\n\tlocal_item_offset = NULL;\n\n\treturn;\n}\n\nLOCAL void printBiValueNet(Print *cp)\n{\n\tPrintRefInfo *p_ref_info = NULL;\n\tRefParameterItems *p_ref_tbl_item = NULL;\n\tInVar *p_invar = NULL, *p_quality_invar = NULL;\n\tINT32 local_no = 0, row_num = 0;\n\tINT32 i = 0, n = 0, print_item_num = 0;\n\tDataFields *p_datafield = NULL;\n\tUINT16 local_bool_value = 0;\n\tUINT8 tran_val = 0;\n\tUINT16 *local_item_offset = NULL;\n\n\tp_ref_info = (PrintRefInfo *)s_ref_tbl_cfg[EN_REF_TBL_BINCHG].p_ref_info;\n\tp_ref_tbl_item = p_ref_info->p_tbl;\n\tlocal_item_offset = (UINT16 *)HOPEMALLOC(p_ref_tbl_item->num * sizeof(UINT16));\n\tif (NULL == local_item_offset)\n\t{\n\t\tPRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printBiValueNet) Malloc failed!\\n\");\n\t\treturn;\n\t}\n\n\t// 打印标题\n\tprintHeaderLineNet(cp, slan_bi_value_str.desc[cp->dev_cfg.lang_sel]);\n\n\t//printStrLine(cp, slan_binchg_init_state_str.desc[cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\tprintStrLine(cp, present_value_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\tprintStrLine(cp, present_value_line_tab1a[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t//print_item_num = p_ref_tbl_item->num;\n\tfor (i = 0; i < p_ref_tbl_item->num; i++)\n\t{\n\t    if ( DESC_PRINT_VISIBLE(p_ref_info->p_item[i].p_datafield) )\n\t    {\n\t        local_item_offset[print_item_num] = i;\n\t\t\tprint_item_num++;\n\t    }\n\t}\n\n\t// 行循环\n\trow_num = (print_item_num + 1) >> 1;\n\tfor (i = 0; i < row_num; i++)\n\t{\n\t\tprintStrLine(cp, present_value_line_tab2[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t\t// 两列循环\n\t\tfor (n = 0; n < 2; n++)\n\t\t{\n\t\t\tif (0 == n)\n\t\t\t{\n\t\t\t\tprintAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t}\n\n\t\t\t// 序号\n\t\t\tif (0 == n)\n\t\t\t{\n\t\t\t\tlocal_no = i + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlocal_no = i + 1 + row_num;\n\t\t\t}\n\n\t\t\tif (local_no < 100)\n\t\t\t{\n\t\t\t\tcp->print_ptr += 1;\n\t\t\t\tsprintf(cp->print_ptr, \"%02d\", local_no);\n\t\t\t\tcp->print_ptr += 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsprintf(cp->print_ptr, \"%03d\", local_no);\n\t\t\t\tcp->print_ptr += 3;\n\t\t\t}\n\n\t\t\t*cp->print_ptr++ = ' ';\n\t\t\tprintAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t\t\tif (0 == n)\n\t\t\t{\n\t\t\t\tp_datafield = p_ref_info->p_item[local_item_offset[i]].p_datafield;\n\t\t\t\tp_invar = p_ref_info->p_item[local_item_offset[i]].p_invar;\n\t\t\t\tp_quality_invar = p_ref_info->p_item[local_item_offset[i]].p_quality_invar;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tp_datafield = p_ref_info->p_item[local_item_offset[i + row_num]].p_datafield;\n\t\t\t\tp_invar = p_ref_info->p_item[local_item_offset[i + row_num]].p_invar;\n\t\t\t\tp_quality_invar = p_ref_info->p_item[local_item_offset[i + row_num]].p_quality_invar;\n\t\t\t}\n\n\t\t\t// 描述\n\t\t\tcp->print_ptr += 2;\n\t\t\tprintAddStrToBufAndModifyPtr(cp, p_datafield->desc, strlen(p_datafield->desc));\n\n\t\t\t*cp->print_ptr++ = ':';\n\t\t\tcp->print_ptr += (39 - strlen(p_datafield->desc));\n\n\t\t\tif (p_invar)\n\t\t\t{\n\t\t\t\tGET_INVAL_VAL(&local_bool_value, p_invar);\n\t\t\t}\n\n\t\t\tif (local_bool_value)\n\t\t\t{\n\t\t\t\t*cp->print_ptr = '1';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t*cp->print_ptr = '0';\n\t\t\t}\n\n\t\t\tcp->print_ptr ++;\n\n\t\t\t*cp->print_ptr++ = ':';\n\n\t\t\tif (NULL == p_quality_invar)\n\t\t\t{\n\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \" \", 4);\n\t\t\t}\n\t\t\telse if ((BITS_TYPE == p_datafield->type) || (INT8_TYPE == p_datafield->type) ||\n\t\t\t\t(UINT8_TYPE == p_datafield->type))\n\t\t\t{\n\t\t\t\tGET_INVAL_VAL(&tran_val, p_quality_invar);\n\t\t\t\tif (GOOSE_Q_VALID != (tran_val & GOOSE_Q_VALID))\n\t\t\t\t{\n\t\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \"I\", 1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \" \", 1);\n\t\t\t\t}\n\n\t\t\t\tif (GOOSE_Q_RX_TEST == (tran_val & GOOSE_Q_RX_TEST))\n\t\t\t\t{\n\t\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \"T\", 1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \" \", 1);\n\t\t\t\t}\n\n\t\t\t\tif (GOOSE_Q_LINK_OK != (tran_val & GOOSE_Q_LINK_OK))\n\t\t\t\t{\n\t\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \"L\", 1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \" \", 1);\n\t\t\t\t}\n\n\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \" \", 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tGET_INVAL_VAL(&tran_val, p_quality_invar);\n\n\t\t\t\tif (SV_Q_VALID != (tran_val & SV_Q_VALID))\n\t\t\t\t{\n\t\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \"I\", 1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \" \", 1);\n\t\t\t\t}\n\n\t\t\t\tif (SV_Q_RX_TEST == (tran_val & SV_Q_RX_TEST))\n\t\t\t\t{\n\t\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \"T\", 1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \" \", 1);\n\t\t\t\t}\n\n\t\t\t\tif (SV_Q_OVERFLOW == (tran_val & SV_Q_OVERFLOW))\n\t\t\t\t{\n\t\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \"O\", 1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \" \", 1);\n\t\t\t\t}\n\n\t\t\t\tprintAddStrToBufAndModifyPtr(cp, \" \", 1);\n\t\t\t}\n\n\t\t\tif ((i == row_num - 1) && (print_item_num & 0x01))\n\t\t\t{\n\t\t\t\tprintAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t\tcp->print_ptr += 4;\n\t\t\t\tprintAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t\tcp->print_ptr += 28;\n\t\t\t\t*cp->print_ptr++ = ':';\n\t\t\t\tcp->print_ptr += 14;\n\t\t\t\t*cp->print_ptr++ = ':';\n\t\t\t\tcp->print_ptr += 4;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tprintAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\tprintCharLine(cp, WITH_RETURN);\n\t}\n\n\tprintStrLine(cp, present_value_line_tab3[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\tHOPEFREE(local_item_offset);\n\tlocal_item_offset = NULL;\n\n\treturn;\n}\n\n /* 打印定值 */\n LOCAL void printSettings(Print *cp)\n {\n\t if (PRINT_UART_PROTOCOL == cp->print_method)\n\t {\n\t\t printSettingsUart(cp);\n\t }\n\t else if (PRINT_ETH_PROTOCOL == cp->print_method)\n\t {\n\t\t printSettingsNet(cp);\n\t }\n\n\t return;\n }\n\n LOCAL void printSettingsUart(Print *cp)\n {\n\t INT32 m = 0, i = 0;\n\t FaultReadCtrl read_ctrl = { 0 };\n\n\t if (0x5a == cp->print_rec_set_flag)\n\t {\n\t\t // 为录波定值，打印全部组定值及定值矩阵\n\t\t cp->print_shm_content.print_para_num = 0;\n\n\t\t read_ctrl.field = FAULT_DF_SET_VAL;\n\t\t read_ctrl.off = 0;\n\t\t read_ctrl.num = cp->wave_data.fault_head.set_num;\n\n\t\t if (getHisFaultData(&cp->wave_data.fault_head, &read_ctrl, (void *)cp->wave_data.p_set_buf) < 0)\n\t\t {\n\t\t\t return;\n\t\t }\n\n\t\t // 分组循环\n\t\t for (m = 1; m < cp->p_set_grps->group_num; m++)\n\t\t {\n\t\t\t if (cp->p_set_grps->group[m].grp_hiden_set)\n\t\t\t {\n\t\t\t\t continue;\n\t\t\t }\n\n\t\t\t printOneGrpSettings(cp, m, 0);\n\t\t\t printOneGrpSettingMatrixes(cp, m, 0);\n\t\t }\n\t }\n\t else\n\t {\n\t\t // 非录波定值，由LCD决定打印内容\n\t\t if (cp->print_shm_content.print_para_num < 2)\n\t\t {\n\t\t\t return;\n\t\t }\n\n\t\t if (0xff == (cp->print_shm_content.print_para_val[1] & 0xff))\n\t\t {\n\t\t\t for (m = 1; m < cp->p_set_grps->group_num; m++)\n\t\t\t {\n\t\t\t\t if (cp->p_set_grps->group[m].grp_hiden_set)\n\t\t\t\t {\n\t\t\t\t\t continue;\n\t\t\t\t }\n\n\t\t\t\t printOneGrpSettings(cp, m, cp->print_shm_content.print_para_val[0] & 0xff);\n\t\t\t\t printOneGrpSettingMatrixes(cp, m, cp->print_shm_content.print_para_val[0] & 0xff);\n\t\t\t }\n\t\t }\n\t\t else\n\t\t {\n\t\t\t for (i = 0; i < cp->print_shm_content.print_para_num - 1; i++)\n\t\t\t {\n\t\t\t\t printOneGrpSettings(cp, cp->print_shm_content.print_para_val[i + 1] & 0xff,\n\t\t\t\t\t cp->print_shm_content.print_para_val[0] & 0xff);\n\t\t\t\t printOneGrpSettingMatrixes(cp, cp->print_shm_content.print_para_val[i + 1] & 0xff,\n\t\t\t\t\t cp->print_shm_content.print_para_val[0] & 0xff);\n\t\t\t }\n\t\t }\n\t }\n\n\t return;\n }\n\nLOCAL void printSettingsNet(Print *cp)\n{\n\tINT32 m = 0, i = 0;\n\tFaultReadCtrl read_ctrl = { 0 };\n\n\tif (0x5a == cp->print_rec_set_flag)\n\t{\n\t\t// 为录波定值，打印全部组定值及定值矩阵\n\t\tcp->print_shm_content.print_para_num = 0;\n\n\t\tread_ctrl.field = FAULT_DF_SET_VAL;\n\t\tread_ctrl.off = 0;\n\t\tread_ctrl.num = cp->wave_data.fault_head.set_num;\n\n\t\tif (getHisFaultData(&cp->wave_data.fault_head, &read_ctrl, (void *)cp->wave_data.p_set_buf) < 0)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\t// 分组循环\n\t\tfor (m = 1; m < cp->p_set_grps->group_num; m++)\n\t\t{\n\t\t\tif (cp->p_set_grps->group[m].grp_hiden_set)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tprintOneGrpSettings(cp, m, 0);\n\t\t\tprintOneGrpSettingMatrixes(cp, m, 0);\n\t\t}\n\t}\n\telse\n\t{\n\t\t// 非录波定值，由LCD决定打印内容\n\t\tif (cp->print_shm_content.print_para_num < 2)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tif (0xff == (cp->print_shm_content.print_para_val[1] & 0xff))\n\t\t{\n\t\t\tfor (m = 1; m < cp->p_set_grps->group_num; m++)\n\t\t\t{\n\t\t\t\tif (cp->p_set_grps->group[m].grp_hiden_set)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tprintOneGrpSettings(cp, m, cp->print_shm_content.print_para_val[0] & 0xff);\n\t\t\t\tprintOneGrpSettingMatrixes(cp, m, cp->print_shm_content.print_para_val[0] & 0xff);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (i = 0; i < cp->print_shm_content.print_para_num - 1; i++)\n\t\t\t{\n\t\t\t\tprintOneGrpSettings(cp, cp->print_shm_content.print_para_val[i + 1] & 0xff,\n\t\t\t\t\t\t\t\t\t\tcp->print_shm_content.print_para_val[0] & 0xff);\n\t\t\t\tprintOneGrpSettingMatrixes(cp, cp->print_shm_content.print_para_val[i + 1] & 0xff,\n\t\t\t\t\t\t\t\t\t\t\tcp->print_shm_content.print_para_val[0] & 0xff);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn;\n}\n\nLOCAL void printOneGrpSettings(Print *cp, UINT16 grp_index, UINT16 section_index)\n{\n\tDataFields *p_datafield = NULL;\n\tSettingValue local_setting_value = { 0 };\n\tINT8 tmp_str[128] = { 0 }, is_multi_set = 0;\n\tUINT16 *p_setting_item_offset = 0;\n\tINT32 i = 0, j = 0, m = 0, n = 0, row_num = 0, sum_index = 0, print_section = 1, sub_grp_num = 0;\n\tINT32 print_item_num = 0, print_item_bits_num = 0, print_item_unbits_num = 0, ret = 0;\n\tINT32 print_item_bits_cnt = 0, print_item_unbits_cnt = 0;\n\tUINT16 local_no = 0;\n\n\t// 分组数不能越限\n\tif (grp_index >= cp->p_set_grps->group_num)\n\t{\n\t\treturn;\n\t}\n\n\t// 若是多区定值，则定值区不能越限\n\tis_multi_set = cp->p_set_grps->group[grp_index].multi_set;\n\tif ((0x5a != cp->print_rec_set_flag) && is_multi_set && \n\t\t(section_index > cp->p_set_grps->group[grp_index].section_num))\n\t{\n\t\treturn;\n\t}\n\n\t// 判断是否有打印内容，若无则不打印本组\n\tsum_index = 0;\n\tfor (j = 0; j < grp_index; j++)\n\t{\n\t\tsum_index += cp->p_set_content_num[j];\n\t}\n\n\tfor (i = 0; i < cp->p_set_grps->group[grp_index].item_num; i++)\n\t{\n\t\tp_datafield = cp->pp_set_datafield[sum_index + i];\n\t\tif (DESC_PRINT_VISIBLE(p_datafield))\n\t\t{\n\t\t\tif (BITS_TYPE == p_datafield->type)\n\t\t\t{\n\t\t\t\tprint_item_bits_num++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprint_item_unbits_num++;\n\t\t\t\tprint_item_unbits_num += print_item_bits_num;\n\t\t\t\tprint_item_bits_num = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0 == (print_item_bits_num + print_item_unbits_num))\n\t{\n\t\treturn;\n\t}\n\n\t// 仅处理保护定值，其余控制字均不分开打印\n\tif (0 == is_multi_set)\n\t{\n\t\tprint_item_unbits_num += print_item_bits_num;\n\t\tprint_item_bits_num = 0;\n\t}\n\n\tfor (i = 0; i < cp->p_set_grps->group[grp_index].item_num; i++)\n\t{\n\t\tp_datafield = cp->pp_set_datafield[sum_index + i];\n\t\tif (DESC_PRINT_VISIBLE(p_datafield))\n\t\t{\n\t\t\tif (print_item_num < print_item_unbits_num)\n\t\t\t{\n\t\t\t\tcp->p_set_item_unbits_offset[print_item_unbits_cnt++] = sum_index + i;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcp->p_set_item_bits_offset[print_item_bits_cnt++] = sum_index + i;\n\t\t\t}\n\n\t\t\tprint_item_num++;\n\t\t}\n\t}\n\n\tif (PRINT_UART_PROTOCOL == cp->print_method)\n\t{\n\t\tprintHeaderLineUart(cp, cp->p_set_grps->group[grp_index].desc);\n\t}\n\telse\n\t{\n\t\tprintHeaderLineNet(cp, cp->p_set_grps->group[grp_index].desc);\n\t}\n\t\n\t// 打印标题\n\tif ((0x5a != cp->print_rec_set_flag) && (cp->p_set_grps->group[grp_index].section_num > 1))\n\t{\n\t\tprint_section = section_index;\n\n\t\t// 运行区\n\t\tif (print_section == cp->p_set_grps->cur_section)\n\t\t{\n\t\t\tsprintf(tmp_str, \"(%s%02d)\", slan_active_section_str.desc[cp->dev_cfg.lang_sel],\n\t\t\t\t\t\tprint_section);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsprintf(tmp_str, \"(%s%02d)\", slan_unactive_section_str.desc[cp->dev_cfg.lang_sel],\n\t\t\t\tprint_section);\n\t\t}\n\n\t\tprintAddStrToBuf(cp, tmp_str);\n\t\tprintCharLine(cp, WITH_RETURN);\n\t}\n\n\tif (cp->p_set_grps->group[grp_index].section_num > 1)\n\t{\n\t\tstrcpy(tmp_str, \"(\");\n\t\tif (1 == printGetInVar(EN_IN_SETTING_PRIM_OR_SEC))\n\t\t{\n\t\t\tstrcat(tmp_str, slan_prim_value_str.desc[cp->dev_cfg.lang_sel]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstrcat(tmp_str, slan_second_value_str.desc[cp->dev_cfg.lang_sel]);\n\t\t}\n\t\tstrcat(tmp_str, \")\");\n\t\tprintAddStrToBuf(cp, tmp_str);\n\t\tprintCharLine(cp, WITH_RETURN);\n\t}\n\n\tprintStrLine(cp, one_grp_settings_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\tprintStrLine(cp, present_value_line_tab1[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\tif (print_item_unbits_num)\n\t{\n\t\tsub_grp_num++;\n\t}\n\n\tif (print_item_bits_num)\n\t{\n\t\tsub_grp_num++;\n\t}\n\n\tfor (m = 0; m < sub_grp_num; m++)\n\t{\n\t\tif (2 == sub_grp_num)\n\t\t{\n\t\t\tprintStrLine(cp, one_grp_settings_line_tab4[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t\t\tprintAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t\t\tif (0 == m)\n\t\t\t{\n\t\t\t\tp_setting_item_offset = cp->p_set_item_unbits_offset;\n\t\t\t\tprint_item_num = print_item_unbits_num;\n\t\t\t\tsprintf(tmp_str, \"%s\", cp->p_set_grps->group[grp_index].desc);\n\t\t\t\tprintAddStrToBufAndModifyPtr(cp, tmp_str, 110);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tp_setting_item_offset = cp->p_set_item_bits_offset;\n\t\t\t\tprint_item_num = print_item_bits_num;\n\t\t\t\tsprintf(tmp_str, \"%s%s\", cp->p_set_grps->group[grp_index].desc,\n\t\t\t\t\t\t\tslan_set_control_bit_str.desc[cp->dev_cfg.lang_sel]);\n\t\t\t\tprintAddStrToBufAndModifyPtr(cp, tmp_str, 110);\n\t\t\t}\n\n\t\t\tprintAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\tprintCharLine(cp, WITH_RETURN);\n\t\t\tprintStrLine(cp, one_grp_settings_line_tab5[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//modified by wzc,保证只有bits_item的情况也能全部打印\n\t\t\tif(print_item_unbits_num != 0)\n\t\t\t{\n\t\t\t\t//这一分支内容和以前一样\n\t\t\t\tp_setting_item_offset = cp->p_set_item_unbits_offset;\n\t\t\t\tprint_item_num = print_item_unbits_num;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//如果需要打印的只有bits_item，则赋另一组值\n\t\t\t\tp_setting_item_offset = cp->p_set_item_bits_offset;\n\t\t\t\tprint_item_num = print_item_bits_num;\n\t\t\t}\n\t\t}\n\n\t\trow_num = (print_item_num + 1) >> 1;\n\t\tfor (i = 0; i < row_num; i++)\n\t\t{\n\t\t\tif (!((2 == sub_grp_num) && (is_multi_set) && (0 == i)))\n\t\t\t{\n\t\t\t\tprintStrLine(cp, one_grp_settings_line_tab2[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t\t\t}\n\n\t\t\t// 两列循环\n\t\t\tfor (n = 0; n < 2; n++)\n\t\t\t{\n\t\t\t\tif (0 == n)\n\t\t\t\t{\n\t\t\t\t\tprintAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tprintAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t\t}\n\n\t\t\t\t// 序号\n\t\t\t\tif (0 == n)\n\t\t\t\t{\n\t\t\t\t\tlocal_no = i + 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlocal_no = i + 1 + row_num;\n\t\t\t\t}\n\n\t\t\t\tif (local_no < 100)\n\t\t\t\t{\n\t\t\t\t\tcp->print_ptr += 1;\n\t\t\t\t\tsprintf(cp->print_ptr, \"%02d\", local_no);\n\t\t\t\t\tcp->print_ptr += 2;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsprintf(cp->print_ptr, \"%03d\", local_no);\n\t\t\t\t\tcp->print_ptr += 3;\n\t\t\t\t}\n\n\t\t\t\t*cp->print_ptr++ = ' ';\n\t\t\t\tprintAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t\t\t\tif (0 == n)\n\t\t\t\t{\n\t\t\t\t\tp_datafield = cp->pp_set_datafield[p_setting_item_offset[i]];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tp_datafield = cp->pp_set_datafield[p_setting_item_offset[i + row_num]];\n\t\t\t\t}\n\n\t\t\t\t// 描述\n\t\t\t\tprintAddStrToBufAndModifyPtr(cp, p_datafield->desc, 33);\n\n\t\t\t\t*cp->print_ptr++ = ':';\n\t\t\t\t*cp->print_ptr++ = ' ';\n\n\t\t\t\tif (0x5a == cp->print_rec_set_flag)\n\t\t\t\t{\n\t\t\t\t\tif (0 == n)\n\t\t\t\t\t{\n\t\t\t\t\t\tlocal_setting_value = cp->wave_data.p_set_buf[p_setting_item_offset[i]];\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tlocal_setting_value = cp->wave_data.p_set_buf[p_setting_item_offset[i + row_num]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (0 == n)\n\t\t\t\t\t{\n\t\t\t\t\t\tret = getDevSettingValue(grp_index, print_section, \n\t\t\t\t\t\t\t\t\t\tp_setting_item_offset[i] - sum_index, &local_setting_value);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tret = getDevSettingValue(grp_index, print_section, \n\t\t\t\t\t\t\tp_setting_item_offset[i + row_num] - sum_index, &local_setting_value);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (-1 == ret)\n\t\t\t\t\t{\n\t\t\t\t\t\tPRINTINFO(CONSOLE_SHOW, \"[print]: (_lcd_printOneGrpSettings) Get set val failed!\\n\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// 实际值\n\t\t\t\tprintSetValueFormatToBuffer(p_datafield, &local_setting_value, cp->print_ptr, cp->print_ptr + 8 -1);\n\t\t\t\tcp->print_ptr += 9;\n\n\t\t\t\t// 量纲\n\t\t\t\tprintAddStrToBufAndModifyPtr(cp, p_datafield->unit, 4);\n\n\t\t\t\tif ((i == row_num - 1) && (print_item_num & 0x01))\n\t\t\t\t{\n\t\t\t\t\tprintAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t\t\tcp->print_ptr += 4;\n\t\t\t\t\tprintAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t\t\tcp->print_ptr += 33;\n\t\t\t\t\t*cp->print_ptr++ = ':';\n\t\t\t\t\tcp->print_ptr += 14;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprintAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\tprintCharLine(cp, WITH_RETURN);\n\t\t}\n\t}\n\n\tprintStrLine(cp, one_grp_settings_line_tab3[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\tprintCharLine(cp, WITH_RETURN);\n\t\n\treturn;\n}\n\nLOCAL void printOneGrpSettingMatrixes(Print *cp, UINT16 grp_index, UINT16 section_index)\n{\n\tDataFields *p_datafield = NULL;\n\tSettingValue local_setting_value = { 0 };\n\tINT8 tmp_str[80] = { 0 };\n\tINT32 i = 0, j = 0, k = 0, m = 0, sum_index = 0, print_section = 1, print_item_num = 0, ret = 0;\n\tUINT32 local_set_value = 0;\n\tSetting *p_setting = NULL;\n\n\t// 判断是否有打印内容，若无则不打印本组\n\tsum_index = 0;\n\tfor (j = 0; j < grp_index; j++)\n\t{\n\t\tsum_index += cp->p_set_content_num[j];\n\t}\n\n\tcp->printing_matrix_group_num = 0;\n\tk = 0;\n\tfor (j = 0; j < cp->p_set_grps->group[grp_index].item_num; j++)\n\t{\n\t\tif (k >= cp->p_set_grps->group[grp_index].item_num)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tdo \n\t\t{\n\t\t\tp_datafield = cp->pp_set_datafield[sum_index + k];\n\t\t\tp_setting = &cp->p_set_grps->group[grp_index].item[k];\n\t\t\tk++;\n\t\t} while (((0 == DESC_PRINT_VISIBLE(cp->pp_set_datafield[sum_index + k - 1])) || (0 == p_datafield->is_bit_str))\n\t\t\t\t && (k < cp->p_set_grps->group[grp_index].item_num));\n\n\t\tif (p_datafield && DESC_PRINT_VISIBLE(cp->pp_set_datafield[sum_index + k - 1]) && p_datafield->is_bit_str)\n\t\t{\n\t\t\tprint_item_num++;\n\t\t\tfor (m = 0; m < cp->printing_matrix_group_num; m++)\n\t\t\t{\n\t\t\t\tif (p_datafield->bit_str_seq == cp->printing_matrix_group_val[m])\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (m == cp->printing_matrix_group_num)\n\t\t\t{\n\t\t\t\tcp->printing_matrix_group_num++;\n\t\t\t\tcp->printing_matrix_group_val[m] = p_datafield->bit_str_seq;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0 == print_item_num)\n\t{\n\t\treturn;\n\t}\n\n\tstrcpy(tmp_str, cp->p_set_grps->group[grp_index].desc);\n\tstrcat(tmp_str, \"(\");\n\tstrcat(tmp_str, slan_matrix_setting_str.desc[cp->dev_cfg.lang_sel]);\n\tstrcat(tmp_str, \")\");\n\n\tif (PRINT_UART_PROTOCOL == cp->print_method)\n\t{\n\t\tprintHeaderLineUart(cp, tmp_str);\n\t}\n\telse\n\t{\n\t\tprintHeaderLineNet(cp, tmp_str);\n\t}\n\n\n\n\t// 打印标题\n\tif ((0x5a != cp->print_rec_set_flag) && (cp->p_set_grps->group[grp_index].section_num > 1))\n\t{\n\t\tprint_section = section_index;\n\n\t\tif (print_section == cp->p_set_grps->cur_section)\n\t\t{\n\t\t\t// 运行区\n\t\t\t//取行首地址\n\t\t\tsprintf(tmp_str, \"(%s%02d)\", slan_active_section_str.desc[cp->dev_cfg.lang_sel], print_section);\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// 非运行区\n\t\t\tsprintf(tmp_str, \"(%s%02d)\", slan_unactive_section_str.desc[cp->dev_cfg.lang_sel], print_section);\n\t\t}\n\n\t\tprintAddStrToBuf(cp, tmp_str);\n\t\tprintCharLine(cp, WITH_RETURN);\n\t}\n\n\tstrcpy(tmp_str, \"(\");\n\tif (1 == printGetInVar(EN_IN_SETTING_PRIM_OR_SEC))\n\t{\n\t\tstrcat(tmp_str, slan_prim_value_str.desc[cp->dev_cfg.lang_sel]);\n\t}\n\telse\n\t{\n\t\tstrcat(tmp_str, slan_second_value_str.desc[cp->dev_cfg.lang_sel]);\n\t}\n\tstrcat(tmp_str, \")\");\n\n\tprintAddStrToBuf(cp, tmp_str);\n\tprintCharLine(cp, WITH_RETURN);\n\n\tprintMatrixDesc(cp);\n\n\tprintStrLine(cp, setting_matrix_line_tab3[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\tprintStrLine(cp, setting_matrix_line_tab4[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\tprintStrLine(cp, setting_matrix_line_tab5[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\tk = 0;\n\tfor (j = 0; j < print_item_num; j++)\n\t{\n\t\tif (k >= cp->p_set_grps->group[grp_index].item_num)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tdo \n\t\t{\n\t\t\tp_datafield = cp->pp_set_datafield[sum_index + k];\n\t\t\tp_setting = &cp->p_set_grps->group[grp_index].item[k];\n\t\t\tk++;\n\t\t} while (((0 == DESC_PRINT_VISIBLE(cp->pp_set_datafield[sum_index + k - 1])) || (0 == p_datafield->is_bit_str))\n\t\t\t\t\t&& (k < cp->p_set_grps->group[grp_index].item_num));\n\n\t\tif (p_datafield && DESC_PRINT_VISIBLE(cp->pp_set_datafield[sum_index + k - 1]) && p_datafield->is_bit_str)\n\t\t{\n\t\t\tprintStrLine(cp, setting_matrix_line_tab6[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t\t\tprintAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\tprintAddStrToBufAndModifyPtr(cp, cp->pp_set_datafield[sum_index + k - 1]->desc, 38);\n\n\t\t\tif (0x5a == cp->print_rec_set_flag)\n\t\t\t{\n\t\t\t\tlocal_setting_value = cp->wave_data.p_set_buf[sum_index + k - 1];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tret = getDevSettingValue(grp_index, print_section, k - 1, &local_setting_value);\n\t\t\t\tif (ret < 0)\n\t\t\t\t{\n\t\t\t\t\tPRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printOneGrpSettingMatrixes) Get set val failed!\\n\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlocal_set_value = local_setting_value.u_value.f_value;\n\t\t\tfor (i = 0; i < 32; i++)\n\t\t\t{\n\t\t\t\tif (0 == i % 16)\n\t\t\t\t{\n\t\t\t\t\tprintAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t\t}\n\t\t\t\telse if (0 == i % 4)\n\t\t\t\t{\n\t\t\t\t\tprintAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t*cp->print_ptr++ = ' ';\n\t\t\t\t}\n\n\t\t\t\tif (local_set_value & (1 << (31 - i)))\n\t\t\t\t{\n\t\t\t\t\tsprintf(cp->print_ptr, \"%01d\", 1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsprintf(cp->print_ptr, \"%01d\", 0);\n\t\t\t\t}\n\n\t\t\t\tcp->print_ptr++;\n\t\t\t}\n\n\t\t\tprintAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\tprintCharLine(cp, WITH_RETURN);\n\t\t}\n\t}\n\n\tprintStrLine(cp, setting_matrix_line_tab7[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\tprintCharLine(cp, WITH_RETURN);\n\t\n\treturn;\n}\n\nLOCAL void printMatrixDesc(Print *cp)\n{\n\tINT32 i = 0, m = 0, group_index = 0;\n\tINT8 str_buf[64] = { 0 }, value_buf[64] = { 0 }, *p_str = NULL;\n\tDataFields *p_datafield = NULL;\n\tSettingGrps *p_setting_grps = NULL;\n\tSettingValue st_val = { 0 };\n\n\tp_setting_grps = getDevSettingGrps();\n\tif (NULL == p_setting_grps)\n\t{\n\t\tPRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printMatrixDesc) Get dev setting failed!\\n\");\n\t\treturn;\n\t}\n\n\tprintAddStrToBuf(cp, slan_matrix_desc_str.desc[cp->dev_cfg.lang_sel]);\n\tprintCharLine(cp, WITH_RETURN);\n\n\tprintStrLine(cp, matrix_desc_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\tfor (m = 0; m < cp->printing_matrix_group_num; m++)\n\t{\n\t\tfor (i = 0; i < cp->printing_matrix_group_num; i++)\n\t\t{\n\t\t\tif (cp->printing_matrix_group_val[m] == cp->matrix_grp_val[i])\n\t\t\t{\n\t\t\t\tgroup_index = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (group_index >= cp->matrix_grp_num)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\tcp->print_ptr += 2;\n\t\tp_str = getLocalLangByAbbr(cp->p_matrix_title[group_index].item, cp->dev_cfg.lang_sel);\n\t\tprintf(\"[print]: item = %s, p_str = %s\\n\", cp->p_matrix_title[group_index].item, p_str);\n\t\tif (NULL == p_str)\n\t\t{\n\t\t\tstrcpy(str_buf, cp->p_matrix_title[group_index].item);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstrcpy(str_buf, p_str);\n\t\t}\n\t\tstrcat(str_buf, \":\");\n\t\tprintAddStrToBufAndModifyPtr(cp, str_buf, 108);\n\t\tprintAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\tprintCharLine(cp, WITH_RETURN);\n\n\t\tfor (i = 0; i < cp->matrix_grp_bitoff_num[group_index]; i++)\n\t\t{\n\t\t\tif (0 == i % 3)\n\t\t\t{\n\t\t\t\tprintAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t\tcp->print_ptr += 2;\n\t\t\t}\n\n\t\t\tsprintf(value_buf, \"%s%d:\", getLocalLangByAbbr(slan_matrix_bit_str.desc[cp->dev_cfg.lang_sel],\n\t\t\t\t\tcp->dev_cfg.lang_sel), cp->matrix_grp_bitoff[group_index][i]);\n\t\t\tstrcpy(str_buf, value_buf);\n\n\t\t\tp_datafield = getParameterWithName(cp->p_matrix_bit[cp->matrix_grp_bitoff_attr[group_index][i]].item);\n\t\t\tif (p_datafield)\n\t\t\t{\n\t\t\t\tgetDevSettingValue(p_datafield->grp, p_setting_grps->cur_section, p_datafield->inf, &st_val);\n\t\t\t\tstrcat(str_buf, st_val.u_value.s_value);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tp_str = getLocalLangByAbbr(cp->p_matrix_bit[cp->matrix_grp_bitoff_attr[group_index][i]].item, cp->dev_cfg.lang_sel);\n\t\t\t\tif (NULL == p_str)\n\t\t\t\t{\n\t\t\t\t\tstrcat(str_buf, cp->p_matrix_bit[cp->matrix_grp_bitoff_attr[group_index][i]].item);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstrcat(str_buf, p_str);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprintAddStrToBufAndModifyPtr(cp, str_buf, 36);\n\n\t\t\tif (0 == ((i + 1) % 3))\n\t\t\t{\n\t\t\t\tprintAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t\tprintCharLine(cp, WITH_RETURN);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(i == (cp->matrix_grp_bitoff_num[group_index] - 1))\n\t\t\t\t{\n\t\t\t\t\tif (0 == i % 3)\n\t\t\t\t\t{\n\t\t\t\t\t\tcp->print_ptr += 72;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcp->print_ptr += 36;\n\t\t\t\t\t}\n\n\t\t\t\t\tprintAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t\t\tprintCharLine(cp, WITH_RETURN);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintStrLine(cp, matrix_desc_line_tab1[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t\n\treturn;\n}\n\n /* 打印最近修改定值 */\n LOCAL void printRecentModifySet(Print *cp)\n {\n\t if (PRINT_UART_PROTOCOL == cp->print_method)\n\t {\n\t\t printRecentModifySetUart(cp);\n\t }\n\t else\n\t {\n\t\t printRecentModifySetNet(cp);\n\t }\n\n\t return;\n }\n\n LOCAL void printRecentModifySetUart(Print *cp)\n {\n\t DataFields *p_datafield = NULL;\n\t UINT8 have_changed = 0;\n\t UINT32 i = 0, j = 0, m = 0, sum_index = 0;\n\t INT32 changed_index = 0;\n\n\t // 打印标题\n\t printHeaderLineUart(cp, slan_latest_modify_header_str.desc[cp->dev_cfg.lang_sel]);\n\n\t printStrLine(cp, latest_modify_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t printStrLine(cp, latest_modify_line_tab1[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t printStrLine(cp, latest_modify_line_tab2[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t // 分组循环\n\t for (m = 1; m < cp->p_set_grps->group_num; m++)\n\t {\n\t\t // 本组为隐含定值，不打印\n\t\t if (cp->p_set_grps->group[m].grp_hiden_set)\n\t\t {\n\t\t\t continue;\n\t\t }\n\n\t\t sum_index = 0;\n\t\t for (j = 0; j < m; j++)\n\t\t {\n\t\t\t sum_index += cp->p_set_content_num[j];\n\t\t }\n\n\t\t // 行循环\n\t\t for (i = 0; i < cp->p_set_grps->group[m].item_num; i++)\n\t\t {\n\t\t\t // 获取信息\n\t\t\t p_datafield = cp->pp_set_datafield[sum_index + i];\n\t\t\t if (NULL == p_datafield)\n\t\t\t {\n\t\t\t\t PRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printRecentModify) Datafield is null!\\n\");\n\t\t\t\t return;\n\t\t\t }\n\n\t\t\t if (0 == DESC_PRINT_VISIBLE(cp->pp_set_datafield[sum_index + i]))\n\t\t\t {\n\t\t\t\t continue;\n\t\t\t }\n\n\t\t\t have_changed = 0;\n\t\t\t if (STRING_TYPE == p_datafield->type)\n\t\t\t {\n\t\t\t\t if (strcmp(cp->p_dram_set_recent_modify_buf[sum_index + i].u_value.s_value, \n\t\t\t\t\t cp->p_sram_set_recent_modify_buf[sum_index + i].u_value.s_value))\n\t\t\t\t {\n\t\t\t\t\t have_changed = 1;\n\t\t\t\t }\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t if (cp->p_dram_set_recent_modify_buf[sum_index + i].u_value.f_value !=\n\t\t\t\t\t cp->p_sram_set_recent_modify_buf[sum_index + i].u_value.f_value)\n\t\t\t\t {\n\t\t\t\t\t have_changed = 1;\n\t\t\t\t }\n\t\t\t }\n\n\t\t\t if (have_changed)\n\t\t\t {\n\t\t\t\t changed_index++;\n\t\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t\t cp->print_ptr += 1;\n\t\t\t\t sprintf(cp->print_ptr, \"%03d\", changed_index);\n\t\t\t\t cp->print_ptr += 3;\n\t\t\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t\t\t\t cp->print_ptr += 2;\n\n\t\t\t\t // 描述\n\t\t\t\t printAddStrToBufAndModifyPtr(cp, p_datafield->desc, 40);\n\t\t\t\t *cp->print_ptr++ = ':';\n\n\t\t\t\t // 实际值\n\t\t\t\t printSetValueFormatToBuffer(p_datafield, &cp->p_sram_set_recent_modify_buf[sum_index + i],\n\t\t\t\t\t cp->print_ptr + 4, cp->print_ptr + 20 -1 );\n\t\t\t\t cp->print_ptr += 26;\n\t\t\t\t printSetValueFormatToBuffer(p_datafield, &cp->p_dram_set_recent_modify_buf[sum_index + i],\n\t\t\t\t\t cp->print_ptr + 4, cp->print_ptr + 20 - 1);\n\n\t\t\t\t cp->print_ptr += 26;\n\t\t\t\t cp->print_ptr += 3;\n\n\t\t\t\t // 量纲\n\t\t\t\t printAddStrToBufAndModifyPtr(cp, p_datafield->unit, 6);\n\t\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t\t cp->print_ptr += 1;\n\n\t\t\t\t printCharLine(cp, WITH_RETURN);\n\t\t\t }\n\t\t }\n\t }\n\n\t printStrLine(cp, latest_modify_line_tab3[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t printCharLine(cp, WITH_RETURN);\n\n\t return;\n }\n\n LOCAL void printRecentModifySetNet(Print *cp)\n {\n\t DataFields *p_datafield = NULL;\n\t UINT8 have_changed = 0;\n\t UINT32 i = 0, j = 0, m = 0, sum_index = 0;\n\t INT32 changed_index = 0;\n\n\t // 打印标题\n\t printHeaderLineNet(cp, slan_latest_modify_header_str.desc[cp->dev_cfg.lang_sel]);\n\n\t printStrLine(cp, latest_modify_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t printStrLine(cp, latest_modify_line_tab1[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t printStrLine(cp, latest_modify_line_tab2[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t \n\t // 分组循环\n\t for (m = 1; m < cp->p_set_grps->group_num; m++)\n\t {\n\t\t // 本组为隐含定值，不打印\n\t\t if (cp->p_set_grps->group[m].grp_hiden_set)\n\t\t {\n\t\t\t continue;\n\t\t }\n\n\t\t sum_index = 0;\n\t\t for (j = 0; j < m; j++)\n\t\t {\n\t\t\t sum_index += cp->p_set_content_num[j];\n\t\t }\n\n\t\t // 行循环\n\t\t for (i = 0; i < cp->p_set_grps->group[m].item_num; i++)\n\t\t {\n\t\t\t // 获取信息\n\t\t\t p_datafield = cp->pp_set_datafield[sum_index + i];\n\t\t\t if (NULL == p_datafield)\n\t\t\t {\n\t\t\t\t PRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printRecentModify) Datafield is null!\\n\");\n\t\t\t\t return;\n\t\t\t }\n\n\t\t\t if (0 == DESC_PRINT_VISIBLE(cp->pp_set_datafield[sum_index + i]))\n\t\t\t {\n\t\t\t\t continue;\n\t\t\t }\n\n\t\t\t have_changed = 0;\n\t\t\t if (STRING_TYPE == p_datafield->type)\n\t\t\t {\n\t\t\t\t if (strcmp(cp->p_dram_set_recent_modify_buf[sum_index + i].u_value.s_value, \n\t\t\t\t\t\t\tcp->p_sram_set_recent_modify_buf[sum_index + i].u_value.s_value))\n\t\t\t\t {\n\t\t\t\t\t have_changed = 1;\n\t\t\t\t }\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t if (cp->p_dram_set_recent_modify_buf[sum_index + i].u_value.f_value !=\n\t\t\t\t\t cp->p_sram_set_recent_modify_buf[sum_index + i].u_value.f_value)\n\t\t\t\t {\n\t\t\t\t\t have_changed = 1;\n\t\t\t\t }\n\t\t\t }\n\n\t\t\t if (have_changed)\n\t\t\t {\n\t\t\t\t changed_index++;\n\t\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t\t cp->print_ptr += 1;\n\t\t\t\t sprintf(cp->print_ptr, \"%03d\", changed_index);\n\t\t\t\t cp->print_ptr += 3;\n\t\t\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t\t\t\t cp->print_ptr += 2;\n\n\t\t\t\t // 描述\n\t\t\t\t printAddStrToBufAndModifyPtr(cp, p_datafield->desc, 40);\n\t\t\t\t *cp->print_ptr++ = ':';\n\n\t\t\t\t // 实际值\n\t\t\t\t printSetValueFormatToBuffer(p_datafield, &cp->p_sram_set_recent_modify_buf[sum_index + i],\n\t\t\t\t\t\t\t\t\t\t\t\tcp->print_ptr + 4, cp->print_ptr + 20 -1 );\n\t\t\t\t cp->print_ptr += 26;\n\t\t\t\t printSetValueFormatToBuffer(p_datafield, &cp->p_dram_set_recent_modify_buf[sum_index + i],\n\t\t\t\t\t\t\t\t\t\t\t\tcp->print_ptr + 4, cp->print_ptr + 20 - 1);\n\n\t\t\t\t cp->print_ptr += 26;\n\t\t\t\t cp->print_ptr += 3;\n\n\t\t\t\t // 量纲\n\t\t\t\t printAddStrToBufAndModifyPtr(cp, p_datafield->unit, 6);\n\t\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t\t cp->print_ptr += 1;\n\n\t\t\t\t printCharLine(cp, WITH_RETURN);\n\t\t\t }\n\t\t }\n\t }\n\n\t printStrLine(cp, latest_modify_line_tab3[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t printCharLine(cp, WITH_RETURN);\n\n\t return;\n }\n\n /* 打印运行报告 */\n LOCAL void printRunRpt(Print *cp)\n {\n\t if (PRINT_UART_PROTOCOL == cp->print_method)\n\t {\n\t\t printRunRptUart(cp);\n\t }\n\t else\n\t {\n\t\t printRunRptNet(cp);\n\t }\n\t \n\t return;\n }\n\nLOCAL void printRunRptUart(Print *cp)\n{\n\tUINT32 rpt_no_start = 0, rpt_no_end = 0;\n\tINT32 i = 0;\n\tUINT16 event_num = 0;\n\tEventData event_data = { 0 };\n\tHisEventReadCtrl read_ctrl = { 0 };\n\tINT32 offset = 0;\n\n\tevent_num = getInt16(cp->print_shm_content.print_para_val, &offset);\n\trpt_no_start = getInt32(cp->print_shm_content.print_para_val, &offset);\n\trpt_no_end = getInt32(cp->print_shm_content.print_para_val, &offset);\n\n\tprintHeaderLineUart(cp, slan_run_rpt_header_str.desc[cp->dev_cfg.lang_sel]);\n\tprintStrLine(cp, run_rpt_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\tprintStrLine(cp, run_rpt_line_tab1[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\tread_ctrl.start_no = rpt_no_start;\n\tread_ctrl.last_no = rpt_no_end;\n\tread_ctrl.order = 0;\n\n\tfor (i = 0; i < event_num; i++)\n\t{\n\t\tread_ctrl.off = i;\n\t\tif (0 == getHisEvent(EN_RUN_EVENT, &read_ctrl, &event_data))\n\t\t{\n\t\t\tprintRunRptItem(cp, &event_data);\n\t\t}\n\t}\n\n\tprintStrLine(cp, run_rpt_line_tab4[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\tprintCharLine(cp, WITH_RETURN);\n\n\treturn;\n}\n\nLOCAL void printRunRptNet(Print *cp)\n{\n\tUINT32 rpt_no_start = 0, rpt_no_end = 0;\n\tINT32 i = 0;\n\tUINT16 event_num = 0;\n\tEventData event_data = { 0 };\n\tHisEventReadCtrl read_ctrl = { 0 };\n\tINT32 offset = 0;\n\n\tevent_num = getInt16(cp->print_shm_content.print_para_val, &offset);\n\trpt_no_start = getInt32(cp->print_shm_content.print_para_val, &offset);\n\trpt_no_end = getInt32(cp->print_shm_content.print_para_val, &offset);\n\n\tprintHeaderLineNet(cp, slan_run_rpt_header_str.desc[cp->dev_cfg.lang_sel]);\n\tprintStrLine(cp, run_rpt_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\tprintStrLine(cp, run_rpt_line_tab1[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\tread_ctrl.start_no = rpt_no_start;\n\tread_ctrl.last_no = rpt_no_end;\n\tread_ctrl.order = 0;\n\n\tfor (i = 0; i < event_num; i++)\n\t{\n\t\tread_ctrl.off = i;\n\t\tif (0 == getHisEvent(EN_RUN_EVENT, &read_ctrl, &event_data))\n\t\t{\n\t\t\tprintRunRptItem(cp, &event_data);\n\t\t}\n\t}\n\n\tprintStrLine(cp, run_rpt_line_tab4[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\tprintCharLine(cp, WITH_RETURN);\n\t\n\treturn;\n}\n\nLOCAL void printRunRptItem(Print *cp, EventData *p_data)\n{\n\tDataFields *p_datafield = NULL;\n\tINT8 time_str[32] = { 0 };\n\tPrintRefInfo *p_ref_info = NULL;\n\n\tprintStrLine(cp, run_rpt_line_tab2[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\tprintAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\tcp->print_ptr += 2;\n\n\tsprintf(cp->print_ptr, \"%04d\", p_data->data.run.no);\n\tcp->print_ptr += 4;\n\t*cp->print_ptr = ' ';\n\tcp->print_ptr += 2;\n\tprintAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\tcp->print_ptr += 4;\n\n\tlongSecAndVsecToManTime(p_data->data.run.t.sec, p_data->data.run.t.us, time_str);\n\tprintAddStrToBufAndModifyPtr(cp, time_str, strlen(time_str) + 9);\n\n\tprintAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\tcp->print_ptr += 8;\n\n\tp_ref_info = (PrintRefInfo *)s_ref_tbl_cfg[EN_REF_TBL_RUN].p_ref_info;\n\tp_datafield = p_ref_info->p_item[p_data->data.run.st_no].p_datafield;\n\tif (p_datafield)\n\t{\n\t\tprintAddStrToBufAndModifyPtr(cp, p_datafield->desc, 42);\n\t}\n\telse\n\t{\n\t\tcp->print_ptr += 42;\n\t}\n\n\tprintAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\tcp->print_ptr += 2;\n\tif (p_data->data.run.st_val)\n\t{\n\t\tprintAddStrToBufAndModifyPtr(cp, clear_to_set_str[cp->print_method][cp->dev_cfg.lang_sel], 8);\n\t}\n\telse\n\t{\n\t\tprintAddStrToBufAndModifyPtr(cp, set_to_clear_str[cp->print_method][cp->dev_cfg.lang_sel], 8);\n\t}\n\n\tprintAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\tprintCharLine(cp, WITH_RETURN);\n\n\treturn;\n}\n\n /* 打印动作报告 */\n LOCAL void printTripRpt(Print *cp)\n {\n\t if (PRINT_UART_PROTOCOL == cp->print_method)\n\t {\n\t\t printTripRptUart(cp);\n\t }\n\t else\n\t {\n\t\t printTripRptNet(cp);\n\t }\n\n\t return;\n }\n\n LOCAL void printTripRptUart(Print *cp)\n {\n\t UINT32 rpt_no_start = 0, rpt_no_end = 0;\n\t INT32 i = 0;\n\t UINT16 event_num = 0;\n\t EventData event_data = { 0 };\n\t HisEventReadCtrl read_ctrl = { 0 };\n\t INT32 offset = 0;\n\n\t event_num = getInt16(cp->print_shm_content.print_para_val, &offset);\n\t rpt_no_start = getInt32(cp->print_shm_content.print_para_val, &offset);\n\t rpt_no_end = getInt32(cp->print_shm_content.print_para_val, &offset);\n\n\t printHeaderLineUart(cp, slan_item_trip_rpt_header_str.desc[cp->dev_cfg.lang_sel]);\n\t printStrLine(cp, item_trip_rpt_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t printStrLine(cp, item_trip_rpt_line_tab1[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t read_ctrl.start_no = rpt_no_start;\n\t read_ctrl.last_no = rpt_no_end;\n\t read_ctrl.order = 0;\n\n\t for (i = 0; i < event_num; i++)\n\t {\n\t\t read_ctrl.off = i;\n\t\t if (0 == getHisEvent(EN_TRIP_EVENT, &read_ctrl, &event_data))\n\t\t {\n\t\t\t printRptItem(cp, &event_data);\n\t\t }\n\t }\n\n\t printStrLine(cp, item_trip_rtp_line_tab4[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t printCharLine(cp, WITH_RETURN);\n\n\t return;\n }\n\n LOCAL void printTripRptNet(Print *cp)\n {\n\t UINT32 rpt_no_start = 0, rpt_no_end = 0;\n\t INT32 i = 0;\n\t UINT16 event_num = 0;\n\t EventData event_data = { 0 };\n\t HisEventReadCtrl read_ctrl = { 0 };\n\t INT32 offset = 0;\n\n\t event_num = getInt16(cp->print_shm_content.print_para_val, &offset);\n\t rpt_no_start = getInt32(cp->print_shm_content.print_para_val, &offset);\n\t rpt_no_end = getInt32(cp->print_shm_content.print_para_val, &offset);\n\n\t printHeaderLineNet(cp, slan_item_trip_rpt_header_str.desc[cp->dev_cfg.lang_sel]);\n\t printStrLine(cp, item_trip_rpt_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t printStrLine(cp, item_trip_rpt_line_tab1[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t read_ctrl.start_no = rpt_no_start;\n\t read_ctrl.last_no = rpt_no_end;\n\t read_ctrl.order = 0;\n\n\t for (i = 0; i < event_num; i++)\n\t {\n\t\t read_ctrl.off = i;\n\t\t if (0 == getHisEvent(EN_TRIP_EVENT, &read_ctrl, &event_data))\n\t\t {\n\t\t\t printRptItem(cp, &event_data);\n\t\t }\n\t }\n\n\t printStrLine(cp, item_trip_rtp_line_tab4[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t printCharLine(cp, WITH_RETURN);\n\t \n\t return;\n }\n\n LOCAL void printRptItem(Print *cp, EventData *p_data)\n {\n\t DataFields *p_datafield = NULL;\n\t INT8 time_str[32] = { 0 };\n\t INT32 local_no = 0, local_val = 0;\n\t EveTimeTag event_t = { 0 };\n\t PrintRefInfo *p_ref_info = NULL;\n\n\t printStrLine(cp, item_rpt_line_tab2[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t cp->print_ptr += 2;\n\n\t if (EN_TRIP_EVENT == p_data->type)\n\t {\n\t\t local_no = p_data->data.trip.no;\n\t\t event_t = p_data->data.trip.t;\n\t\t local_val = p_data->data.trip.st_val;\n\t\t p_ref_info = (PrintRefInfo *)s_ref_tbl_cfg[EN_REF_TBL_TRIP].p_ref_info;\n\t\t p_datafield = p_ref_info->p_item[p_data->data.trip.st_no].p_datafield;\n\t }\n\t else if (EN_CHECK_EVENT == p_data->type)\n\t {\n\t\t local_no = p_data->data.sys_chk.no;\n\t\t event_t = p_data->data.sys_chk.t;\n\t\t local_val = p_data->data.sys_chk.st_val;\n\t\t p_ref_info = (PrintRefInfo *)s_ref_tbl_cfg[EN_REF_TBL_SELF_CHECK].p_ref_info;\n\t\t p_datafield = p_ref_info->p_item[p_data->data.trip.st_no].p_datafield;\n\t }\n\t else if (EN_BI_EVENT == p_data->type)\n\t {\n\t\t local_no = p_data->data.bi.no;\n\t\t event_t = p_data->data.bi.t;\n\t\t local_val = p_data->data.bi.st_val;\n\t\t p_ref_info = (PrintRefInfo *)s_ref_tbl_cfg[EN_REF_TBL_BINCHG].p_ref_info;\n\t\t p_datafield = p_ref_info->p_item[p_data->data.trip.st_no].p_datafield;\n\t }\n\n\t sprintf(cp->print_ptr, \"%04d\", local_no);\n\t cp->print_ptr += 4;\n\t *cp->print_ptr = ' ';\n\t cp->print_ptr += 2;\n\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t cp->print_ptr += 3;\n\n\t longSecAndVsecToManTime(event_t.sec, event_t.us, time_str);\n\t printAddStrToBufAndModifyPtr(cp, time_str, strlen(time_str) + 10);\n\n\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t cp->print_ptr += 8;\n\n\t if (p_datafield)\n\t {\n\t\t printAddStrToBufAndModifyPtr(cp, p_datafield->desc, 42);\n\t }\n\t else\n\t {\n\t\t cp->print_ptr += 42;\n\t }\n\n\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t cp->print_ptr += 2;\n\n\t if (local_val)\n\t {\n\t\t printAddStrToBufAndModifyPtr(cp, clear_to_set_str[cp->print_method][cp->dev_cfg.lang_sel], 8);\n\t }\n\t else\n\t {\n\t\t printAddStrToBufAndModifyPtr(cp, set_to_clear_str[cp->print_method][cp->dev_cfg.lang_sel], 8);\n\t }\n\n\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t printCharLine(cp, WITH_RETURN);\n\n\t return;\n }\n\n /* 打印动作信息报告 */\n LOCAL void printDrawoffSimpleTripRpt(Print *cp)\n {\n\t if (PRINT_UART_PROTOCOL == cp->print_method)\n\t {\n\t\t printDrawoffSimpleTripRptUart(cp);\n\t }\n\t else\n\t {\n\t\t printDrawoffSimpleTripRptNet(cp);\n\t }\n\n\t return;\n }\n\n LOCAL void printDrawoffSimpleTripRptUart(Print *cp)\n {\n\t UINT32 rpt_no_start = 0, rpt_no_end = 0;\n\t HisEventReadCtrl read_ctrl = { 0 };\n\t INT32 offset = 0;\n\n\t if (getHisFaultNum(&rpt_no_start, &rpt_no_end) < 0)\n\t {\n\t\t PRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printDrawoffSimpleTripRpt) Get his fault num err!\\n\");\n\t\t return;\n\t }\n\n\t read_ctrl.start_no = rpt_no_start;\n\t read_ctrl.last_no = rpt_no_end;\n\t read_ctrl.order = 1;\n\t read_ctrl.off = getInt16(cp->print_shm_content.print_para_val, &offset);\n\n\t if (0 == getHisFaultHead(&read_ctrl, &cp->wave_data.fault_head))\n\t {\n\t\t cp->wave_data.fault_head.trip_event_num &= 0x0fff;\n\t\t printDrawoffSimpleTripRptItemUart(cp);\n\t }\n\n\t return;\n }\n\n LOCAL void printDrawoffSimpleTripRptNet(Print *cp)\n {\n\t UINT32 rpt_no_start = 0, rpt_no_end = 0;\n\t HisEventReadCtrl read_ctrl = { 0 };\n\t INT32 offset = 0;\n\n\t if (getHisFaultNum(&rpt_no_start, &rpt_no_end) < 0)\n\t {\n\t\t PRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printDrawoffSimpleTripRpt) Get his fault num err!\\n\");\n\t\t return;\n\t }\n\n\t read_ctrl.start_no = rpt_no_start;\n\t read_ctrl.last_no = rpt_no_end;\n\t read_ctrl.order = 1;\n\t read_ctrl.off = getInt16(cp->print_shm_content.print_para_val, &offset);\n\n\t if (0 == getHisFaultHead(&read_ctrl, &cp->wave_data.fault_head))\n\t {\n\t\t cp->wave_data.fault_head.trip_event_num &= 0x0fff;\n\t\t printDrawoffSimpleTripRptItem(cp);\n\t }\n\t \n\t return;\n }\n\n LOCAL void printDrawoffSimpleTripRptItemUart(Print *cp)\n {\n\t DataFields *p_datafield = NULL, *p_datafield_para = NULL, *p_datafield_faultinfo = NULL;\n\t INT8 time_str[32] = { 0 }, time_rt_str[32] = { 0 }, fault_para_str[64] = { 0 }, phase_str[8] = { 0 };\n\t FaultReadCtrl read_ctrl = { 0 };\n\t EventData *event = NULL;\n\t FaultHead *p_fault_head = NULL;\n\t FLOAT32 *fault_para = NULL;\n\t INT32 i = 0, j = 0, para_flag = 0;\n\t UINT32 phase_value = 0;\n\t InVar local_in_value = { 0 };\n\t PrintRefInfo *p_ref_info = NULL, *p_ref_info_para = NULL, *p_ref_info_faultinfo = NULL;\n\n\t p_fault_head = &cp->wave_data.fault_head;\n\t event = (EventData *)HOPEMALLOC(p_fault_head->trip_event_num * sizeof(EventData));\n\t if (NULL == event)\n\t {\n\t\t PRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printDrawoffTripRptItem) Malloc failed!\\n\");\n\t\t return;\n\t }\n\n\t read_ctrl.field = FAULT_DF_TRIP_EVENT;\n\t read_ctrl.off = 0;\n\t read_ctrl.num = p_fault_head->trip_event_num;\n\n\t if (getHisFaultData(p_fault_head, &read_ctrl, (void *)event) < 0)\n\t {\n\t\t PRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printDrawoffTripRptItem) Get his fault data failed!\\n\");\n\t\t HOPEFREE(event);\n\t\t return;\n\t }\n\n\t // 打印标题\n\t printHeaderLineUart(cp, slan_drawoff_simple_trip_rpt_header_str.desc[cp->dev_cfg.lang_sel]);\n\nprintf(\"[%s, %d]: header_str is %s\\n\", __FUNCTION__, __LINE__, slan_drawoff_simple_trip_rpt_header_str.desc[cp->dev_cfg.lang_sel]);\n\n\t printStrLine(cp, drawoff_trip_rpt_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t printStrLine(cp, drawoff_trip_rpt_line_tab1[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t p_ref_info = (PrintRefInfo *)s_ref_tbl_cfg[EN_REF_TBL_TRIP].p_ref_info;\n\t p_ref_info_para = (PrintRefInfo *)s_ref_tbl_cfg[EN_REF_TBL_TRIP_PARA].p_ref_info;\n\t p_ref_info_faultinfo = (PrintRefInfo *)s_ref_tbl_cfg[EN_REF_TBL_FAULT_INFO].p_ref_info;\n\t for (i = 0; i < p_fault_head->trip_event_num; i++)\n\t {\n\t\t // 若是1->0，不打印\n\t\t if (0 == (event[i].data.trip.st_val & 0x01))\n\t\t {\n\t\t\t continue;\n\t\t }\n\n\t\t if (0 == i)\n\t\t {\n\t\t\t printStrLine(cp, drawoff_trip_rpt_line_tab2[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t cp->print_ptr += 2;\n\n\t\t\t // 报告序号\n\t\t\t sprintf(cp->print_ptr, \"%04d\", p_fault_head->no);\n\t\t\t cp->print_ptr += 4;\n\t\t\t *cp->print_ptr = ' ';\n\t\t\t cp->print_ptr += 2;\n\t\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t cp->print_ptr += 3;\n\n\t\t\t longSecAndVsecToManTime(p_fault_head->t.sec, p_fault_head->t.us, time_str);\n\t\t\t printAddStrToBufAndModifyPtr(cp, time_str, strlen(time_str) + 2);\n\n\t\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t cp->print_ptr += 1;\n\t\t }\n\t\t else\n\t\t {\n\t\t\t if (0 == para_flag)\n\t\t\t {\n\t\t\t\t printStrLine(cp, drawoff_trip_rpt_line_tab3[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t printStrLine(cp, drawoff_trip_rpt_line_tab3a[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t\t\t }\n\t\t\t para_flag = 0;\n\t\t\t \n\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t cp->print_ptr += 8;\n\n\t\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t cp->print_ptr += 28;\n\n\t\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t cp->print_ptr += 1;\n\t\t }\n\n\t\t // 相对时间\n\t\t if (event[i].data.trip.ret_ms > 3600 * 1000)\n\t\t {\n\t\t\t sprintf(time_rt_str, \"%s\", \">3600\");\n\t\t\t strcat(time_rt_str, \" s\");\n\t\t }\n\t\t else\n\t\t {\n\t\t\t sprintf(time_rt_str, \"%05d\", event[i].data.trip.ret_ms);\n\t\t\t strcat(time_rt_str, \"ms\");\n\t\t }\n\t\t \n\t\t printAddStrToBufAndModifyPtr(cp, time_rt_str, 9);\n\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t\t // 相别\n\t\t cp->print_ptr += 3;\n\t\t phase_str[0] = '\\0';\n\t\t if (event[i].data.trip.st_val & 0x02)\n\t\t {\n\t\t\t strcat(phase_str, \"A\");\n\t\t }\n\n\t\t if (event[i].data.trip.st_val & 0x04)\n\t\t {\n\t\t\t strcat(phase_str, \"B\");\n\t\t }\n\n\t\t if (event[i].data.trip.st_val & 0x08)\n\t\t {\n\t\t\t strcat(phase_str, \"C\");\n\t\t }\n\n\t\t printAddStrToBufAndModifyPtr(cp, phase_str, 7);\n\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t cp->print_ptr += 4;\n\n\t\t // 描述\n\t\t p_datafield = p_ref_info->p_item[event[i].data.trip.st_no].p_datafield;\n\t\t if (p_datafield)\n\t\t {\n\t\t\t printAddStrToBufAndModifyPtr(cp, p_datafield->desc, 42);\n\t\t }\n\t\t else\n\t\t {\n\t\t\t cp->print_ptr += 42;\n\t\t }\n\n\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t printCharLine(cp, WITH_RETURN);\n\t }\n\n\t if (NULL != event)\n\t {\n\t\t HOPEFREE(event);\n\t\t event = NULL;\n\t }\n\n\t if (0 == para_flag)\n\t {\nprintf(\"[%s, %d]\\n\", __FUNCTION__, __LINE__);\nprintf(\"method = %d, lang_sel = %d\\n\", cp->print_method, cp->dev_cfg.lang_sel);\n\t\t printStrLine(cp, drawoff_trip_rpt_line_tab5[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t }\n\t else\n\t {\nprintf(\"[%s, %d\\n]\\n\", __FUNCTION__, __LINE__);\n\t\t printStrLine(cp, drawoff_trip_rpt_line_tab5a[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t }\n\t para_flag = 0;\n\t \n\t return;\n }\n\n LOCAL void printDrawoffSimpleTripRptItem(Print *cp)\n {\n\t DataFields *p_datafield = NULL, *p_datafield_para = NULL, *p_datafield_faultinfo = NULL;\n\t INT8 time_str[32] = { 0 }, time_rt_str[32] = { 0 }, fault_para_str[64] = { 0 }, phase_str[8] = { 0 };\n\t FaultReadCtrl read_ctrl = { 0 };\n\t EventData *event = NULL;\n\t FaultHead *p_fault_head = NULL;\n\t FLOAT32 *fault_para = NULL;\n\t INT32 i = 0, j = 0, para_flag = 0;\n\t UINT32 phase_value = 0;\n\t InVar local_in_value = { 0 };\n\t PrintRefInfo *p_ref_info = NULL, *p_ref_info_para = NULL, *p_ref_info_faultinfo = NULL;\n\n\t p_fault_head = &cp->wave_data.fault_head;\n\t event = (EventData *)HOPEMALLOC(p_fault_head->trip_event_num * sizeof(EventData));\n\t if (NULL == event)\n\t {\n\t\t PRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printDrawoffTripRptItem) Malloc failed!\\n\");\n\t\t return;\n\t }\n\n\t read_ctrl.field = FAULT_DF_TRIP_EVENT;\n\t read_ctrl.off = 0;\n\t read_ctrl.num = p_fault_head->trip_event_num;\n\n\t if (getHisFaultData(p_fault_head, &read_ctrl, (void *)event) < 0)\n\t {\n\t\t PRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printDrawoffTripRptItem) Get his fault data failed!\\n\");\n\t\t HOPEFREE(event);\n\t\t return;\n\t }\n\n\t // 打印标题\n\t printHeaderLineNet(cp, slan_drawoff_simple_trip_rpt_header_str.desc[cp->dev_cfg.lang_sel]);\n\t \n\t printStrLine(cp, drawoff_trip_rpt_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t printStrLine(cp, drawoff_trip_rpt_line_tab1[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t p_ref_info = (PrintRefInfo *)s_ref_tbl_cfg[EN_REF_TBL_TRIP].p_ref_info;\n\t p_ref_info_para = (PrintRefInfo *)s_ref_tbl_cfg[EN_REF_TBL_TRIP_PARA].p_ref_info;\n\t p_ref_info_faultinfo = (PrintRefInfo *)s_ref_tbl_cfg[EN_REF_TBL_FAULT_INFO].p_ref_info;\n\t for (i = 0; i < p_fault_head->trip_event_num; i++)\n\t {\n\t\t // 若是1->0，不打印\n\t\t if (0 == (event[i].data.trip.st_val & 0x01))\n\t\t {\n\t\t\t continue;\n\t\t }\n\n\t\t if (0 == i)\n\t\t {\n\t\t\t printStrLine(cp, drawoff_trip_rpt_line_tab2[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t cp->print_ptr += 2;\n\n\t\t\t // 报告序号\n\t\t\t sprintf(cp->print_ptr, \"%04d\", p_fault_head->no);\n\t\t\t cp->print_ptr += 7;\n\t\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t cp->print_ptr += 3;\n\n\t\t\t longSecAndVsecToManTime(p_fault_head->t.sec, p_fault_head->t.us, time_str);\n\t\t\t printAddStrToBufAndModifyPtr(cp, time_str, strlen(time_str) + 2);\n\n\t\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t cp->print_ptr += 1;\n\t\t }\n\t\t else\n\t\t {\n\t\t\t if (0 == para_flag)\n\t\t\t {\n\t\t\t\t printStrLine(cp, drawoff_trip_rpt_line_tab3[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t printStrLine(cp, drawoff_trip_rpt_line_tab3a[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t\t\t }\n\t\t\t para_flag = 0;\n\t\t\t \n\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t cp->print_ptr += 8;\n\n\t\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t cp->print_ptr += 28;\n\n\t\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t cp->print_ptr += 1;\n\t\t }\n\n\t\t // 相对时间\n\t\t if (event[i].data.trip.ret_ms > 3600 * 1000)\n\t\t {\n\t\t\t sprintf(time_rt_str, \"%s\", \">3600\");\n\t\t\t strcat(time_rt_str, \" s\");\n\t\t }\n\t\t else\n\t\t {\n\t\t\t sprintf(time_rt_str, \"%05d\", event[i].data.trip.ret_ms);\n\t\t\t strcat(time_rt_str, \"ms\");\n\t\t }\n\n\t\t printAddStrToBufAndModifyPtr(cp, time_rt_str, 9);\n\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t\t // 相别\n\t\t cp->print_ptr += 3;\n\t\t phase_str[0] = '\\0';\n\t\t if (event[i].data.trip.st_val & 0x02)\n\t\t {\n\t\t\t strcat(phase_str, \"A\");\n\t\t }\n\n\t\t if (event[i].data.trip.st_val & 0x04)\n\t\t {\n\t\t\t strcat(phase_str, \"B\");\n\t\t }\n\n\t\t if (event[i].data.trip.st_val & 0x08)\n\t\t {\n\t\t\t strcat(phase_str, \"C\");\n\t\t }\n\n\t\t printAddStrToBufAndModifyPtr(cp, phase_str, 7);\n\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t cp->print_ptr += 4;\n\n\t\t // 描述\n\t\t p_datafield = p_ref_info->p_item[event[i].data.trip.st_no].p_datafield;\n\t\t if (p_datafield)\n\t\t {\n\t\t\t printAddStrToBufAndModifyPtr(cp, p_datafield->desc, 42);\n\t\t }\n\t\t else\n\t\t {\n\t\t\t cp->print_ptr += 42;\n\t\t }\n\n\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t printCharLine(cp, WITH_RETURN);\n\n\t }\n\n\t if (NULL != event)\n\t {\n\t\t HOPEFREE(event);\n\t\t event = NULL;\n\t }\n\n\t if (0 == para_flag)\n\t {\n\t\t printStrLine(cp, drawoff_trip_rpt_line_tab5[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t }\n\t else\n\t {\n\t\t printStrLine(cp, drawoff_trip_rpt_line_tab5a[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t }\n\t para_flag = 0;\n\t \n\t return;\n }\n\n /* 打印整组报告 */\n LOCAL void printDrawoffTripRpt(Print *cp)\n {\n\t if (PRINT_UART_PROTOCOL == cp->print_method)\n\t {\n\t\t printDrawoffTripRptUart(cp);\n\t }\n\t else\n\t {\n\t\t printDrawoffTripRptNet(cp);\n\t }\n\n\t return;\n }\n\n//added by 王志超 on Feb 20， 2017， 包含启动前开入量状态和启动后开关量变位状态的整组报告\nLOCAL void printAllDrawoffTripRpt(Print *cp)\n{\n\n\t if (PRINT_UART_PROTOCOL == cp->print_method)\n\t {\n\t\t printDrawoffTripRptUart(cp);\n\t }\n\t else\n\t {\n\t\t printDrawoffTripRptNet(cp);\n\t }\n\n\t // 获取波形数据\n\t if (printGetWaveFile(cp) < 0)\n\t {\n\t\t return;\n\t }\n\t // 打印事件报文\nprintf(\"[%s, %d]: will print state\\n\", __FUNCTION__, __LINE__);\n\t printEventInitState(cp);\n\t\n\t printEventChangeState(cp);\n\n\t // 释放波形数据空间\n\t printFreeWaveHeap(cp);\n\t \n\t return;\n\n}\n\n LOCAL void printDrawoffTripRptUart(Print *cp)\n {\n\t UINT32 rpt_no_start = 0, rpt_no_end = 0;\n\t HisEventReadCtrl read_ctrl = { 0 };\n\t INT32 offset = 0;\n\n\t if (getHisFaultNum(&rpt_no_start, &rpt_no_end) < 0)\n\t {\n\t\t PRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printDrawoffTripRpt) Get his fault num err!\\n\");\n\t\t return;\n\t }\n\n\t read_ctrl.start_no = rpt_no_start;\n\t read_ctrl.last_no = rpt_no_end;\n\t read_ctrl.order = 1;\n\t read_ctrl.off = getInt16(cp->print_shm_content.print_para_val, &offset);\n\n\t if (0 == getHisFaultHead(&read_ctrl, &cp->wave_data.fault_head))\n\t {\n\t\t cp->wave_data.fault_head.trip_event_num &= 0x0fff;\n\t\t printDrawoffTripRptItemUart(cp);\n\t }\n\n\t return;\n }\n\n LOCAL void printDrawoffTripRptNet(Print *cp)\n {\n\t UINT32 rpt_no_start = 0, rpt_no_end = 0;\n\t HisEventReadCtrl read_ctrl = { 0 };\n\t INT32 offset = 0;\n\n\t if (getHisFaultNum(&rpt_no_start, &rpt_no_end) < 0)\n\t {\n\t\t PRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printDrawoffTripRpt) Get his fault num err!\\n\");\n\t\t return;\n\t }\n\n\t read_ctrl.start_no = rpt_no_start;\n\t read_ctrl.last_no = rpt_no_end;\n\t read_ctrl.order = 1;\n\t read_ctrl.off = getInt16(cp->print_shm_content.print_para_val, &offset);\n\n\t if (0 == getHisFaultHead(&read_ctrl, &cp->wave_data.fault_head))\n\t {\n\t\t cp->wave_data.fault_head.trip_event_num &= 0x0fff;\n\t\t printDrawoffTripRptItem(cp);\n\t }\n\t \n\t return;\n }\n\n LOCAL void printDrawoffTripRptItemUart(Print *cp)\n {\n\t DataFields *p_datafield = NULL, *p_datafield_para = NULL, *p_datafield_faultinfo = NULL;\n\t INT8 time_str[32] = { 0 }, time_rt_str[32] = { 0 }, fault_para_str[64] = { 0 }, phase_str[8] = { 0 };\n\t FaultReadCtrl read_ctrl = { 0 };\n\t EventData *event = NULL;\n\t FaultHead *p_fault_head = NULL;\n\t FLOAT32 *fault_para = NULL;\n\t INT32 i = 0, j = 0, para_flag = 0;\n\t UINT32 phase_value = 0;\n\t InVar local_in_value = { 0 };\n\t PrintRefInfo *p_ref_info = NULL, *p_ref_info_para = NULL, *p_ref_info_faultinfo = NULL;\n\n\t p_fault_head = &cp->wave_data.fault_head;\n\t event = (EventData *)HOPEMALLOC(p_fault_head->trip_event_num * sizeof(EventData));\n\t if (NULL == event)\n\t {\n\t\t PRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printDrawoffTripRptItem) Malloc failed!\\n\");\n\t\t return;\n\t }\n\n\t read_ctrl.field = FAULT_DF_TRIP_EVENT;\n\t read_ctrl.off = 0;\n\t read_ctrl.num = p_fault_head->trip_event_num;\n\n\t if (getHisFaultData(p_fault_head, &read_ctrl, (void *)event) < 0)\n\t {\n\t\t PRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printDrawoffTripRptItem) Get his fault data failed!\\n\");\n\t\t HOPEFREE(event);\n\t\t return;\n\t }\n\n\t // 打印标题\n\t printHeaderLineUart(cp, slan_drawoff_trip_rpt_header_str.desc[cp->dev_cfg.lang_sel]);\nprintf(\"[%s, %d]: header_str is %s\\n\", __FUNCTION__, __LINE__, slan_drawoff_trip_rpt_header_str.desc[cp->dev_cfg.lang_sel]);\n\n\t printStrLine(cp, drawoff_trip_rpt_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t printStrLine(cp, drawoff_trip_rpt_line_tab1[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t p_ref_info = (PrintRefInfo *)s_ref_tbl_cfg[EN_REF_TBL_TRIP].p_ref_info;\n\t p_ref_info_para = (PrintRefInfo *)s_ref_tbl_cfg[EN_REF_TBL_TRIP_PARA].p_ref_info;\n\t p_ref_info_faultinfo = (PrintRefInfo *)s_ref_tbl_cfg[EN_REF_TBL_FAULT_INFO].p_ref_info;\n\t for (i = 0; i < p_fault_head->trip_event_num; i++)\n\t {\n\t\t // 若是1->0，不打印\n\t\t if (0 == (event[i].data.trip.st_val & 0x01))\n\t\t {\n\t\t\t continue;\n\t\t }\n\n\t\t if (0 == i)\n\t\t {\n\t\t\t printStrLine(cp, drawoff_trip_rpt_line_tab2[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t cp->print_ptr += 2;\n\n\t\t\t // 报告序号\n\t\t\t sprintf(cp->print_ptr, \"%04d\", p_fault_head->no);\n\t\t\t cp->print_ptr += 4;\n\t\t\t *cp->print_ptr = ' ';\n\t\t\t cp->print_ptr += 2;\n\t\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t cp->print_ptr += 3;\n\n\t\t\t longSecAndVsecToManTime(p_fault_head->t.sec, p_fault_head->t.us, time_str);\n\t\t\t printAddStrToBufAndModifyPtr(cp, time_str, strlen(time_str) + 2);\n\n\t\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t cp->print_ptr += 1;\n\t\t }\n\t\t else\n\t\t {\n\t\t\t if (0 == para_flag)\n\t\t\t {\n\t\t\t\t printStrLine(cp, drawoff_trip_rpt_line_tab3[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t printStrLine(cp, drawoff_trip_rpt_line_tab3a[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t\t\t }\n\t\t\t para_flag = 0;\n\t\t\t \n\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t cp->print_ptr += 8;\n\n\t\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t cp->print_ptr += 28;\n\n\t\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t cp->print_ptr += 1;\n\t\t }\n\n\t\t // 相对时间\n\t\t if (event[i].data.trip.ret_ms > 3600 * 1000)\n\t\t {\n\t\t\t sprintf(time_rt_str, \"%s\", \">3600\");\n\t\t\t strcat(time_rt_str, \" s\");\n\t\t }\n\t\t else\n\t\t {\n\t\t\t sprintf(time_rt_str, \"%05d\", event[i].data.trip.ret_ms);\n\t\t\t strcat(time_rt_str, \"ms\");\n\t\t }\n\t\t \n\t\t printAddStrToBufAndModifyPtr(cp, time_rt_str, 9);\n\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t\t // 相别\n\t\t cp->print_ptr += 3;\n\t\t phase_str[0] = '\\0';\n\t\t if (event[i].data.trip.st_val & 0x02)\n\t\t {\n\t\t\t strcat(phase_str, \"A\");\n\t\t }\n\n\t\t if (event[i].data.trip.st_val & 0x04)\n\t\t {\n\t\t\t strcat(phase_str, \"B\");\n\t\t }\n\n\t\t if (event[i].data.trip.st_val & 0x08)\n\t\t {\n\t\t\t strcat(phase_str, \"C\");\n\t\t }\n\n\t\t printAddStrToBufAndModifyPtr(cp, phase_str, 7);\n\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t cp->print_ptr += 4;\n\n\t\t // 描述\n\t\t p_datafield = p_ref_info->p_item[event[i].data.trip.st_no].p_datafield;\n\t\t if (p_datafield)\n\t\t {\n\t\t\t printAddStrToBufAndModifyPtr(cp, p_datafield->desc, 42);\n\t\t }\n\t\t else\n\t\t {\n\t\t\t cp->print_ptr += 42;\n\t\t }\n\n\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t printCharLine(cp, WITH_RETURN);\n\n\t\t // 条目动作参数\n\t\t for (j = 0; j < event[i].data.trip.para_num; j++)\n\t\t {\n\t\t\t p_datafield_para = p_ref_info_para->p_item[event[i].data.trip.para_no[j]].p_datafield;\n\t\t\t if (0 == DESC_EVENT_VISIBLE(p_datafield_para))\n\t\t\t {\n\t\t\t\t continue;\n\t\t\t }\n\n\t\t\t if (0 == j)\n\t\t\t {\n\t\t\t\t printStrLine(cp, drawoff_trip_rpt_line_tab4[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t printStrLine(cp, drawoff_trip_rpt_line_tab4a[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t\t\t }\n\n\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t cp->print_ptr += 8;\n\n\t\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t cp->print_ptr += 28;\n\n\t\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t cp->print_ptr += 10;\n\n\t\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t cp->print_ptr += 2;\n\n\t\t\t // 描述\n\t\t\t if (p_datafield_para)\n\t\t\t {\n\t\t\t\t printAddStrToBufAndModifyPtr(cp, p_datafield_para->desc, 30);\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t cp->print_ptr += 30;\n\t\t\t }\n\n\t\t\t // 值\n\t\t\t local_in_value.value = *((UINT32 *)&event[i].data.trip.val[j]);\n\t\t\t printInvarFormatToBuffer(p_datafield_para, &local_in_value, cp->print_ptr, cp->print_ptr + 16 - 1,\n\t\t\t\t printGetInVar(EN_IN_SIG_PRIM_OR_SEC) - 1);\n\t\t\t cp->print_ptr += 16;\n\n\t\t\t // 量纲\n\t\t\t printAddStrToBufAndModifyPtr(cp, p_datafield_para->unit, 10);\n\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t printCharLine(cp, WITH_RETURN);\n\n\t\t\t para_flag = 1;\n\t\t }\n\t }\n\n\t if (NULL != event)\n\t {\n\t\t HOPEFREE(event);\n\t\t event = NULL;\n\t }\n\n\t if (0 == para_flag)\n\t {\n\t\t printStrLine(cp, drawoff_trip_rpt_line_tab5[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t }\n\t else\n\t {\n\t\t printStrLine(cp, drawoff_trip_rpt_line_tab5a[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t }\n\t para_flag = 0;\n\t \n\t // 整组动作参数\n\t if (p_fault_head->para_num)\n\t {\n\t\t fault_para = (FLOAT32 *)HOPEMALLOC(p_fault_head->para_num * sizeof(FLOAT32));\n\t\t if (NULL == fault_para)\n\t\t {\n\t\t\t PRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printDrawoffTripRptItem) Malloc failed1!\\n\");\n\t\t\t return;\n\t\t }\n\n\t\t read_ctrl.field = FAULT_DF_PARA_VAL;\n\t\t read_ctrl.off = 0;\n\t\t read_ctrl.num = p_fault_head->para_num;\n\t\t if (getHisFaultData(p_fault_head, &read_ctrl, (void *)fault_para) >= 0)\n\t\t {\n\t\t\t for (i = 0; i < p_fault_head->para_num; i++)\n\t\t\t {\n\t\t\t\t p_datafield_faultinfo = p_ref_info_faultinfo->p_item[i].p_datafield;\n\t\t\t\t if (0 == DESC_WAVE_VISIBLE(p_datafield_faultinfo))\n\t\t\t\t {\n\t\t\t\t\t continue;\n\t\t\t\t }\n\n\t\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t\t cp->print_ptr += 6;\n\n\t\t\t\t // 中英文描述\n\t\t\t\t if (p_datafield_faultinfo)\n\t\t\t\t {\n\t\t\t\t\t printAddStrToBufAndModifyPtr(cp, p_datafield_faultinfo->desc, 60);\n\t\t\t\t }\n\t\t\t\t else\n\t\t\t\t {\n\t\t\t\t\t cp->print_ptr += 60;\n\t\t\t\t }\n\n\t\t\t\t // 值\n\t\t\t\t if (2 == p_ref_info_faultinfo->p_item[i].para[EN_FAULTINFO_TBL_PARA_FAULT_TYPE])\n\t\t\t\t {\n\t\t\t\t\t switch(p_datafield_faultinfo->type)\n\t\t\t\t\t {\n\t\t\t\t\t case BITS_TYPE:\n\t\t\t\t\t case INT8_TYPE:\n\t\t\t\t\t\t phase_value = *((INT8 *)&fault_para[i]);\n\t\t\t\t\t\t break;\n\n\t\t\t\t\t case UINT8_TYPE:\n\t\t\t\t\t\t phase_value = *((UINT8 *)&fault_para[i]);\n\t\t\t\t\t\t break;\n\n\t\t\t\t\t case INT16_TYPE:\n\t\t\t\t\t\t phase_value = *((INT16 *)&fault_para[i]);\n\t\t\t\t\t\t break;\n\n\t\t\t\t\t case UINT16_TYPE:\n\t\t\t\t\t\t phase_value = *((UINT16 *)&fault_para[i]);\n\t\t\t\t\t\t break;\n\n\t\t\t\t\t case INT32_TYPE:\n\t\t\t\t\t\t phase_value = *((INT32 *)&fault_para[i]);\n\t\t\t\t\t\t break;\n\n\t\t\t\t\t case UINT32_TYPE:\n\t\t\t\t\t\t phase_value = *((UINT32 *)&fault_para[i]);\n\t\t\t\t\t\t break;\n\n\t\t\t\t\t default:\n\t\t\t\t\t\t phase_value = *((INT8 *)&fault_para[i]);\n\t\t\t\t\t\t break;\n\t\t\t\t\t }\n\n\t\t\t\t\t fault_para_str[0] = '\\0';\n\t\t\t\t\t if (phase_value & 0x01)\n\t\t\t\t\t {\n\t\t\t\t\t\t strcat(fault_para_str, \"A\");\n\t\t\t\t\t }\n\n\t\t\t\t\t if (phase_value & 0x02)\n\t\t\t\t\t {\n\t\t\t\t\t\t strcat(fault_para_str, \"B\");\n\t\t\t\t\t }\n\n\t\t\t\t\t if (phase_value & 0x04)\n\t\t\t\t\t {\n\t\t\t\t\t\t strcat(fault_para_str, \"C\");\n\t\t\t\t\t }\n\n\t\t\t\t\t cp->print_ptr += 10;\n\t\t\t\t\t printAddStrToBufAndModifyPtr(cp, fault_para_str, 10);\n\t\t\t\t }\n\t\t\t\t else\n\t\t\t\t {\n\t\t\t\t\t local_in_value.value = *((UINT32 *)&fault_para[i]);\n\t\t\t\t\t printInvarFormatToBuffer(p_datafield_faultinfo, &local_in_value, cp->print_ptr, cp->print_ptr + 10 - 1,\n\t\t\t\t\t\t printGetInVar(EN_IN_SIG_PRIM_OR_SEC) - 1);\n\t\t\t\t\t cp->print_ptr += 20;\n\t\t\t\t }\n\n\t\t\t\t cp->print_ptr += 10;\n\n\t\t\t\t // 量纲\n\t\t\t\t if (p_datafield_faultinfo)\n\t\t\t\t {\n\t\t\t\t\t printAddStrToBufAndModifyPtr(cp, p_datafield_faultinfo->unit, 10);\n\t\t\t\t }\n\t\t\t\t else\n\t\t\t\t {\n\t\t\t\t\t cp->print_ptr += 10;\n\t\t\t\t }\n\n\t\t\t\t cp->print_ptr += 4;\n\t\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t\t\t\t printCharLine(cp, WITH_RETURN);\n\t\t\t }\n\t\t }\n\n\t\t if (NULL != fault_para)\n\t\t {\n\t\t\t HOPEFREE(fault_para);\n\t\t\t fault_para = NULL;\n\t\t }\n\t }\n\n\t printStrLine(cp, drawoff_trip_rpt_line_tab6[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t printCharLine(cp, WITH_RETURN);\n\n\t return;\n }\n\n LOCAL void printDrawoffTripRptItem(Print *cp)\n {\n\t DataFields *p_datafield = NULL, *p_datafield_para = NULL, *p_datafield_faultinfo = NULL;\n\t INT8 time_str[32] = { 0 }, time_rt_str[32] = { 0 }, fault_para_str[64] = { 0 }, phase_str[8] = { 0 };\n\t FaultReadCtrl read_ctrl = { 0 };\n\t EventData *event = NULL;\n\t FaultHead *p_fault_head = NULL;\n\t FLOAT32 *fault_para = NULL;\n\t INT32 i = 0, j = 0, para_flag = 0;\n\t UINT32 phase_value = 0;\n\t InVar local_in_value = { 0 };\n\t PrintRefInfo *p_ref_info = NULL, *p_ref_info_para = NULL, *p_ref_info_faultinfo = NULL;\n\n\t p_fault_head = &cp->wave_data.fault_head;\n\t event = (EventData *)HOPEMALLOC(p_fault_head->trip_event_num * sizeof(EventData));\n\t if (NULL == event)\n\t {\n\t\t PRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printDrawoffTripRptItem) Malloc failed!\\n\");\n\t\t return;\n\t }\n\n\t read_ctrl.field = FAULT_DF_TRIP_EVENT;\n\t read_ctrl.off = 0;\n\t read_ctrl.num = p_fault_head->trip_event_num;\n\n\t if (getHisFaultData(p_fault_head, &read_ctrl, (void *)event) < 0)\n\t {\n\t\t PRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printDrawoffTripRptItem) Get his fault data failed!\\n\");\n\t\t HOPEFREE(event);\n\t\t return;\n\t }\n\n\t // 打印标题\n\t printHeaderLineNet(cp, slan_drawoff_trip_rpt_header_str.desc[cp->dev_cfg.lang_sel]);\n\t \n\t printStrLine(cp, drawoff_trip_rpt_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t printStrLine(cp, drawoff_trip_rpt_line_tab1[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t p_ref_info = (PrintRefInfo *)s_ref_tbl_cfg[EN_REF_TBL_TRIP].p_ref_info;\n\t p_ref_info_para = (PrintRefInfo *)s_ref_tbl_cfg[EN_REF_TBL_TRIP_PARA].p_ref_info;\n\t p_ref_info_faultinfo = (PrintRefInfo *)s_ref_tbl_cfg[EN_REF_TBL_FAULT_INFO].p_ref_info;\n\t for (i = 0; i < p_fault_head->trip_event_num; i++)\n\t {\n\t\t // 若是1->0，不打印\n\t\t if (0 == (event[i].data.trip.st_val & 0x01))\n\t\t {\n\t\t\t continue;\n\t\t }\n\n\t\t if (0 == i)\n\t\t {\n\t\t\t printStrLine(cp, drawoff_trip_rpt_line_tab2[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t cp->print_ptr += 2;\n\n\t\t\t // 报告序号\n\t\t\t sprintf(cp->print_ptr, \"%04d\", p_fault_head->no);\n\t\t\t cp->print_ptr += 7;\n\t\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t cp->print_ptr += 3;\n\n\t\t\t longSecAndVsecToManTime(p_fault_head->t.sec, p_fault_head->t.us, time_str);\n\t\t\t printAddStrToBufAndModifyPtr(cp, time_str, strlen(time_str) + 2);\n\n\t\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t cp->print_ptr += 1;\n\t\t }\n\t\t else\n\t\t {\n\t\t\t if (0 == para_flag)\n\t\t\t {\n\t\t\t\t printStrLine(cp, drawoff_trip_rpt_line_tab3[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t printStrLine(cp, drawoff_trip_rpt_line_tab3a[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t\t\t }\n\t\t\t para_flag = 0;\n\t\t\t \n\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t cp->print_ptr += 8;\n\n\t\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t cp->print_ptr += 28;\n\n\t\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t cp->print_ptr += 1;\n\t\t }\n\n\t\t // 相对时间\n\t\t if (event[i].data.trip.ret_ms > 3600 * 1000)\n\t\t {\n\t\t\t sprintf(time_rt_str, \"%s\", \">3600\");\n\t\t\t strcat(time_rt_str, \" s\");\n\t\t }\n\t\t else\n\t\t {\n\t\t\t sprintf(time_rt_str, \"%05d\", event[i].data.trip.ret_ms);\n\t\t\t strcat(time_rt_str, \"ms\");\n\t\t }\n\n\t\t printAddStrToBufAndModifyPtr(cp, time_rt_str, 9);\n\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t\t // 相别\n\t\t cp->print_ptr += 3;\n\t\t phase_str[0] = '\\0';\n\t\t if (event[i].data.trip.st_val & 0x02)\n\t\t {\n\t\t\t strcat(phase_str, \"A\");\n\t\t }\n\n\t\t if (event[i].data.trip.st_val & 0x04)\n\t\t {\n\t\t\t strcat(phase_str, \"B\");\n\t\t }\n\n\t\t if (event[i].data.trip.st_val & 0x08)\n\t\t {\n\t\t\t strcat(phase_str, \"C\");\n\t\t }\n\n\t\t printAddStrToBufAndModifyPtr(cp, phase_str, 7);\n\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t cp->print_ptr += 4;\n\n\t\t // 描述\n\t\t p_datafield = p_ref_info->p_item[event[i].data.trip.st_no].p_datafield;\n\t\t if (p_datafield)\n\t\t {\n\t\t\t printAddStrToBufAndModifyPtr(cp, p_datafield->desc, 42);\n\t\t }\n\t\t else\n\t\t {\n\t\t\t cp->print_ptr += 42;\n\t\t }\n\n\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t printCharLine(cp, WITH_RETURN);\n\n\t\t // 条目动作参数\n\t\t for (j = 0; j < event[i].data.trip.para_num; j++)\n\t\t {\n\t\t\t p_datafield_para = p_ref_info_para->p_item[event[i].data.trip.para_no[j]].p_datafield;\n\t\t\t if (0 == DESC_EVENT_VISIBLE(p_datafield_para))\n\t\t\t {\n\t\t\t\t continue;\n\t\t\t }\n\n\t\t\t if (0 == j)\n\t\t\t {\n\t\t\t\t printStrLine(cp, drawoff_trip_rpt_line_tab4[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t printStrLine(cp, drawoff_trip_rpt_line_tab4a[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t\t\t }\n\n\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t cp->print_ptr += 8;\n\n\t\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t cp->print_ptr += 28;\n\n\t\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t cp->print_ptr += 10;\n\n\t\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t cp->print_ptr += 2;\n\n\t\t\t // 描述\n\t\t\t if (p_datafield_para)\n\t\t\t {\n\t\t\t\t printAddStrToBufAndModifyPtr(cp, p_datafield_para->desc, 30);\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t cp->print_ptr += 30;\n\t\t\t }\n\n\t\t\t // 值\n\t\t\t local_in_value.value = *((UINT32 *)&event[i].data.trip.val[j]);\n\t\t\t printInvarFormatToBuffer(p_datafield_para, &local_in_value, cp->print_ptr, cp->print_ptr + 16 - 1,\n\t\t\t\t\t\t\t\t\t\tprintGetInVar(EN_IN_SIG_PRIM_OR_SEC) - 1);\n\t\t\t cp->print_ptr += 16;\n\n\t\t\t // 量纲\n\t\t\t printAddStrToBufAndModifyPtr(cp, p_datafield_para->unit, 10);\n\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t printCharLine(cp, WITH_RETURN);\n\n\t\t\t para_flag = 1;\n\t\t }\n\t }\n\n\t if (NULL != event)\n\t {\n\t\t HOPEFREE(event);\n\t\t event = NULL;\n\t }\n\n\t if (0 == para_flag)\n\t {\n\t\t printStrLine(cp, drawoff_trip_rpt_line_tab5[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t }\n\t else\n\t {\n\t\t printStrLine(cp, drawoff_trip_rpt_line_tab5a[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t }\n\t para_flag = 0;\n\n\t // 整组动作参数\n\t if (p_fault_head->para_num)\n\t {\n\t\t fault_para = (FLOAT32 *)HOPEMALLOC(p_fault_head->para_num * sizeof(FLOAT32));\n\t\t if (NULL == fault_para)\n\t\t {\n\t\t\t PRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printDrawoffTripRptItem) Malloc failed1!\\n\");\n\t\t\t return;\n\t\t }\n\n\t\t read_ctrl.field = FAULT_DF_PARA_VAL;\n\t\t read_ctrl.off = 0;\n\t\t read_ctrl.num = p_fault_head->para_num;\n\t\t if (getHisFaultData(p_fault_head, &read_ctrl, (void *)fault_para) >= 0)\n\t\t {\n\t\t\t for (i = 0; i < p_fault_head->para_num; i++)\n\t\t\t {\n\t\t\t\t p_datafield_faultinfo = p_ref_info_faultinfo->p_item[i].p_datafield;\n\t\t\t\t if (0 == DESC_WAVE_VISIBLE(p_datafield_faultinfo))\n\t\t\t\t {\n\t\t\t\t\t continue;\n\t\t\t\t }\n\n\t\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t\t cp->print_ptr += 6;\n\n\t\t\t\t // 中英文描述\n\t\t\t\t if (p_datafield_faultinfo)\n\t\t\t\t {\n\t\t\t\t\t printAddStrToBufAndModifyPtr(cp, p_datafield_faultinfo->desc, 60);\n\t\t\t\t }\n\t\t\t\t else\n\t\t\t\t {\n\t\t\t\t\t cp->print_ptr += 60;\n\t\t\t\t }\n\n\t\t\t\t // 值\n\t\t\t\t if (2 == p_ref_info_faultinfo->p_item[i].para[EN_FAULTINFO_TBL_PARA_FAULT_TYPE])\n\t\t\t\t {\n\t\t\t\t\t switch(p_datafield_faultinfo->type)\n\t\t\t\t\t {\n\t\t\t\t\t case BITS_TYPE:\n\t\t\t\t\t case INT8_TYPE:\n\t\t\t\t\t\t phase_value = *((INT8 *)&fault_para[i]);\n\t\t\t\t\t\t break;\n\n\t\t\t\t\t case UINT8_TYPE:\n\t\t\t\t\t\t phase_value = *((UINT8 *)&fault_para[i]);\n\t\t\t\t\t\t break;\n\n\t\t\t\t\t case INT16_TYPE:\n\t\t\t\t\t\t phase_value = *((INT16 *)&fault_para[i]);\n\t\t\t\t\t\t break;\n\n\t\t\t\t\t case UINT16_TYPE:\n\t\t\t\t\t\t phase_value = *((UINT16 *)&fault_para[i]);\n\t\t\t\t\t\t break;\n\n\t\t\t\t\t case INT32_TYPE:\n\t\t\t\t\t\t phase_value = *((INT32 *)&fault_para[i]);\n\t\t\t\t\t\t break;\n\n\t\t\t\t\t case UINT32_TYPE:\n\t\t\t\t\t\t phase_value = *((UINT32 *)&fault_para[i]);\n\t\t\t\t\t\t break;\n\n\t\t\t\t\t default:\n\t\t\t\t\t\t phase_value = *((INT8 *)&fault_para[i]);\n\t\t\t\t\t\t break;\n\t\t\t\t\t }\n\n\t\t\t\t\t fault_para_str[0] = '\\0';\n\t\t\t\t\t if (phase_value & 0x01)\n\t\t\t\t\t {\n\t\t\t\t\t\t strcat(fault_para_str, \"A\");\n\t\t\t\t\t }\n\n\t\t\t\t\t if (phase_value & 0x02)\n\t\t\t\t\t {\n\t\t\t\t\t\t strcat(fault_para_str, \"B\");\n\t\t\t\t\t }\n\n\t\t\t\t\t if (phase_value & 0x04)\n\t\t\t\t\t {\n\t\t\t\t\t\t strcat(fault_para_str, \"C\");\n\t\t\t\t\t }\n\n\t\t\t\t\t cp->print_ptr += 10;\n\t\t\t\t\t printAddStrToBufAndModifyPtr(cp, fault_para_str, 10);\n\t\t\t\t }\n\t\t\t\t else\n\t\t\t\t {\n\t\t\t\t\t local_in_value.value = *((UINT32 *)&fault_para[i]);\n\t\t\t\t\t printInvarFormatToBuffer(p_datafield_faultinfo, &local_in_value, cp->print_ptr, cp->print_ptr + 10 - 1,\n\t\t\t\t\t\t printGetInVar(EN_IN_SIG_PRIM_OR_SEC) - 1);\n\t\t\t\t\t cp->print_ptr += 20;\n\t\t\t\t }\n\n\t\t\t\t cp->print_ptr += 10;\n\n\t\t\t\t // 量纲\n\t\t\t\t if (p_datafield_faultinfo)\n\t\t\t\t {\n\t\t\t\t\t printAddStrToBufAndModifyPtr(cp, p_datafield_faultinfo->unit, 10);\n\t\t\t\t }\n\t\t\t\t else\n\t\t\t\t {\n\t\t\t\t\t cp->print_ptr += 10;\n\t\t\t\t }\n\n\t\t\t\t cp->print_ptr += 4;\n\t\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t\t\t\t printCharLine(cp, WITH_RETURN);\n\t\t\t }\n\t\t }\n\n\t\t if (NULL != fault_para)\n\t\t {\n\t\t\t HOPEFREE(fault_para);\n\t\t\t fault_para = NULL;\n\t\t }\n\t }\n\n\t printStrLine(cp, drawoff_trip_rpt_line_tab6[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t printCharLine(cp, WITH_RETURN);\n\n\t return;\n }\n\n LOCAL void printEventInitState(Print *cp)\n {\nprintf(\"[%s, %d]: para is %#x\\n\", __FUNCTION__, __LINE__, cp->print_shm_content.print_para_val[2]);\n\n\t if (cp->print_shm_content.print_para_val[2] & PRINT_DRAWOFF_SELFSUPERV_ENABLE)\n\t {\n\t\t printEventInitStateItem(cp, &s_ref_tbl_cfg[EN_REF_TBL_SELF_CHECK]);\n\t }\n\n\t if (cp->print_shm_content.print_para_val[2] & PRINT_DRAWOFF_BINCHG_ENABLE)\n\t {\n\t\t printEventInitStateItem(cp, &s_ref_tbl_cfg[EN_REF_TBL_BINCHG]);\n\t }\n\n\t return;\n }\n\n LOCAL void printEventChangeState(Print *cp)\n {\n\t FaultReadCtrl read_ctrl = { 0 };\n\t NoParaEvent *p_selfsuperv_rpt = NULL, *p_binchg_rpt = NULL;\n\n\t if (cp->wave_data.fault_head.chk_event_num)\n\t {\n\t\t p_selfsuperv_rpt = (NoParaEvent *)HOPEMALLOC(cp->wave_data.fault_head.chk_event_num * sizeof(NoParaEvent));\n\t\t if (NULL == p_selfsuperv_rpt)\n\t\t {\n\t\t\t PRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printEventChangeState) Malloc failed!\\n\");\n\t\t\t return;\n\t\t }\n\n\t\t read_ctrl.field = FAULT_DF_CHECK_EVENT;\n\t\t read_ctrl.off = 0;\n\t\t read_ctrl.num = cp->wave_data.fault_head.chk_event_num;\n\t\t if (getHisFaultData(&cp->wave_data.fault_head, &read_ctrl, (void *)p_selfsuperv_rpt) >= 0)\n\t\t {\n\t\t\t if (cp->print_shm_content.print_para_val[2] & PRINT_DRAWOFF_SELFSUPERV_ENABLE)\n\t\t\t {\n\t\t\t\t printEventChangeStateItem(cp, p_selfsuperv_rpt, cp->wave_data.fault_head.chk_event_num,\n\t\t\t\t\t\t\t\t\t\t\t&s_ref_tbl_cfg[EN_REF_TBL_SELF_CHECK]);\n\t\t\t }\n\t\t }\n\n\t\t HOPEFREE(p_selfsuperv_rpt);\n\t\t p_selfsuperv_rpt = NULL;\n\t }\n\n\t if (cp->wave_data.fault_head.bi_event_num)\n\t {\n\t\t p_binchg_rpt = (NoParaEvent *)HOPEMALLOC(cp->wave_data.fault_head.bi_event_num * sizeof(NoParaEvent));\n\t\t if (NULL == p_binchg_rpt)\n\t\t {\n\t\t\t PRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printEventChangeState) Malloc failed1!\\n\");\n\t\t\t return;\n\t\t }\n\n\t\t read_ctrl.field = FAULT_DF_BI_EVENT;\n\t\t read_ctrl.off = 0;\n\t\t read_ctrl.num = cp->wave_data.fault_head.bi_event_num;\n\nprintf(\"[%s, %d]: para is %#x\\n\", __FUNCTION__, __LINE__, cp->print_shm_content.print_para_val[2]);\n\n\t\t if (getHisFaultData(&cp->wave_data.fault_head, &read_ctrl, (void *)p_binchg_rpt) >= 0)\n\t\t {\n\t\t\t if (cp->print_shm_content.print_para_val[2] & PRINT_DRAWOFF_BINCHG_ENABLE)\n\t\t\t {\n\t\t\t\t printEventChangeStateItem(cp, p_binchg_rpt, cp->wave_data.fault_head.bi_event_num,\n\t\t\t\t\t\t\t\t\t\t\t&s_ref_tbl_cfg[EN_REF_TBL_BINCHG]);\n\t\t\t }\n\n\t\t\t HOPEFREE(p_binchg_rpt);\n\t\t\t p_binchg_rpt = NULL;\n\t\t }\n\t }\n\n\t printCharLine(cp, WITH_RETURN);\n\n\t return;\n }\n\n LOCAL void printEventInitStateItem(Print *cp, PrintRefTblCfg *p_ref_tbl_cfg)\n {\n\t INT32 row_num = 0;\n\t INT32 i = 0, n = 0, print_item_num = 0;\n\t DataFields *p_datafield = NULL;\n\t UINT16 local_bool_value = 0, local_no = 0;\n\t UINT16 *p_state_val = NULL, state_int16_num = 0;\n\t FaultReadCtrl read_ctrl = { 0 };\n\t FaultHead *p_fault_head = NULL;\n\t UINT16 *local_item_offset = NULL, *local_offset = NULL, *local_bit_offset = NULL;\n\t PrintRefInfo *p_ref_info = NULL;\n\t RefParameterItems *p_ref_tbl_item = NULL;\n\t UINT16 index = 0;\n\n\t p_ref_info = (PrintRefInfo *)p_ref_tbl_cfg->p_ref_info;\n\t p_ref_tbl_item = p_ref_info->p_tbl;\n\t local_item_offset = (UINT16 *)HOPEMALLOC(p_ref_tbl_item->num * sizeof(UINT16));\n\t if (NULL == local_item_offset)\n\t {\n\t\t PRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printEventInitStateItem) Malloc failed!\\n\");\n\t\t return;\n\t }\n\n\t local_bit_offset = (UINT16 *)HOPEMALLOC(p_ref_tbl_item->num * sizeof(UINT16));\n\t if (NULL == local_bit_offset)\n\t {\n\t\t PRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printEventInitStateItem) Malloc failed1!\\n\");\n\t\t return;\n\t }\n\n\t local_offset = (UINT16 *)HOPEMALLOC(p_ref_tbl_item->num * sizeof(UINT16));\n\t if (NULL == local_offset)\n\t {\n\t\t PRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printEventInitStateItem) Malloc failed2!\\n\");\n\t\t return;\n\t }\n\n\t for (i = 0; i < p_ref_tbl_item->num; i++)\n\t {\n\t\t p_datafield = p_ref_info->p_item[i].p_datafield;\n\n\t\t if (p_ref_info->p_item[i].para[EN_SELFCHECK_TBL_PRINT_IN_DRAWOFF_RPT] &&\n\t\t\t DESC_WAVE_VISIBLE(p_datafield))\n\t\t {\n\t\t\t local_item_offset[print_item_num] = i;\n\t\t\t local_offset[print_item_num] = index;\n\t\t\t print_item_num++;\n\t\t }\n\n\t\t if (DESC_WAVE_VISIBLE(p_datafield))\n\t\t {\n\t\t\t local_bit_offset[index] = index;\n\t\t\t index++;\n\t\t }\n\t }\n\n\t if (0 == print_item_num)\n\t {\n\t\t return;\n\t }\n\n\t state_int16_num = (p_ref_tbl_item->num + 15) >> 4;\n\t p_state_val = (UINT16 *)HOPEMALLOC(state_int16_num * sizeof(UINT16));\n\t if (NULL == p_state_val)\n\t {\n\t\t PRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printEventInitStateItem) Malloc failed1!\\n\");\n\t\t return;\n\t }\n\n\t p_fault_head = &cp->wave_data.fault_head;\n\t if (p_ref_tbl_cfg == &s_ref_tbl_cfg[EN_REF_TBL_SELF_CHECK])\n\t {\n\t\t read_ctrl.field = FAULT_DF_CHK_STATE;\n\t }\n\t else\n\t {\n\t\t read_ctrl.field = FAULT_DF_BI_VAL;\n\t }\n\t read_ctrl.off = 0;\n\t read_ctrl.num = state_int16_num;\n\n\t if (getHisFaultData(p_fault_head, &read_ctrl, (void *)p_state_val) < 0)\n\t {\n\t\t PRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printEventStateItem) Get his fault data failed1!\\n\");\n\t\t HOPEFREE(local_item_offset);\n\t\t local_item_offset = NULL;\n\n\t\t HOPEFREE(local_bit_offset);\n\t\t local_bit_offset = NULL;\n\n\t\t HOPEFREE(local_offset);\n\t\t local_offset = NULL;\n\n\t\t HOPEFREE(p_state_val);\n\t\t p_state_val = NULL;\n\n\t\t return;\n\t }\n\n\t if (p_ref_tbl_cfg == &s_ref_tbl_cfg[EN_REF_TBL_SELF_CHECK])\n\t {\n\t\t printStrLine(cp, slan_selfcheck_init_state_str.desc[cp->dev_cfg.lang_sel], WITH_RETURN);\n\t }\n\t else\n\t {\n\t\t printStrLine(cp, slan_binchg_init_state_str.desc[cp->dev_cfg.lang_sel], WITH_RETURN);\n\t }\n\n\t printStrLine(cp, event_init_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t printStrLine(cp, event_init_line_tab1[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t // 行循环\n\t row_num = (print_item_num + 1) >> 1;\n\t for (i = 0; i < row_num; i++)\n\t {\n\t\t printStrLine(cp, event_init_line_tab2[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t\t // 两列循环\n\t\t for (n = 0; n < 2; n++)\n\t\t {\n\t\t\t if (0 == n)\n\t\t\t {\n\t\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t }\n\n\t\t\t // 序号\n\t\t\t if (0 == n)\n\t\t\t {\n\t\t\t\t local_no = i + 1;\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t local_no = i + 1 + row_num;\n\t\t\t }\n\n\t\t\t if (local_no < 100)\n\t\t\t {\n\t\t\t\t cp->print_ptr += 1;\n\t\t\t\t sprintf(cp->print_ptr, \"%02d\", local_no);\n\t\t\t\t cp->print_ptr += 2;\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t sprintf(cp->print_ptr, \"%03d\", local_no);\n\t\t\t\t cp->print_ptr += 3;\n\t\t\t }\n\n\t\t\t *cp->print_ptr++ = ' ';\n\t\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t\t\t if (0 == n)\n\t\t\t {\n\t\t\t\t p_datafield = p_ref_info->p_item[local_item_offset[i]].p_datafield;\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t p_datafield = p_ref_info->p_item[local_item_offset[i + row_num]].p_datafield;\n\t\t\t }\n\n\t\t\t // 描述\n\t\t\t cp->print_ptr += 2;\n\t\t\t printAddStrToBufAndModifyPtr(cp, p_datafield->desc, 37);\n\n\t\t\t *cp->print_ptr++ = ':';\n\t\t\t cp->print_ptr += 4;\n\n\t\t\t if (0 == n)\n\t\t\t {\n\t\t\t\t local_bool_value = p_state_val[local_bit_offset[local_offset[i]] >> 4] & (1 << (local_bit_offset[local_offset[i]] & 0x0f));\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t local_bool_value = p_state_val[(local_bit_offset[local_offset[row_num + i]]) >> 4] & (1 << ((local_bit_offset[local_offset[row_num + i]]) & 0x0f));\n\t\t\t }\n\n\t\t\t if (local_bool_value)\n\t\t\t {\n\t\t\t\t *cp->print_ptr = '1';\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t *cp->print_ptr = '0';\n\t\t\t }\n\n\t\t\t cp->print_ptr += 4;\n\n\t\t\t if ((i == row_num - 1) && (print_item_num & 0x01))\n\t\t\t {\n\t\t\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t\t cp->print_ptr += 4;\n\t\t\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t\t cp->print_ptr += 39;\n\t\t\t\t *cp->print_ptr++ = ':';\n\t\t\t\t cp->print_ptr += 8;\n\t\t\t\t break;\n\t\t\t }\n\t\t }\n\n\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t printCharLine(cp, WITH_RETURN);\n\t }\n\n\t printStrLine(cp, event_init_line_tab3[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t HOPEFREE(local_item_offset);\n\t local_item_offset = NULL;\n\n\t HOPEFREE(local_bit_offset);\n\t local_bit_offset = NULL;\n\n\t HOPEFREE(local_offset);\n\t local_offset = NULL;\n\n\t HOPEFREE(p_state_val);\n\t p_state_val = NULL;\n\n\t return;\n }\n\n LOCAL void printEventChangeStateItem(Print *cp, NoParaEvent *p_event_rpt, UINT16 changed_num, PrintRefTblCfg *p_ref_tbl_cfg)\n {\n\t INT32 i = 0, local_rt = 0, local_val = 0;\n\t DataFields *p_datafield = NULL;\n\t PrintRefInfo *p_ref_info = NULL;\n\n\t p_ref_info = (PrintRefInfo *)p_ref_tbl_cfg->p_ref_info;\n\t if (p_ref_tbl_cfg == &s_ref_tbl_cfg[EN_REF_TBL_SELF_CHECK])\n\t {\n\t\t printStrLine(cp, slan_selfcheck_chg_state_str.desc[cp->dev_cfg.lang_sel], WITH_RETURN);\n\t }\n\t else\n\t {\n\t\t printStrLine(cp, slan_binchg_chg_state_str.desc[cp->dev_cfg.lang_sel], WITH_RETURN);\n\t }\n\n\t printStrLine(cp, event_change_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t printStrLine(cp, event_change_line_tab1[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t for (i = 0; i < changed_num; i++)\n\t {\n\t\t if (0 == i % 2)\n\t\t {\n\t\t\t printStrLine(cp, event_change_line_tab2[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t }\n\t\t else\n\t\t {\n\t\t\t cp->print_ptr += 2;\n\t\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t }\n\n\t\t // 序号\n\t\t if (i < 100)\n\t\t {\n\t\t\t cp->print_ptr += 1;\n\t\t\t sprintf(cp->print_ptr, \"%02d\", i);\n\t\t\t cp->print_ptr += 2;\n\t\t\t *cp->print_ptr++ = ' ';\n\t\t }\n\t\t else\n\t\t {\n\t\t\t sprintf(cp->print_ptr, \"%03d\", i);\n\t\t\t cp->print_ptr += 3;\n\t\t\t *cp->print_ptr++ = ' ';\n\t\t }\n\n\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t\t // 相对时间\n\t\t local_rt = ((p_event_rpt[i].t.sec - cp->wave_data.fault_head.t.sec) * 1000000\n\t\t\t\t\t + (p_event_rpt[i].t.us - cp->wave_data.fault_head.t.us)) * 0.001;\t\t\t//modified \n\t\t sprintf(cp->print_ptr, \"%05d\", local_rt);\n\t\t cp->print_ptr += 5;\n\t\t *cp->print_ptr++ = ' ';\n\t\t *cp->print_ptr++ = 'm';\n\t\t *cp->print_ptr++ = 's';\n\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t cp->print_ptr += 2;\n\t\t \n\t\t // 描述\n\t\t p_datafield = p_ref_info->p_item[p_event_rpt[i].st_no].p_datafield;\n\t\t if (p_datafield)\n\t\t {\n\t\t\t printAddStrToBufAndModifyPtr(cp, p_datafield->desc, 27);\n\t\t }\n\t\t else\n\t\t {\n\t\t\t cp->print_ptr += 27;\n\t\t }\n\n\t\t *cp->print_ptr++ = ':';\n\t\t cp->print_ptr += 2;\n\n\t\t // 值\n\t\t local_val = p_event_rpt[i].st_val;\n\t\t if (local_val)\n\t\t {\n\t\t\t printAddStrToBufAndModifyPtr(cp, clear_to_set_str[cp->print_method][cp->dev_cfg.lang_sel], 4);\n\t\t }\n\t\t else\n\t\t {\n\t\t\t printAddStrToBufAndModifyPtr(cp, set_to_clear_str[cp->print_method][cp->dev_cfg.lang_sel], 4);\n\t\t }\n\n\t\t if (i % 2)\n\t\t {\n\t\t\t cp->print_ptr += 2;\n\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t cp->print_ptr += 2;\n\t\t\t printCharLine(cp, WITH_RETURN);\n\t\t }\n\t\t else\n\t\t {\n\t\t\t if (i + 1 == changed_num)\n\t\t\t {\n\t\t\t\t cp->print_ptr += 2;\n\t\t\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t\t\t\t cp->print_ptr += 4;\n\t\t\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t\t\t\t cp->print_ptr += 8;\n\t\t\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t\t\t\t cp->print_ptr += 38;\n\t\t\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t\t\t\t cp->print_ptr += 2;\n\t\t\t\t printCharLine(cp, WITH_RETURN);\n\t\t\t }\n\t\t }\n\t }\n\n\t printStrLine(cp, event_change_line_tab3[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t return;\n }\n\n /* 打印波形 */\n LOCAL void printOscillogram(Print *cp)\n {\n\t if (PRINT_UART_PROTOCOL == cp->print_method)\n\t {\n\t\t printOscillogramUart(cp);\n\t }\n\t else if (PRINT_ETH_PROTOCOL == cp->print_method)\n\t {\n\t\t printOscillogramNet(cp);\n\t }\n\n\t return;\n }\n\n LOCAL void printOscillogramUart(Print *cp)\n {\n\t // 打印整组报告\n\t printDrawoffTripRpt(cp);\n\n\t // 获取波形数据\n\t if (printGetWaveFile(cp) < 0)\n\t {\n\t\t return;\n\t }\n\n\t // 打印事件报文\n\t printEventInitState(cp);\n\n\t printEventChangeState(cp);\n\n\t // 打印波形\n\t if (cp->print_shm_content.print_para_val[2] & PRINT_DRAWOFF_WAVE_ENABLE)\n\t {\n\t\t printWaveNofUart(cp);\n\t }\n\n\t // 打印波形采样值\n\t if (cp->print_shm_content.print_para_val[2] & PRINT_DRAWOFF_SMPL_ENABLE)\n\t {\n\t\t printWaveSmplUart(cp);\n\t }\n\n\t // 打印录波定值\n\t if (cp->print_shm_content.print_para_val[2] & PRINT_DRAWOFF_SETTING_ENABLE)\n\t {\n\t\t cp->print_rec_set_flag = 0x5a;\n\t\t printSettings(cp);\n\t\t cp->print_rec_set_flag = 0;\n\t }\n\n\t // 释放波形数据空间\n\t printFreeWaveHeap(cp);\n\n\t return;\n }\n\n LOCAL void printOscillogramNet(Print *cp)\n {\n\t // 打印整组报告\n\t printDrawoffTripRpt(cp);\n\n\t // 获取波形数据\n\t if (printGetWaveFile(cp) < 0)\n\t {\n\t\t printf(\"error!\\n\");\n\t\t return;\n\t }\n\n\t // 打印事件报文\n\t printEventInitState(cp);\n\n\t printEventChangeState(cp);\n\n\t // 打印波形\n\t if (cp->print_shm_content.print_para_val[2] & PRINT_DRAWOFF_WAVE_ENABLE)\n\t {\n\t\t printWaveNof(cp);\n\t }\n\n\t // 打印波形采样值\n\t if (cp->print_shm_content.print_para_val[2] & PRINT_DRAWOFF_SMPL_ENABLE)\n\t { \n\t\t printWaveSmplUart(cp);\n\t }\n\n\t // 打印录波定值\n\t if (cp->print_shm_content.print_para_val[2] & PRINT_DRAWOFF_SETTING_ENABLE)\n\t {\n\t\t // 打印定值\n\t\t cp->print_rec_set_flag = 0x5a;\n\t\t printSettings(cp);\n\t\t cp->print_rec_set_flag = 0;\n\t }\n\n\t // 释放波形数据空间\n\t printFreeWaveHeap(cp);\n\t \n\t return;\n }\n\n /* 打印波形采样值 */\n LOCAL void printWaveSmplUart(Print *cp)\n {\n\t INT32 wave_id = 0, i = 0, j = 0, k = 0, m = 0, len = 0, local_index = 0;\n\t PrintRefInfo *p_ref_info = NULL, *p_ref_info_analog = NULL;\n\t UINT32 analog_item_select = 0, *p_time = 0, read_num = 0, print_space = 0, time_dat = 0;\n\t FILE *fp = NULL;\n\t INT8 file_dat_name[64] = { 0 }, *p_buffer_ptr_app = NULL, buf[64] = { 0 };\n\t UINT16 mask_flag[16] = { 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,\n\t\t\t\t\t\t\t  0x0100, 0x0200, 0x0400, 0x0800, 0x1000, 0x2000, 0x4000, 0x8000}, smpl_val = 0;\n\t UINT8 mask_index[16] = { 0 }, mask_num[16] = { 0 }, flag = 0, index = 0, *int8_ptr = NULL;\n\t FLOAT32 time_stamp = 0.;\n\t \n\t // 当前选中的波形组ID号\n\t //wave_id = cp->print_shm_content.print_para_val[3];\n\t \n\t // 寻找当前波形组\n\t p_ref_info = (PrintRefInfo *)s_ref_tbl_cfg[EN_REF_TBL_WAVE_TITLE].p_ref_info;\n\n\t //调整波形ID号获取\n\t if (cp->print_shm_content.print_para_num > 3)\n\t     wave_id = cp->print_shm_content.print_para_num - 2;\n\t else\n\t     wave_id = cp->print_shm_content.print_para_val[3];\n\t \n\t if (wave_id > p_ref_info->entry_num)\n\t {\n\t\t printf(\"[print]: (_func_printWaveSmplUart) Selected wave grp is not exist!\\n\");\n\t\t return;\n\t }\n\n\t // 寻找该波形组分几组打印采样值\n\t analog_item_select = p_ref_info->p_item[wave_id].para[EN_WAVE_TITLE_TBL_PARA_SMPL_VAL];\n\t for (i = 0; i < 16; i++)\n\t {\n\t\t if (analog_item_select & mask_flag[i])\n\t\t {\n\t\t\t mask_index[index++] = i;\n\t\t\t flag = 1;\n\t\t }\n\t }\n\n\t if (0 == flag)\n\t {\n\t\t return;\n\t }\n\n\t // 获取波形文件\n\t getWaveName(&cp->wave_data.fault_head.t, cp->wave_data.fault_head.nof,\n\t\t\t\t\tgp_wave_file_dir[EN_WAVE_USER_ID],\n\t\t\t\t\tgp_fault_file_ext_name[EN_FAULT_DAT_NAME_ID], file_dat_name);\n\n\t // 打印采样值\n\t p_ref_info_analog = (PrintRefInfo *)s_ref_tbl_cfg[EN_REF_TBL_USER_INST_AI].p_ref_info;\n\n\t // 计算每组采样值\n\t for (i = 0; i < index; i++)\n\t {\n\t\t for (j = 0; j < p_ref_info_analog->entry_num; j++)\n\t\t {\n\t\t     if (((cp->print_shm_content.print_para_num > 3) && \n\t\t\t \t(0 == (p_ref_info_analog->p_item[j].para[EN_USER_AI_TBL_PARA_PRINT_PAGE] & ((1 << wave_id)-1)))) ||\n\t\t\t \t(0 == DESC_WAVE_VISIBLE(p_ref_info_analog->p_item[j].p_datafield)) ||\n\t\t\t \t((cp->print_shm_content.print_para_num <= 3) &&\n\t\t\t \t(0 == (p_ref_info_analog->p_item[j].para[EN_USER_AI_TBL_PARA_PRINT_PAGE] & (1 << wave_id)))))\n\t\t     {\n\t\t         continue;\n\t\t     }\n\n\t\t\t if (p_ref_info_analog->p_item[j].para[EN_USER_AI_TBL_PARA_SMPL_PAGE] & mask_flag[mask_index[i]])\n\t\t\t {\n\t\t\t\t mask_num[i]++;\n\t\t\t }\n\t\t }\n\t }\n\n\t if (0 == cp->comtrade_data_type)\n\t {\n\t\t // 波形为BINARY格式\n\t\t for (i = 0; i < index; i++)\n\t\t { \n\t\t\t if(0 == mask_num[i])\n\t\t\t {\n\t\t\t\t continue;\n\t\t\t }\n\n\t\t\t print_space = (PRINT_LINE_CHAR_LEN - 30) / (mask_num[i] * 2);\n\n\n\t\t\t len = sprintf(cp->print_ptr, \"第%d组采样值：\", i + 1);\n\t\t\t cp->print_ptr += len;\n\t\t\t printCharLine(cp, WITH_RETURN);\n\n\t\t\t len = sprintf(cp->print_ptr, \"序号\");\n\t\t\t cp->print_ptr += len;\n\t\t\t cp->print_ptr += 4;\n\n\t\t\t len = sprintf(cp->print_ptr, \"采样时间(ms)\");\n\t\t\t cp->print_ptr += 11;\n\t\t\t cp->print_ptr += 4;\n\n\t\t\t local_index = 0;\n\t\t\t for (k = 0; k < cp->wave_data.ana_num; k++, local_index++)\n\t\t\t {\n\t\t\t\t // 如果该条目对波形不可见\n\t\t\t\t if (0 == DESC_WAVE_VISIBLE(p_ref_info_analog->p_item[local_index].p_datafield))\n\t\t\t\t {\n\t\t\t\t\t k--;\n\t\t\t\t\t continue;\n\t\t\t\t }\n\n\t\t\t\t // 如果该条目不在此波形打印页\n\t\t\t\t if ((cp->print_shm_content.print_para_num <= 3) &&\n\t\t\t\t \t0 == (p_ref_info_analog->p_item[local_index].para[EN_USER_AI_TBL_PARA_PRINT_PAGE] & (1 << wave_id)))\n\t\t\t\t {\n\t\t\t\t\t continue;\n\t\t\t\t }\n\n\t\t\t\t if ((cp->print_shm_content.print_para_num > 3) &&\n\t\t\t\t \t0 == (p_ref_info_analog->p_item[local_index].para[EN_USER_AI_TBL_PARA_PRINT_PAGE] & ((1 << wave_id)-1)))\n\t\t\t\t {\n\t\t\t\t\t continue;\n\t\t\t\t }\n\n\t\t\t\t if (p_ref_info_analog->p_item[local_index].para[EN_USER_AI_TBL_PARA_SMPL_PAGE] & mask_flag[mask_index[i]])\n\t\t\t\t {\n\t\t\t\t\t cp->print_ptr++;\n\t\t\t\t\t len = sprintf(cp->print_ptr, \"%s(%s)\", p_ref_info_analog->p_item[local_index].p_datafield->desc,\n\t\t\t\t\t\t\t\t\t\tp_ref_info_analog->p_item[local_index].p_datafield->unit);\n\t\t\t\t\t cp->print_ptr += 11;\n\n\t\t\t\t\t cp->print_ptr += print_space;\n\t\t\t\t }\n\t\t\t }\n\t\t\t printCharLine(cp, WITH_RETURN);\n\n\t\t\t // 分割线\n\t\t\t printStrLine(cp, title_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t\t\t // 从NAND FLASH中读出波形\n\t\t\t fp = fopen(file_dat_name, \"r\");\n\t\t\t if (NULL == fp)\n\t\t\t {\n\t\t\t\t printf(\"[print]: (_func_printWaveSmplUart) Cann't open %s!\\n\", file_dat_name);\n\t\t\t\t return;\n\t\t\t }\n\t\t\t \n\t\t\t p_buffer_ptr_app = cp->component_buf;\n\t\t\t for (j = 0; j < cp->wave_data.rec_total_dot_num; j++)\n\t\t\t {\n\t\t\t\t read_num = fread(p_buffer_ptr_app, 4 + 4 + sizeof(INT16) * cp->wave_data.ana_num + cp->wave_data.bin_int16_num * sizeof(UINT16), 1, fp);\n\t\t\t\t \n\t\t\t\t len = sprintf(cp->print_ptr, \"%04d\", j + 1);\n\t\t\t\t cp->print_ptr += len;\n\n\t\t\t\t cp->print_ptr += 4;\n\n\t\t\t\t p_time = (UINT32 *)(p_buffer_ptr_app + 4);\n\n#if _BYTE_ORDER == _BIG_ENDIAN\t\n\t\t\t\t time_dat = LONGSWAP(*p_time);\n#else\n\t\t\t\t time_dat = *p_time;\n#endif\n\t\t\t\t time_stamp = (time_dat) / 1000. - 100.;\n\t\t\t\t len = sprintf(cp->print_ptr, \"%09.2f\", time_stamp);\n\t\t\t\t cp->print_ptr += 11;\n\t\t\t\t cp->print_ptr += 4;\n\t\t\t\t \n\t\t\t\t local_index = 0;\n\t\t\t\t for (k = 0; k < cp->wave_data.ana_num; k++, local_index++)\n\t\t\t\t {\n\t\t\t\t\t // 如果该条目对波形不可见\n\t\t\t\t\t if (0 == DESC_WAVE_VISIBLE(p_ref_info_analog->p_item[local_index].p_datafield))\n\t\t\t\t\t {\n\t\t\t\t\t\t k--;\n\t\t\t\t\t\t continue;\n\t\t\t\t\t }\n\n\t\t\t\t\t // 如果该条目不在此波形打印页\n\t\t\t\t\t if ((cp->print_shm_content.print_para_num <= 3) &&\n\t\t\t\t \t    0 == (p_ref_info_analog->p_item[local_index].para[EN_USER_AI_TBL_PARA_PRINT_PAGE] & (1 << wave_id)))\n\t\t\t\t     {\n\t\t\t\t\t     continue;\n\t\t\t\t     }\n\n\t\t\t\t     if ((cp->print_shm_content.print_para_num > 3) &&\n\t\t\t\t \t    0 == (p_ref_info_analog->p_item[local_index].para[EN_USER_AI_TBL_PARA_PRINT_PAGE] & ((1 << wave_id)-1)))\n\t\t\t\t     {\n\t\t\t\t\t     continue;\n\t\t\t\t     }\n\n\t\t\t\t\t if (p_ref_info_analog->p_item[local_index].para[EN_USER_AI_TBL_PARA_SMPL_PAGE] & mask_flag[mask_index[i]])\n\t\t\t\t\t {\n\t\t\t\t\t\t *cp->print_ptr++ = ' ';\n\t\t\t\t\t\t len = sprintf(cp->print_ptr, \"%09.2f\", cp->wave_data.p_analog_buf[j * cp->wave_data.ana_num + k]);\n\t\t\t\t\t\t cp->print_ptr += 11;\n\n\t\t\t\t\t\t cp->print_ptr += print_space; \n\t\t\t\t\t }\n\t\t\t\t }\n\n\t\t\t\t printCharLine(cp, WITH_RETURN);\n\n\t\t\t\t if (0 == (j & 0x0f))\n\t\t\t\t {\n\t\t\t\t\t cp->out_val[EN_OUT_RUN_CNT]++;\n\t\t\t\t }\n\t\t\t }\n\n\t\t\t printCharLine(cp, WITH_RETURN);\n\n\t\t\t fclose(fp);\n\t\t }\n\t }\n\t else\n\t {\n\t\t // 波形为ASCII格式\n\t\t for (i = 0; i < index; i++)\n\t\t {\n\t\t\t if(0 == mask_num[i])\n\t\t\t {\n\t\t\t\t continue;\n\t\t\t }\n\n\t\t\t print_space = (PRINT_LINE_CHAR_LEN - 30) / mask_num[i];\n\n\t\t\t len = sprintf(cp->print_ptr, \"第%d组采样值：\", i + 1);\n\t\t\t cp->print_ptr += len;\n\t\t\t printCharLine(cp, WITH_RETURN);\n\n\t\t\t len = sprintf(cp->print_ptr, \"序号\");\n\t\t\t cp->print_ptr += len;\n\t\t\t cp->print_ptr += 4;\n\n\t\t\t len = sprintf(cp->print_ptr, \"采样时间(ms)\");\n\t\t\t cp->print_ptr += 11;\n\t\t\t cp->print_ptr += 4;\n\n\t\t\t local_index = 0;\n\t\t\t for (k = 0; k < cp->wave_data.ana_num; k++, local_index++)\n\t\t\t {\n\t\t\t\t // 如果该条目对波形不可见\n\t\t\t\t if (0 == DESC_WAVE_VISIBLE(p_ref_info_analog->p_item[local_index].p_datafield))\n\t\t\t\t {\n\t\t\t\t\t k--;\n\t\t\t\t\t continue;\n\t\t\t\t }\n\n\t\t\t\t // 如果该条目不在此波形打印页\n\t\t\t\t if ((cp->print_shm_content.print_para_num <= 3) &&\n\t\t\t\t \t0 == (p_ref_info_analog->p_item[local_index].para[EN_USER_AI_TBL_PARA_PRINT_PAGE] & (1 << wave_id)))\n\t\t\t\t {\n\t\t\t\t\t continue;\n\t\t\t\t }\n\n\t\t\t\t if ((cp->print_shm_content.print_para_num > 3) &&\n\t\t\t\t \t0 == (p_ref_info_analog->p_item[local_index].para[EN_USER_AI_TBL_PARA_PRINT_PAGE] & ((1 << wave_id)-1)))\n\t\t\t\t {\n\t\t\t\t\t continue;\n\t\t\t\t }\n\n\t\t\t\t if (p_ref_info_analog->p_item[local_index].para[EN_USER_AI_TBL_PARA_SMPL_PAGE] & mask_flag[mask_index[i]])\n\t\t\t\t {\n\t\t\t\t\t cp->print_ptr++;\n\t\t\t\t\t len = sprintf(cp->print_ptr, \"%s(%s)\", p_ref_info_analog->p_item[local_index].p_datafield->desc,\n\t\t\t\t\t\t\t\t\t\tp_ref_info_analog->p_item[local_index].p_datafield->unit);\n\t\t\t\t\t cp->print_ptr += 11;\n\n\t\t\t\t\t cp->print_ptr += print_space;\n\t\t\t\t }\n\t\t\t }\n\t\t\t printCharLine(cp, WITH_RETURN);\n\n\t\t\t // 分割线\n\t\t\t printStrLine(cp, title_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t\t\t // 从NAND FLASH中读出波形\n\t\t\t fp = fopen(file_dat_name, \"r\");\n\t\t\t if (NULL == fp)\n\t\t\t {\n\t\t\t\t printf(\"[print]: (_func_printWaveSmplUart) Cann't open %s!\\n\", file_dat_name);\n\t\t\t\t return;\n\t\t\t }\n\n\t\t\t p_buffer_ptr_app = cp->component_buf;\n\t\t\t for (j = 0; j < cp->wave_data.rec_total_dot_num; j++)\n\t\t\t {\n\t\t\t\t if (NULL == fgets(p_buffer_ptr_app, PRINT_BUF_LEN, fp))\n\t\t\t\t {\n\t\t\t\t\t printf(\"[print]: (_func_printWaveSmplUart) Fgets err1!\\n\");\n\t\t\t\t\t fclose(fp);\n\t\t\t\t\t return;\n\t\t\t\t }\n\n\t\t\t\t strtok(p_buffer_ptr_app, \",\\t\\n \");\n\t\t\t\t int8_ptr = (UINT8 *)strtok(NULL, \",\\t\\n \");\n\n\t\t\t\t len = sprintf(cp->print_ptr, \"%04d\", j + 1);\n\t\t\t\t cp->print_ptr += 4;\n\n\t\t\t\t p_time = (UINT32 *)int8_ptr;\n\t\t\t\t time_dat = *p_time;\n\t\t\t\t time_stamp = (time_dat) / 1000. - 100.;\n\t\t\t\t len = sprintf(cp->print_ptr, \"%09.2f\", time_stamp);\n\t\t\t\t cp->print_ptr += 11;\n\t\t\t\t cp->print_ptr += 4;\n\n\t\t\t\t for (k = 0; k < cp->wave_data.ana_num; k++, local_index++)\n\t\t\t\t {\n\t\t\t\t\t // 如果该条目对波形不可见\n\t\t\t\t\t if (0 == DESC_WAVE_VISIBLE(p_ref_info_analog->p_item[local_index].p_datafield))\n\t\t\t\t\t {\n\t\t\t\t\t\t k--;\n\t\t\t\t\t\t continue;\n\t\t\t\t\t }\n\n\t\t\t\t\t // 如果该条目不在此波形打印页\n\t\t\t\t\t if ((cp->print_shm_content.print_para_num <= 3) &&\n\t\t\t\t \t    0 == (p_ref_info_analog->p_item[local_index].para[EN_USER_AI_TBL_PARA_PRINT_PAGE] & (1 << wave_id)))\n\t\t\t\t     {\n\t\t\t\t\t     continue;\n\t\t\t\t     }\n\n\t\t\t\t     if ((cp->print_shm_content.print_para_num > 3) &&\n\t\t\t\t \t    0 == (p_ref_info_analog->p_item[local_index].para[EN_USER_AI_TBL_PARA_PRINT_PAGE] & ((1 << wave_id)-1)))\n\t\t\t\t     {\n\t\t\t\t\t     continue;\n\t\t\t\t     }\n\t\t\t\t\t \n\t\t\t\t\t if (p_ref_info_analog->p_item[local_index].para[EN_USER_AI_TBL_PARA_SMPL_PAGE] & mask_flag[mask_index[i]])\n\t\t\t\t\t {\n\t\t\t\t\t\t *cp->print_ptr++ = ' ';\n\t\t\t\t\t\t len = sprintf(buf, \"%09.2f\", cp->wave_data.p_analog_buf[j * cp->wave_data.ana_num + k]);\n\t\t\t\t\t\t cp->print_ptr += 11;\n\n\t\t\t\t\t\t cp->print_ptr += print_space;\n\t\t\t\t\t }\n\t\t\t\t }\n\n\t\t\t\t printCharLine(cp, WITH_RETURN);\n\n\t\t\t\t if (0 == (j & 0x3f))\n\t\t\t\t {\n\t\t\t\t\t cp->out_val[EN_OUT_RUN_CNT]++;\n\t\t\t\t }\n\t\t\t }\n\n\t\t\t printCharLine(cp, WITH_RETURN);\n\n\t\t\t fclose(fp);\n\t\t }\n\t }\n\n\t if (NULL != fp)\n\t {\n\t\t fclose(fp);\n\t }\n\t\t \n\t return;\n }\n\n LOCAL void printWaveNof(Print *cp)\n {\n\t INT32 i = 0, local_print_group_num = 0;\n\t PrintRefInfo *p_ref_info = NULL;\n\t RefParameterItems *p_ref_tbl_item = NULL;\n\t INT8 *p_str = NULL;\n\n\t local_print_group_num = (cp->print_shm_content.print_para_num - 2);\n\n\t for (i = 0; i < local_print_group_num; i++)\n\t {\n\t\t cp->specific_info.base_index = cp->print_shm_content.print_para_val[3+i];\n\n\t\t if ((0 == cp->each_page_analog_num[cp->specific_info.base_index]) &&\n\t\t\t (0 == cp->each_page_pulse_num[cp->specific_info.base_index]))\n\t\t {\n\t\t\t printNoSpecificWavePage(cp);\n\t\t\t continue;\n\t\t }\n\n\t\t // 打印标题\n\t\t p_ref_info = (PrintRefInfo *)s_ref_tbl_cfg[EN_REF_TBL_WAVE_TITLE].p_ref_info;\n\t\t p_ref_tbl_item = p_ref_info->p_tbl;\n\t\t if (p_ref_tbl_item && (cp->specific_info.base_index < p_ref_tbl_item->num))\n\t\t {\n\t\t\t p_str = strchr(p_ref_tbl_item->item[cp->specific_info.base_index], ':');\n\t\t\t if (p_str)\n\t\t\t {\n\t\t\t\t *p_str = 0;\n\t\t\t }\n\n\t\t\t printHeaderLineNet(cp, (INT8 *)getLocalLangByAbbr(p_ref_tbl_item->item[cp->specific_info.base_index], cp->dev_cfg.lang_sel));\n\t\t }\n\n\t\t // 计算出打印该次波形所需的各个变量值\n\t\t if (printCalcWaveParameter(cp) < 0)\n\t\t {\n\t\t\t return;\n\t\t }\n\n\t\t // 打印波形标度及时间标度\n\t\t if(printWaveScale(cp)<0)\n\t\t {\n\t\t\t return;\n\t\t }\n\n\t\t // 打印跳闸脉冲描述\n\t\t printPulseDescrip(cp);\n\n\t\t // 打印录波通道描述\n\t\t printAnalogDescrip(cp);\n\n\t\t // 打印相对时间描述\n\t\t printRetTimeDescrip(cp);\n\n\t\t // 打印波形头\n\t\t printWaveHead(cp);\n\n\t\t // 打印波形\n\t\t printWaveForm(cp);\n\n\t\t printCharLine(cp, WITH_RETURN);\n\t }\n\n\t return;\n }\n\n LOCAL void printWaveNofUart(Print *cp)\n {\n\t INT32 i = 0, local_print_group_num = 0;\n\t PrintRefInfo *p_ref_info = NULL;\n\t RefParameterItems *p_ref_tbl_item = NULL;\n\t INT8 *p_str = NULL;\n\n\t local_print_group_num = (cp->print_shm_content.print_para_num - 2);\n\n\t for (i = 0; i < local_print_group_num; i++)\n\t {\n\t\t cp->specific_info.base_index = cp->print_shm_content.print_para_val[3+i];\n\n\t\t if ((0 == cp->each_page_analog_num[cp->specific_info.base_index]) &&\n\t\t\t (0 == cp->each_page_pulse_num[cp->specific_info.base_index]))\n\t\t {\n\t\t\t printNoSpecificWavePageUart(cp);\n\t\t\t continue;\n\t\t }\n\n\t\t // 打印标题\n\t\t p_ref_info = (PrintRefInfo *)s_ref_tbl_cfg[EN_REF_TBL_WAVE_TITLE].p_ref_info;\n\t\t p_ref_tbl_item = p_ref_info->p_tbl;\n\t\t if (p_ref_tbl_item && (cp->specific_info.base_index < p_ref_tbl_item->num))\n\t\t {\n\t\t\t p_str = strchr(p_ref_tbl_item->item[cp->specific_info.base_index], ':');\n\t\t\t if (p_str)\n\t\t\t {\n\t\t\t\t *p_str = 0;\n\t\t\t }\n\n\t\t\t printHeaderLineUart(cp, (INT8 *)getLocalLangByAbbr(p_ref_tbl_item->item[cp->specific_info.base_index], cp->dev_cfg.lang_sel));\n\t\t }\n\n\t\t // 计算出打印该次波形所需的各个变量值\n\t\t if (printCalcWaveParameterUart(cp) < 0)\n\t\t {\n\t\t\t return;\n\t\t }\n\n\t\t // 打印波形标度及时间标度\n\t\t if(printWaveScaleUart(cp)<0)\n\t\t {\n\t\t\t return;\n\t\t }\n\n\t\t // 打印跳闸脉冲描述\n\t\t printPulseDescripUart(cp);\n\n\t\t // 打印录波通道描述\n\t\t printAnalogDescripUart(cp);\n\n\t\t // 打印波形头\n\t\t printWaveHeadUart(cp);\n\n\t\t // 打印波形\n\t\t printWaveFormUart(cp);\n\n\t\t printCharLine(cp, WITH_RETURN);\n\t }\n\n\t return;\n }\n\n LOCAL void printNoSpecificWavePageUart(Print *cp)\n {\n\t INT8 middle_start;\n\n\t *cp->print_ptr++ = 0x1c;                               // 倍宽打印 FS SO\n\t *cp->print_ptr++ = 0x0e;\n\n\t middle_start = (strlen(slan_no_specific_wave_page.desc[cp->dev_cfg.lang_sel]))/2; // 标题居中\n\t memset(cp->print_ptr,' ',middle_start);\n\t cp->print_ptr += middle_start;\n\t printAddStrToBuf(cp, slan_no_specific_wave_page.desc[cp->dev_cfg.lang_sel]);\n\n\t *cp->print_ptr++ = 0x1c;                                   // 取消倍宽打印 FS DC4\n\t *cp->print_ptr++ = 0x14;\n\t printCharLine(cp,WITH_RETURN);\n\n\t printStrLine(cp,(INT8*)title_line_tab0[cp->print_method][cp->dev_cfg.lang_sel],WITH_RETURN);\n\n\t return;\n }\n\n LOCAL void printNoSpecificWavePage(Print *cp)\n {\n\t // 如果该页无模拟量，不打印波形\n\t INT8 middle_start = 0;\n\n\t middle_start = (strlen(slan_no_specific_wave_page.desc[cp->dev_cfg.lang_sel])) / 2;\n\t memset(cp->print_ptr, ' ', middle_start);\n\t cp->print_ptr += middle_start;\n\t printAddStrToBuf(cp, slan_no_specific_wave_page.desc[cp->dev_cfg.lang_sel]);\n\n\t printCharLine(cp, WITH_RETURN);\n\t \n\t printStrLine(cp, title_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t \n\t return;\n }\n\n LOCAL INT32 printCalcWaveParameterUart(Print *cp)\n {\n\t INT32 i = 0, j = 0, k = 0;\n\t FLOAT64 local_max_value1 = 0., local_max_value2 = 0., local_max_value = 0.;\n\t DataFields *p_datafield = NULL;\n\t INT32 local_index = 0, local_cnt = 0;\n\t PrintRefInfo *p_ref_info = NULL;\n\t RefParameterItems *p_ref_tbl_item = NULL;\n\n\t cp->specific_info.group_num = 0;\n\t for (i = 0; i < PRINT_EACH_PAGE_ANALOG_MAX_NUM; i++)\n\t {\n\t\t cp->specific_info.group_norm[0][i] = 0;\n\t\t cp->specific_info.group_norm[1][i] = 0;\n\t\t cp->specific_info.group_data_max[i] = 0;\n\t\t memset(cp->specific_info.wave_unit[i], 0, 8);\n\t\t cp->specific_info.group_column_num[i] = 0;\n\t\t cp->specific_info.limen_value[i] = 0;\n\t\t memset(cp->specific_info.wave_format[i].item, 0, NAME_STRING_LEN);\n\t }\n\n\t // 本页所包含打印通道总个数\n\t for (i = 0; i < cp->each_page_analog_num[cp->specific_info.base_index]; i++)\n\t {\n\t\t local_cnt = 0;\n\t\t p_ref_info = (PrintRefInfo *)s_ref_tbl_cfg[EN_REF_TBL_USER_INST_AI].p_ref_info;\n\t\t p_ref_tbl_item = p_ref_info->p_tbl;\n\t\t for (j = 0; j < p_ref_tbl_item->num; j++)\n\t\t {\n\t\t\t p_datafield = p_ref_info->p_item[j].p_datafield;\n\t\t\t if (0 == DESC_WAVE_VISIBLE(p_datafield))\n\t\t\t {\n\t\t\t\t continue;\n\t\t\t }\n\n\t\t\t if (p_ref_info->p_item[j].para[EN_USER_AI_TBL_PARA_PRINT_PAGE] & (1 << cp->specific_info.base_index))\n\t\t\t {\n\t\t\t\t if (local_cnt == cp->p_each_page_analog_offset[cp->specific_info.base_index][i])\n\t\t\t\t {\n\t\t\t\t\t local_index = j;\n\t\t\t\t\t break;\n\t\t\t\t }\n\t\t\t }\n\n\t\t\t local_cnt++;\n\t\t }\n\n\t\t if (j >= p_ref_tbl_item->num)\n\t\t {\n\t\t\t printf(\"[print]: (_func_printCalcWaveParameter) Can't find analog page!\\n\");\n\t\t\t return -1;\n\t\t }\n\n\t\t p_datafield = p_ref_info->p_item[local_index].p_datafield;\n\t\t if (NULL == p_datafield)\n\t\t {\n\t\t\t printf(\"[print]: (_func_printCalcWaveParameter) Datafield is null!\\n\");\n\t\t\t return -1;\n\t\t }\n\n\t\t for (k = 0; k < cp->specific_info.group_num; k++)\n\t\t {\n\t\t\t if( (fabs(p_datafield->u_value.float64.norm[0]-cp->specific_info.group_norm[0][k])<0.00001)\n\t\t\t\t && (fabs(p_datafield->u_value.float64.norm[1]-cp->specific_info.group_norm[1][k])<0.00001)\n\t\t\t\t && (strcmp(p_datafield->unit,cp->specific_info.wave_unit[k])==0) )\n\t\t\t {\n\t\t\t\t cp->specific_info.p_ai_datafield[k][cp->specific_info.group_column_num[k]] = p_datafield;\n\t\t\t\t cp->specific_info.wave_shift[k][cp->specific_info.group_column_num[k]] = cp->p_each_page_analog_offset[cp->specific_info.base_index][i];\n\n\t\t\t\t cp->specific_info.group_data_max_ps[k] = cp->wave_data.p_analog_ps[cp->p_each_page_analog_offset[cp->specific_info.base_index][i]];\n\t\t\t\t // 同组内则需再次判断本小组最大值\n\t\t\t\t local_max_value1 = fabs(cp->wave_data.p_analog_max[cp->p_each_page_analog_offset[cp->specific_info.base_index][i]]\n\t\t\t\t *cp->wave_data.p_analog_coef_a[cp->p_each_page_analog_offset[cp->specific_info.base_index][i]]\n\t\t\t\t +cp->wave_data.p_analog_coef_b[cp->p_each_page_analog_offset[cp->specific_info.base_index][i]]);\n\t\t\t\t local_max_value2 = fabs(cp->wave_data.p_analog_min[cp->p_each_page_analog_offset[cp->specific_info.base_index][i]]\n\t\t\t\t *cp->wave_data.p_analog_coef_a[cp->p_each_page_analog_offset[cp->specific_info.base_index][i]]\n\t\t\t\t +cp->wave_data.p_analog_coef_b[cp->p_each_page_analog_offset[cp->specific_info.base_index][i]]);\n\t\t\t\t if(local_max_value1>local_max_value2) local_max_value = local_max_value1;\n\t\t\t\t else local_max_value = local_max_value2;\n\n\t\t\t\t // 最大值为额定值的百分比\n\t\t\t\t if(local_max_value>cp->specific_info.group_data_max[k])\n\t\t\t\t\t cp->specific_info.group_data_max[k] = local_max_value;\n\n\t\t\t\t cp->specific_info.group_column_num[k]++;\n\t\t\t\t break;\n\t\t\t }\n\t\t }\n\n\t\t // 找到最后一个都没有找到，则是一个新的标度组\n\t\t if(k==cp->specific_info.group_num)\n\t\t {\n\t\t\t cp->specific_info.p_ai_datafield[k][cp->specific_info.group_column_num[k]] = p_datafield;\n\t\t\t cp->specific_info.group_norm[0][k] = p_datafield->u_value.float64.norm[0];\n\t\t\t cp->specific_info.group_norm[1][k] = p_datafield->u_value.float64.norm[1];\n\t\t\t cp->specific_info.group_data_max_ps[k] = cp->wave_data.p_analog_ps[cp->p_each_page_analog_offset[cp->specific_info.base_index][i]];\n\t\t\t strcpy(cp->specific_info.wave_unit[k],p_datafield->unit);\n\t\t\t strcpy(cp->specific_info.wave_format[k].item,strchr(p_datafield->format,'%'));\n\n\t\t\t cp->specific_info.wave_shift[k][cp->specific_info.group_column_num[k]] \n\t\t\t = cp->p_each_page_analog_offset[cp->specific_info.base_index][i];\n\t\t\t cp->specific_info.limen_value[k] \n\t\t\t = *((FLOAT32*)(&p_ref_info->p_item[cp->specific_info.wave_shift[k][cp->specific_info.group_column_num[k]]].para[EN_USER_AI_TBL_PARA_PRINT_THRESHOLD]));\n\n\t\t\t local_max_value1 = fabs(cp->wave_data.p_analog_max[cp->p_each_page_analog_offset[cp->specific_info.base_index][i]]\n\t\t\t *cp->wave_data.p_analog_coef_a[cp->p_each_page_analog_offset[cp->specific_info.base_index][i]]\n\t\t\t +cp->wave_data.p_analog_coef_b[cp->p_each_page_analog_offset[cp->specific_info.base_index][i]]);\n\t\t\t local_max_value2 = fabs(cp->wave_data.p_analog_min[cp->p_each_page_analog_offset[cp->specific_info.base_index][i]]\n\t\t\t *cp->wave_data.p_analog_coef_a[cp->p_each_page_analog_offset[cp->specific_info.base_index][i]]\n\t\t\t +cp->wave_data.p_analog_coef_b[cp->p_each_page_analog_offset[cp->specific_info.base_index][i]]);\n\t\t\t if(local_max_value1>local_max_value2) local_max_value = local_max_value1;\n\t\t\t else local_max_value = local_max_value2;\n\n\t\t\t // 最大值为额定值的百分比\n\t\t\t if(local_max_value>cp->specific_info.group_data_max[k])\n\t\t\t\t cp->specific_info.group_data_max[k] = local_max_value;\n\n\t\t\t cp->specific_info.group_column_num[k] = 1;\n\t\t\t cp->specific_info.group_num++;\n\t\t }\n\t }\n\n\t // 找出本组各个跳闸脉冲在wave_bin_user_refer_table中的偏移（以便于在setTripPulse幅值录波中找出准确时刻）\n\t for(i=0;i<cp->each_page_pulse_num[cp->specific_info.base_index];i++)\n\t {\n\t\t local_cnt = 0;\n\t\t p_ref_info = (PrintRefInfo*)s_ref_tbl_cfg[EN_REF_TBL_USER_BI].p_ref_info;\n\t\t p_ref_tbl_item = p_ref_info->p_tbl;\n\t\t for(k=0;k<p_ref_tbl_item->num;k++)\n\t\t {\n\t\t\t p_datafield = p_ref_info->p_item[k].p_datafield;\n\t\t\t if( DESC_WAVE_VISIBLE(p_datafield) == 0) \n\t\t\t\t continue;\n\t\t\t if(cp->p_each_page_pulse_offset[cp->specific_info.base_index][i]==local_cnt)\n\t\t\t {\n\t\t\t\t cp->specific_info.pulse_index[i] = local_cnt;\n\t\t\t\t local_index = k;\n\t\t\t\t break;\n\t\t\t }\n\t\t\t local_cnt++;\n\t\t }\n\t\t cp->specific_info.p_bi_datafield[i] = p_ref_info->p_item[local_index].p_datafield;\n\t }\n\n\t // 打印波形单元象素点数\n\t cp->specific_info.unit_width = (8 * 180 - 12 * 12)/((cp->each_page_analog_num[cp->specific_info.base_index]*4+cp->each_page_pulse_num[cp->specific_info.base_index]*1+2));\n\t // 图形宽度(象素单位)\n\t cp->specific_info.graph_width = cp->specific_info.unit_width*(cp->each_page_analog_num[cp->specific_info.base_index]*4+cp->each_page_pulse_num[cp->specific_info.base_index]*1+2);\n\t // 跳闸脉冲居中位置\n\t for(i=0;i<cp->each_page_pulse_num[cp->specific_info.base_index];i++)\n\t\t cp->specific_info.position[i] = (i+1)*cp->specific_info.unit_width;\n\t // 波形居中位置\n\t for(i=0;i<cp->each_page_analog_num[cp->specific_info.base_index];i++)\n\t\t cp->specific_info.position[i+cp->each_page_pulse_num[cp->specific_info.base_index]] = (cp->each_page_pulse_num[cp->specific_info.base_index]+4*i+3)*cp->specific_info.unit_width;\n\n\t return 0;\n }\n\n LOCAL INT32 printCalcWaveParameter(Print *cp)\n {\n\t INT32 i = 0, j = 0, k = 0;\n\t FLOAT64 local_max_value1 = 0., local_max_value2 = 0., local_max_value = 0.;\n\t DataFields *p_datafield = NULL;\n\t INT32 local_index = 0, local_cnt = 0;\n\t PrintRefInfo *p_ref_info = NULL;\n\t RefParameterItems *p_ref_tbl_item = NULL;\n\n\t cp->specific_info.group_num = 0;\n\t for (i = 0; i < PRINT_EACH_PAGE_ANALOG_MAX_NUM; i++)\n\t {\n\t\t cp->specific_info.group_norm[0][i] = 0;\n\t\t cp->specific_info.group_norm[1][i] = 0;\n\t\t cp->specific_info.group_data_max[i] = 0;\n\t\t memset(cp->specific_info.wave_unit[i], 0, 8);\n\t\t cp->specific_info.group_column_num[i] = 0;\n\t\t cp->specific_info.limen_value[i] = 0;\n\t\t memset(cp->specific_info.wave_format[i].item, 0, NAME_STRING_LEN);\n\t }\n\n\t // 本页所包含打印通道总个数\n\t for (i = 0; i < cp->each_page_analog_num[cp->specific_info.base_index]; i++)\n\t {\n\t\t local_cnt = 0;\n\t\t p_ref_info = (PrintRefInfo *)s_ref_tbl_cfg[EN_REF_TBL_USER_INST_AI].p_ref_info;\n\t\t p_ref_tbl_item = p_ref_info->p_tbl;\n\t\t for (j = 0; j < p_ref_tbl_item->num; j++)\n\t\t {\n\t\t\t p_datafield = p_ref_info->p_item[j].p_datafield;\n\t\t\t if (0 == DESC_WAVE_VISIBLE(p_datafield))\n\t\t\t {\n\t\t\t\t continue;\n\t\t\t }\n\n\t\t\t if (p_ref_info->p_item[j].para[EN_USER_AI_TBL_PARA_PRINT_PAGE] & (1 << cp->specific_info.base_index))\n\t\t\t {\n\t\t\t\t if (local_cnt == cp->p_each_page_analog_offset[cp->specific_info.base_index][i])\n\t\t\t\t {\n\t\t\t\t\t local_index = j;\n\t\t\t\t\t break;\n\t\t\t\t }\n\t\t\t }\n\n\t\t\t local_cnt++;\n\t\t }\n\n\t\t if (j >= p_ref_tbl_item->num)\n\t\t {\n\t\t\t printf(\"[print]: (_func_printCalcWaveParameter) Can't find analog page!\\n\");\n\t\t\t return -1;\n\t\t }\n\n\t\t p_datafield = p_ref_info->p_item[local_index].p_datafield;\n\t\t if (NULL == p_datafield)\n\t\t {\n\t\t\t printf(\"[print]: (_func_printCalcWaveParameter) Datafield is null!\\n\");\n\t\t\t return -1;\n\t\t }\n\n\t\t for (k = 0; k < cp->specific_info.group_num; k++)\n\t\t {\n\t\t\t if( (fabs(p_datafield->u_value.float64.norm[0]-cp->specific_info.group_norm[0][k])<0.00001)\n\t\t\t\t && (fabs(p_datafield->u_value.float64.norm[1]-cp->specific_info.group_norm[1][k])<0.00001)\n\t\t\t\t && (strcmp(p_datafield->unit,cp->specific_info.wave_unit[k])==0) )\n\t\t\t {\n\t\t\t\t cp->specific_info.p_ai_datafield[k][cp->specific_info.group_column_num[k]] = p_datafield;\n\t\t\t\t cp->specific_info.wave_shift[k][cp->specific_info.group_column_num[k]] = cp->p_each_page_analog_offset[cp->specific_info.base_index][i];\n\n\t\t\t\t cp->specific_info.group_data_max_ps[k] = cp->wave_data.p_analog_ps[cp->p_each_page_analog_offset[cp->specific_info.base_index][i]];\n\t\t\t\t // 同组内则需再次判断本小组最大值\n\t\t\t\t local_max_value1 = fabs(cp->wave_data.p_analog_max[cp->p_each_page_analog_offset[cp->specific_info.base_index][i]]\n\t\t\t\t *cp->wave_data.p_analog_coef_a[cp->p_each_page_analog_offset[cp->specific_info.base_index][i]]\n\t\t\t\t +cp->wave_data.p_analog_coef_b[cp->p_each_page_analog_offset[cp->specific_info.base_index][i]]);\n\t\t\t\t local_max_value2 = fabs(cp->wave_data.p_analog_min[cp->p_each_page_analog_offset[cp->specific_info.base_index][i]]\n\t\t\t\t *cp->wave_data.p_analog_coef_a[cp->p_each_page_analog_offset[cp->specific_info.base_index][i]]\n\t\t\t\t +cp->wave_data.p_analog_coef_b[cp->p_each_page_analog_offset[cp->specific_info.base_index][i]]);\n\t\t\t\t if(local_max_value1>local_max_value2) local_max_value = local_max_value1;\n\t\t\t\t else local_max_value = local_max_value2;\n\n\t\t\t\t // 最大值为额定值的百分比\n\t\t\t\t if(local_max_value>cp->specific_info.group_data_max[k])\n\t\t\t\t\t cp->specific_info.group_data_max[k] = local_max_value;\n\n\t\t\t\t cp->specific_info.group_column_num[k]++;\n\t\t\t\t break;\n\t\t\t }\n\t\t }\n\n\t\t // 找到最后一个都没有找到，则是一个新的标度组\n\t\t if(k==cp->specific_info.group_num)\n\t\t {\n\t\t\t cp->specific_info.p_ai_datafield[k][cp->specific_info.group_column_num[k]] = p_datafield;\n\t\t\t cp->specific_info.group_norm[0][k] = p_datafield->u_value.float64.norm[0];\n\t\t\t cp->specific_info.group_norm[1][k] = p_datafield->u_value.float64.norm[1];\n\t\t\t cp->specific_info.group_data_max_ps[k] = cp->wave_data.p_analog_ps[cp->p_each_page_analog_offset[cp->specific_info.base_index][i]];\n\t\t\t strcpy(cp->specific_info.wave_unit[k],p_datafield->unit);\n\t\t\t strcpy(cp->specific_info.wave_format[k].item,strchr(p_datafield->format,'%'));\n\n\t\t\t cp->specific_info.wave_shift[k][cp->specific_info.group_column_num[k]] \n\t\t\t = cp->p_each_page_analog_offset[cp->specific_info.base_index][i];\n\t\t\t cp->specific_info.limen_value[k] \n\t\t\t = *((FLOAT32*)(&p_ref_info->p_item[cp->specific_info.wave_shift[k][cp->specific_info.group_column_num[k]]].para[EN_USER_AI_TBL_PARA_PRINT_THRESHOLD]));\n\n\t\t\t local_max_value1 = fabs(cp->wave_data.p_analog_max[cp->p_each_page_analog_offset[cp->specific_info.base_index][i]]\n\t\t\t *cp->wave_data.p_analog_coef_a[cp->p_each_page_analog_offset[cp->specific_info.base_index][i]]\n\t\t\t +cp->wave_data.p_analog_coef_b[cp->p_each_page_analog_offset[cp->specific_info.base_index][i]]);\n\t\t\t local_max_value2 = fabs(cp->wave_data.p_analog_min[cp->p_each_page_analog_offset[cp->specific_info.base_index][i]]\n\t\t\t *cp->wave_data.p_analog_coef_a[cp->p_each_page_analog_offset[cp->specific_info.base_index][i]]\n\t\t\t +cp->wave_data.p_analog_coef_b[cp->p_each_page_analog_offset[cp->specific_info.base_index][i]]);\n\t\t\t if(local_max_value1>local_max_value2) local_max_value = local_max_value1;\n\t\t\t else local_max_value = local_max_value2;\n\n\t\t\t // 最大值为额定值的百分比\n\t\t\t if(local_max_value>cp->specific_info.group_data_max[k])\n\t\t\t\t cp->specific_info.group_data_max[k] = local_max_value;\n\n\t\t\t cp->specific_info.group_column_num[k] = 1;\n\t\t\t cp->specific_info.group_num++;\n\t\t }\n\t }\n\n\t // 找出本组各个跳闸脉冲在wave_bin_user_refer_table中的偏移（以便于在setTripPulse幅值录波中找出准确时刻）\n\t for(i=0;i<cp->each_page_pulse_num[cp->specific_info.base_index];i++)\n\t {\n\t\t local_cnt = 0;\n\t\t p_ref_info = (PrintRefInfo*)s_ref_tbl_cfg[EN_REF_TBL_USER_BI].p_ref_info;\n\t\t p_ref_tbl_item = p_ref_info->p_tbl;\n\t\t for(k=0;k<p_ref_tbl_item->num;k++)\n\t\t {\n\t\t\t p_datafield = p_ref_info->p_item[k].p_datafield;\n\t\t\t if( DESC_WAVE_VISIBLE(p_datafield) == 0) \n\t\t\t\t continue;\n\t\t\t if(cp->p_each_page_pulse_offset[cp->specific_info.base_index][i]==local_cnt)\n\t\t\t {\n\t\t\t\t cp->specific_info.pulse_index[i] = local_cnt;\n\t\t\t\t local_index = k;\n\t\t\t\t break;\n\t\t\t }\n\t\t\t local_cnt++;\n\t\t }\n\t\t cp->specific_info.p_bi_datafield[i] = p_ref_info->p_item[local_index].p_datafield;\n\t }\n\n\t // 打印波形单元象素点数\n\t cp->specific_info.unit_width = (INT16)(((PRINT_RESOLUTION) * (PRINT_PAPER_LEN - 10))/(PRINT_MEASURE * (cp->each_page_analog_num[cp->specific_info.base_index]*4.+cp->each_page_pulse_num[cp->specific_info.base_index]*1.+2.)));\n\t // 图形宽度(象素单位)\n\t cp->specific_info.graph_width = cp->specific_info.unit_width*(cp->each_page_analog_num[cp->specific_info.base_index]*4+cp->each_page_pulse_num[cp->specific_info.base_index]*1+2);\n\t // 跳闸脉冲居中位置\n\t for(i=0;i<cp->each_page_pulse_num[cp->specific_info.base_index];i++)\n\t\t cp->specific_info.position[i] = (i+1)*cp->specific_info.unit_width;\n\t // 波形居中位置\n\t for(i=0;i<cp->each_page_analog_num[cp->specific_info.base_index];i++)\n\t\t cp->specific_info.position[i+cp->each_page_pulse_num[cp->specific_info.base_index]] = (cp->each_page_pulse_num[cp->specific_info.base_index]+4*i+3)*cp->specific_info.unit_width;\n\n\t return 0;\n }\n\n LOCAL INT32 printWaveScaleUart(Print *cp)\n {\n\t UINT16 i = 0,j = 0,value = 0;\n\t FLOAT64 max_value = 0.,local_double_value = 0.,local_limen_value = 0.;\n\t INT8 local_buffer[32] = { 0 };\n\n\t printStrLine(cp,(INT8*)wave_scale_line_tab0[cp->print_method][cp->dev_cfg.lang_sel],WITH_RETURN);\n\n\t for(j=0;j<cp->specific_info.group_num;j++)\n\t {\n\t\t // 注意：此时的max_value是从comtrade文件读出的AX+B值，已经是有名值\n\t\t max_value = cp->specific_info.group_data_max[j]; \n\n\t\t //        printf(\"--index=%d,max_org=%lf,\",j,max_value);\n\n\t\t // 最大值由额定值的百分比转化为有名值 (最大值为每2格对应的最大值)\n\t\t //        max_value = max_value*cp->specific_info.group_norm[cp->specific_info.group_data_max_ps[j]][j];\n\t\t // 打印门槛(精工值)为标幺值，转换为有名值（至于是一次还是二次 由COMTRADE文件的CFG文件的P/S部分决定）\n\t\t local_limen_value = cp->specific_info.limen_value[j]*cp->specific_info.group_norm[cp->specific_info.group_data_max_ps[j]][j];\n\n\t\t //        printf(\"max_ps=%d,norm=%f,max_now=%f\\n\"\n\t\t //        ,cp->specific_info.group_data_max_ps[j]\n\t\t //        ,cp->specific_info.group_norm[cp->specific_info.group_data_max_ps[j]][j]\n\t\t //        ,max_value);\n\n\t\t if(max_value<local_limen_value)\n\t\t\t max_value = local_limen_value;\n\n\t\t cp->specific_info.max_value[j] = max_value;\n\n\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t\t cp->print_ptr+=2;\n\n\t\t printAddStrToBuf(cp, slan_wave_analog_group_scale_str.desc[cp->dev_cfg.lang_sel]);\n\t\t sprintf(cp->print_ptr,\"%02d\",j);\n\t\t cp->print_ptr += 2;\n\t\t *cp->print_ptr++ = '(';\n\n\t\t printAddStrToBuf(cp, slan_wave_analog_channel_str.desc[cp->dev_cfg.lang_sel]);\n\t\t value = 1;\n\t\t for(i=0;i<j;i++)\n\t\t\t value += cp->specific_info.group_column_num[i];\n\t\t sprintf(cp->print_ptr,\"%02d\",value);\n\t\t cp->print_ptr += 2;\n\n\t\t printAddStrToBuf(cp,\"-\");\n\t\t value = 0;\n\t\t for(i=0;i<(j+1);i++)\n\t\t\t value += cp->specific_info.group_column_num[i];\n\t\t sprintf(cp->print_ptr,\"%02d\",value);\n\t\t cp->print_ptr += 2;\n\t\t *cp->print_ptr++ = ')';\n\t\t *cp->print_ptr++ = ':';\n\t\t cp->print_ptr += 15;\n\n\t\t if( (cp->specific_info.p_ai_datafield[j][0]->type==INT8_TYPE)\n\t\t\t || (cp->specific_info.p_ai_datafield[j][0]->type==INT16_TYPE)\n\t\t\t || (cp->specific_info.p_ai_datafield[j][0]->type==INT32_TYPE) )\n\t\t\t sprintf(local_buffer,cp->specific_info.wave_format[j].item,((INT32)cp->specific_info.max_value[j])/2);\n\t\t else if( (cp->specific_info.p_ai_datafield[j][0]->type==UINT8_TYPE)\n\t\t\t || (cp->specific_info.p_ai_datafield[j][0]->type==UINT16_TYPE)\n\t\t\t || (cp->specific_info.p_ai_datafield[j][0]->type==UINT32_TYPE) )\n\t\t\t sprintf(local_buffer,cp->specific_info.wave_format[j].item,((UINT32)cp->specific_info.max_value[j])/2);\n\t\t else\n\t\t\t sprintf(local_buffer,cp->specific_info.wave_format[j].item,cp->specific_info.max_value[j]/2);\n\t\t printAddStrToBufAndModifyPtr(cp,local_buffer,8);\n\n\t\t // 量纲\n\t\t printAddStrToBuf(cp,(INT8*)cp->specific_info.wave_unit[j]);\n\t\t //增加打印波形时，标度组00（通道01-03）： 1.504 A后的单位“/格”\n\t\t printAddStrToBuf(cp, slan_wave_per_unit_descrip.desc[cp->dev_cfg.lang_sel]);\n\t\t cp->print_ptr += strlen(wave_scale_line_tab1[cp->print_method][cp->dev_cfg.lang_sel])-(cp->print_ptr-cp->print_buf)-strlen(print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t printAddStrToBuf(cp,(INT8*)print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t printCharLine(cp,WITH_RETURN);\n\n\t\t *cp->print_ptr++ = 0x1b;           //打印机命令:ESC + n--设置n/360英寸的换行量\n\t\t *cp->print_ptr++ = '+';\n\t\t *cp->print_ptr++ = 10;\n\t\t printCharLine(cp,WITHOUT_RETURN);\n\n\t\t printAddStrToBuf(cp,(INT8*)print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t cp->print_ptr += strlen(wave_scale_line_tab1[cp->print_method][cp->dev_cfg.lang_sel])-4;\n\t\t printAddStrToBuf(cp,(INT8*)print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t printCharLine(cp,WITH_RETURN);\n\n\t\t *cp->print_ptr++ = 0x1b;           //打印机命令:ESC + n--设置n/360英寸的换行量\n\t\t *cp->print_ptr++ = '+';\n\t\t *cp->print_ptr++ = 48;\n\t\t printCharLine(cp,WITHOUT_RETURN);\n\t }\n\n\t printAddStrToBuf(cp,(INT8*)print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t cp->print_ptr += 2;\n\t printAddStrToBuf(cp,(INT8*)slan_wave_time_scale_str.desc[cp->dev_cfg.lang_sel]);\n\t printAddStrToBuf(cp,\":\");\n\t cp->print_ptr += 16;\n\t local_double_value = 1000.0/cp->dev_cfg.system_freq;   // 1000为ms\n\t sprintf(local_buffer,\"%6.2f\",local_double_value);\n\t printAddStrToBufAndModifyPtr(cp,(INT8*)local_buffer,7);\n\t *cp->print_ptr++ = 'm';\n\t *cp->print_ptr++ = 's';\n\t printAddStrToBuf(cp, slan_wave_per_unit_descrip.desc[cp->dev_cfg.lang_sel]);\n\n\t cp->print_ptr += strlen(wave_scale_line_tab1[cp->print_method][cp->dev_cfg.lang_sel])-(cp->print_ptr-cp->print_buf)-strlen(print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t printAddStrToBuf(cp,(INT8*)print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t printCharLine(cp,WITH_RETURN);\n\n\t printStrLine(cp, wave_scale_line_tab1[cp->print_method][cp->dev_cfg.lang_sel],WITH_RETURN);\n\n\t return 0;\n }\n\n LOCAL INT32 printWaveScale(Print *cp)\n {\n\t UINT16 i = 0, j = 0, value = 0;\n\t FLOAT64 max_value = 0., local_double_value = 0., local_limen_value = 0.;\n\t INT8 local_buffer[32] = { 0 };\n\n\t printStrLine(cp, wave_scale_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t for (j = 0; j < cp->specific_info.group_num; j++)\n\t {\n\t\t max_value = cp->specific_info.group_data_max[j];\n\n\t\t if (max_value < local_limen_value)\n\t\t {\n\t\t\t max_value = local_limen_value;\n\t\t }\n\n\t\t cp->specific_info.max_value[j] = max_value;\n\n\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t cp->print_ptr += 2;\n\n\t\t printAddStrToBuf(cp, slan_wave_analog_group_scale_str.desc[cp->dev_cfg.lang_sel]);\n\t\t sprintf(cp->print_ptr, \"%02d\", j);\n\t\t cp->print_ptr += 2;\n\t\t *cp->print_ptr++ = '(';\n\n\t\t printAddStrToBuf(cp, slan_wave_analog_channel_str.desc[cp->dev_cfg.lang_sel]);\n\t\t value = 1;\n\t\t for (i = 0; i < j; i++)\n\t\t {\n\t\t\t value += cp->specific_info.group_column_num[i];\n\t\t }\n\t\t sprintf(cp->print_ptr, \"%02d\", value);\n\t\t cp->print_ptr += 2;\n\n\t\t printAddStrToBuf(cp, \"-\");\n\t\t value = 0;\n\t\t for (i = 0; i < j + 1; i++)\n\t\t {\n\t\t\t value += cp->specific_info.group_column_num[i];\n\t\t }\n\t\t sprintf(cp->print_ptr, \"%02d\", value);\n\t\t cp->print_ptr += 2;\n\t\t *cp->print_ptr++ = ')';\n\t\t *cp->print_ptr++ = ':';\n\t\t cp->print_ptr += 15;\n\n\t\t if ((INT8_TYPE == cp->specific_info.p_ai_datafield[j][0]->type) ||\n\t\t\t (INT16_TYPE == cp->specific_info.p_ai_datafield[j][0]->type) ||\n\t\t\t (INT32_TYPE == cp->specific_info.p_ai_datafield[j][0]->type))\n\t\t {\n\t\t\t sprintf(local_buffer, cp->specific_info.wave_format[j].item, ((INT32)cp->specific_info.max_value[j]) >> 1);\n\t\t }\n\t\t else if ((UINT8_TYPE == cp->specific_info.p_ai_datafield[j][0]->type) ||\n\t\t\t\t(UINT16_TYPE == cp->specific_info.p_ai_datafield[j][0]->type) ||\n\t\t\t\t(UINT32_TYPE == cp->specific_info.p_ai_datafield[j][0]->type))\n\t\t {\n\t\t\t sprintf(local_buffer, cp->specific_info.wave_format[j].item, ((UINT32)cp->specific_info.max_value[j]) >> 1);\n\t\t }\n\t\t else\n\t\t {\n\t\t\t sprintf(local_buffer, cp->specific_info.wave_format[j].item, cp->specific_info.max_value[j] / 2);\n\t\t }\n\t\t printAddStrToBufAndModifyPtr(cp, local_buffer, 8);\n\n\t\t // 量纲\n\t\t printAddStrToBuf(cp, cp->specific_info.wave_unit[j]);\n\t\t cp->print_ptr += strlen(wave_scale_line_tab1[cp->print_method][cp->dev_cfg.lang_sel])\n\t\t\t\t\t\t\t- (cp->print_ptr - cp->print_buf)\n\t\t\t\t\t\t\t- strlen(print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t printCharLine(cp, WITH_RETURN);\n\n\t\t //// 设定行间距\n\t\t //*cp->print_ptr++ = ESC;\n\t\t //*cp->print_ptr++ = '&';\n\t\t //*cp->print_ptr++ = 'l';\n\t\t //*cp->print_ptr++ = '4';\n\t\t //*cp->print_ptr++ = '8';\n\t\t //*cp->print_ptr++ = 'D';\n\t\t //printCharLine(cp, WITHOUT_RETURN);\n\n\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t cp->print_ptr += strlen(wave_scale_line_tab1[cp->print_method][cp->dev_cfg.lang_sel]) - 4;\n\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t printCharLine(cp, WITH_RETURN);\n\t\t \n\t\t //// 恢复行间距\n\t\t //*cp->print_ptr++ = ESC;\n\t\t //*cp->print_ptr++ = '&';\n\t\t //*cp->print_ptr++ = 'l';\n\t\t //*cp->print_ptr++ = '1';\n\t\t //*cp->print_ptr++ = '6';\n\t\t //*cp->print_ptr++ = 'D';\n\t\t //printCharLine(cp, WITHOUT_RETURN);\n\t }\n\n\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t cp->print_ptr += 2;\n\t printAddStrToBuf(cp, slan_wave_time_scale_str.desc[cp->dev_cfg.lang_sel]);\n\t printAddStrToBuf(cp, \":\");\n\t cp->print_ptr += 14;\n\t local_double_value = 1000. / cp->dev_cfg.system_freq;\n\t sprintf(local_buffer, \"%6.2f\", local_double_value);\n\t printAddStrToBufAndModifyPtr(cp, local_buffer, 7);\n\t *cp->print_ptr++ = 'm';\n\t *cp->print_ptr++ = 's';\n\t printAddStrToBuf(cp, slan_wave_per_unit_descrip.desc[cp->dev_cfg.lang_sel]);\n\n\t cp->print_ptr += strlen(wave_scale_line_tab1[cp->print_method][cp->dev_cfg.lang_sel])\n\t\t\t\t\t\t- (cp->print_ptr - cp->print_buf) \n\t\t\t\t\t\t- strlen(print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t printCharLine(cp, WITH_RETURN);\n\n\t printStrLine(cp, wave_scale_line_tab1[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t return 0;\n }\n\n LOCAL void printPulseDescripUart(Print *cp)\n {\n\t INT32 i = 0,k = 0;\n\t DataFields *p_datafield=NULL;\n\t INT8 local_buf[128] = { 0 };\n\n\t printStrLine(cp, pulse_desc_line_tab0[cp->print_method][cp->dev_cfg.lang_sel],WITH_RETURN);\n\n\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t cp->print_ptr += 2;\n\t strcpy(local_buf, slan_trip_pulse_desc_str.desc[cp->dev_cfg.lang_sel]);\n\t strcat(local_buf,\":\");\n\t printAddStrToBufAndModifyPtr(cp,local_buf,108);\n\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t printCharLine(cp,WITH_RETURN);\n\n\t // 只打印本组波形包含的脉冲描述\n\t for(i=0;i<cp->each_page_pulse_num[cp->specific_info.base_index];i++)\n\t {\n\t\t p_datafield = cp->specific_info.p_bi_datafield[i];\n\t\t if(p_datafield==NULL) continue;\n\n\t\t if(i%3==0)\n\t\t {\n\t\t\t *cp->print_ptr++ = 0x1b;           //打印机命令:ESC + n--设置n/360英寸的换行量\n\t\t\t *cp->print_ptr++ = '+';\n\t\t\t *cp->print_ptr++ = 10;\n\t\t\t printCharLine(cp,WITHOUT_RETURN);\n\n\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t cp->print_ptr += strlen(pulse_desc_line_tab0[cp->print_method][cp->dev_cfg.lang_sel])-4;\n\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t printCharLine(cp,WITH_RETURN);\n\n\t\t\t *cp->print_ptr++ = 0x1b;           //打印机命令:ESC + n--设置n/360英寸的换行量\n\t\t\t *cp->print_ptr++ = '+';\n\t\t\t *cp->print_ptr++ = 48;\n\t\t\t printCharLine(cp,WITHOUT_RETURN);\n\n\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t }\n\n\t\t cp->print_ptr += 2;\n\t\t if(i<9) k = i+1+'0';\n\t\t else k = i+1+'7';\n\t\t *cp->print_ptr++ = k;\n\t\t *cp->print_ptr++ = ':';\n\n\t\t // 描述\n\t\t printAddStrToBufAndModifyPtr(cp,p_datafield->desc,32);\n\n\t\t if((i+1)%3==0)\n\t\t {\n\t\t\t cp->print_ptr += 2;\n\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t printCharLine(cp,WITH_RETURN);\n\t\t }\n\t\t else\n\t\t {\n\t\t\t if(i==(cp->each_page_pulse_num[cp->specific_info.base_index]-1))\n\t\t\t {\n\t\t\t\t if(i%3==0) cp->print_ptr += 74;\n\t\t\t\t else cp->print_ptr += 38;\n\n\t\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t\t printCharLine(cp,WITH_RETURN);\n\t\t\t }\n\t\t }\n\t }\n\n\t printStrLine(cp, pulse_desc_line_tab1[cp->print_method][cp->dev_cfg.lang_sel],WITH_RETURN);\n\n\t return;\n }\n\n LOCAL void printPulseDescrip(Print *cp)\n {\n\t INT32 i = 0, k = 0;\n\t DataFields *p_datafield = NULL;\n\t INT8 local_buf[128] = { 0 };\n\n\t printStrLine(cp, pulse_desc_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t cp->print_ptr += 2;\n\t strcpy(local_buf, slan_trip_pulse_desc_str.desc[cp->dev_cfg.lang_sel]);\n\t strcat(local_buf, \":\");\n\t printAddStrToBufAndModifyPtr(cp, local_buf, 108);\n\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t printCharLine(cp, WITH_RETURN);\n\n\t // 只打印本组波形包含的脉冲描述\n\t for (i = 0; i < cp->each_page_pulse_num[cp->specific_info.base_index]; i++)\n\t {\n\t\t p_datafield = cp->specific_info.p_bi_datafield[i];\n\t\t if (NULL == p_datafield)\n\t\t {\n\t\t\t continue;\n\t\t }\n\n\t\t if (0 == i % 3)\n\t\t { \n\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t cp->print_ptr += strlen(pulse_desc_line_tab0[cp->print_method][cp->dev_cfg.lang_sel]) - 4;\n\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t printCharLine(cp, WITH_RETURN);\n\n\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t }\n\n\t\t cp->print_ptr += 2;\n\t\t if (i < 9)\n\t\t {\n\t\t\t k = i + 1 + '0';\n\t\t }\n\t\t else\n\t\t {\n\t\t\t k = i + 1 + '7';\n\t\t }\n\t\t *cp->print_ptr++ = k;\n\t\t *cp->print_ptr++ = ':';\n\n\t\t // 描述\n\t\t printAddStrToBufAndModifyPtr(cp, p_datafield->desc, 32);\n\n\t\t if (0 == (i + 1) % 3)\n\t\t {\n\t\t\t cp->print_ptr += 2;\n\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t printCharLine(cp, WITH_RETURN);\n\t\t }\n\t\t else\n\t\t {\n\t\t\t if (i == cp->each_page_pulse_num[cp->specific_info.base_index] - 1)\n\t\t\t {\n\t\t\t\t if (0 == i % 3)\n\t\t\t\t {\n\t\t\t\t\t cp->print_ptr += 74;\n\t\t\t\t }\n\t\t\t\t else\n\t\t\t\t {\n\t\t\t\t\t cp->print_ptr += 38;\n\t\t\t\t }\n\n\t\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t\t printCharLine(cp, WITH_RETURN);\n\t\t\t }\n\t\t }\n\t }\n\n\t printStrLine(cp, pulse_desc_line_tab1[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t return;\n }\n\n LOCAL void printAnalogDescripUart(Print *cp)\n {\n\t INT32 j = 0,k = 0,local_analog_num=0,local_index=0;\n\t DataFields *p_datafield=NULL;\n\t INT8 local_buf[128] = { 0 };\n\n\t printStrLine(cp, analog_desc_line_tab0[cp->print_method][cp->dev_cfg.lang_sel],WITH_RETURN);\n\n\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t cp->print_ptr += 2;\n\t strcpy(local_buf, slan_wave_analog_discrip.desc[cp->dev_cfg.lang_sel]);\n\t strcat(local_buf,\":\");\n\t printAddStrToBufAndModifyPtr(cp,local_buf,108);\n\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t printCharLine(cp,WITH_RETURN);\n\n\t for(j=0; j<cp->specific_info.group_num; j++)\n\t\t local_analog_num += cp->specific_info.group_column_num[j];\n\n\t local_index = 0;\n\t for(j=0; j<cp->specific_info.group_num; j++)\n\t {\n\t\t for(k=0; k<cp->specific_info.group_column_num[j]; k++)\n\t\t {\n\t\t\t p_datafield = cp->specific_info.p_ai_datafield[j][k];\n\t\t\t if(p_datafield==NULL) continue;\n\n\t\t\t if(local_index%2==0)\n\t\t\t {\n\t\t\t\t *cp->print_ptr++ = 0x1b;           //打印机命令:ESC + n--设置n/360英寸的换行量\n\t\t\t\t *cp->print_ptr++ = '+';\n\t\t\t\t *cp->print_ptr++ = 10;\n\t\t\t\t printCharLine(cp,WITHOUT_RETURN);\n\n\t\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t\t cp->print_ptr += strlen(analog_desc_line_tab0[cp->print_method][cp->dev_cfg.lang_sel])-4;\n\t\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t\t printCharLine(cp,WITH_RETURN);\n\n\t\t\t\t *cp->print_ptr++ = 0x1b;           //打印机命令:ESC + n--设置n/360英寸的换行量\n\t\t\t\t *cp->print_ptr++ = '+';\n\t\t\t\t *cp->print_ptr++ = 48;\n\t\t\t\t printCharLine(cp,WITHOUT_RETURN);\n\n\t\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t }\n\n\t\t\t cp->print_ptr += 2;\n\t\t\t // 序号、描述\n\t\t\t sprintf(local_buf,\"A%d:\",local_index+1);\n\t\t\t strcat(local_buf,p_datafield->desc);\n\t\t\t printAddStrToBufAndModifyPtr(cp,local_buf,53);\n\n\t\t\t if( (local_index+1)%2 == 0 )\n\t\t\t {\n\t\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t\t printCharLine(cp,WITH_RETURN);\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t if( local_index == (local_analog_num-1) )\n\t\t\t\t {\n\t\t\t\t\t cp->print_ptr += 55;\n\t\t\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t\t\t printCharLine(cp,WITH_RETURN);\n\t\t\t\t }\n\t\t\t }\n\t\t\t local_index++;\n\t\t }\n\t }\n\n\t printStrLine(cp, analog_desc_line_tab1[cp->print_method][cp->dev_cfg.lang_sel],WITH_RETURN);\n\n\t return;\n }\n\n LOCAL void printAnalogDescrip(Print *cp)\n {\n\t INT32 j = 0, k = 0, local_analog_num = 0, local_index = 0;\n\t DataFields *p_datafield = NULL;\n\t INT8 local_buf[128] = { 0 };\n\n\t printStrLine(cp, analog_desc_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t cp->print_ptr += 2;\n\t strcpy(local_buf, slan_wave_analog_discrip.desc[cp->dev_cfg.lang_sel]);\n\t strcat(local_buf, \":\");\n\t printAddStrToBufAndModifyPtr(cp, local_buf, 108);\n\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t printCharLine(cp, WITH_RETURN);\n\n\t for (j = 0; j < cp->specific_info.group_num; j++)\n\t {\n\t\t local_analog_num += cp->specific_info.group_column_num[j];\n\t }\n\n\t local_index = 0;\n\t for (j = 0; j < cp->specific_info.group_num; j++)\n\t {\n\t\t for (k = 0; k < cp->specific_info.group_column_num[j]; k++)\n\t\t {\n\t\t\t p_datafield = cp->specific_info.p_ai_datafield[j][k];\n\t\t\t if (NULL == p_datafield)\n\t\t\t {\n\t\t\t\t continue;\n\t\t\t }\n\n\t\t\t if (0 == local_index % 2)\n\t\t\t { \n\t\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t\t cp->print_ptr += strlen(analog_desc_line_tab0[cp->print_method][cp->dev_cfg.lang_sel]) - 4;\n\t\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t\t printCharLine(cp, WITH_RETURN);\n\t\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t }\n\n\t\t\t cp->print_ptr += 2;\n\n\t\t\t // 序号、描述\n\t\t\t sprintf(local_buf, \"A%d:\", local_index + 1);\n\t\t\t strcat(local_buf, p_datafield->desc);\n\t\t\t printAddStrToBufAndModifyPtr(cp, local_buf, 53);\n\n\t\t\t if (0 == (local_index + 1) % 2)\n\t\t\t {\n\t\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t\t printCharLine(cp, WITH_RETURN);\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t if (local_index == (local_analog_num - 1))\n\t\t\t\t {\n\t\t\t\t\t cp->print_ptr += 55;\n\t\t\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t\t\t printCharLine(cp, WITH_RETURN);\n\t\t\t\t }\n\t\t\t }\n\n\t\t\t local_index++;\n\t\t }\n\t }\n\n\t printStrLine(cp, analog_desc_line_tab1[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t return;\n }\n\n LOCAL void printRetTimeDescrip(Print *cp)\n {\n\t INT32 i = 0, j = 0, k = 0, local_analog_num = 0, local_index = 0, len = 0;\n\t DataFields *p_datafield = NULL;\n\t INT8 local_buf[128] = { 0 };\n\t FaultReadCtrl read_ctrl = { 0 };\n\t LOCAL INT8 s_index = 0;\n\t INT32 fan_dot_num = 0, print_line_num = 0;\n\n\t printStrLine(cp, analog_desc_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t cp->print_ptr += 2;\n\t strcpy(local_buf, slan_wave_analog_discrip.desc[cp->dev_cfg.lang_sel]);\n\t strcat(local_buf, \":\");\n\t printAddStrToBufAndModifyPtr(cp, local_buf, 108);\n\t printStrLine(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t \n\n\t for (i = 0; i < cp->wave_data.fault_head.fan_num; i++)\n\t {\n\t\t // 本个FAN录波点数\n\t\t if (i > 0)\n\t\t {\n\t\t\t fan_dot_num = cp->wave_data.rate_dot_num[i - 1];\n\n\t\t\t for (j = 0; j < fan_dot_num; j++)\n\t\t\t {\n\t\t\t\t cp->specific_info.wave_stamp += 1000 / cp->wave_data.rec_freq[i - 1];\n\t\t\t }\n\t\t }\n\t\t \n\t\t \n\t\t if(cp->wave_data.rec_freq[i] >= cp->task_freq)\n\t\t {\n\t\t\t printAddStrToBufAndModifyPtr(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel], 112);\n\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t printCharLine(cp, WITH_RETURN);\n\t\t\t \n\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t cp->print_ptr += 2;\n\n\t\t\t s_index += 1;\n\t\t\t sprintf(local_buf, \"t%d\", s_index);\n\t\t\t printAddStrToBuf(cp, local_buf);\n\t\t\t *cp->print_ptr++ = ':';\n\n\t\t\t if (0 == i)\n\t\t\t {\n\t\t\t\t read_ctrl.field = FAULT_DF_WAVE_BKL;\n\t\t\t\t read_ctrl.off = 0;\n\t\t\t\t read_ctrl.num = 1;\n\t\t\t\t getHisFaultData(&cp->wave_data.fault_head, &read_ctrl, (void *)&cp->wave_data.smpl_blk_head);\n\t\t\t\t cp->specific_info.wave_stamp = (cp->wave_data.smpl_blk_head.start_t.sec -\n\t\t\t\t\t cp->wave_data.smpl_blk_head.trig_t.sec) * 1000. +\n\t\t\t\t\t (cp->wave_data.smpl_blk_head.start_t.us -\n\t\t\t\t\t cp->wave_data.smpl_blk_head.trig_t.us) / 1000.;\n\t\t\t\t\n\t\t\t\t cp->print_ptr += 2;\n\t\t\t\t len = sprintf(cp->print_ptr, \"%09.2f\", cp->specific_info.wave_stamp);\n\t\t\t\t cp->print_ptr += len;\n\t\t\t\t cp->print_ptr += 1;\n\t\t\t\t *cp->print_ptr++ = 'm';\n\t\t\t\t *cp->print_ptr++ = 's';\n\n\t\t\t\t cp->print_ptr += 92;\n\t\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t cp->print_ptr += 2;\n\t\t\t\t len = sprintf(cp->print_ptr, \"%09.2f\", cp->specific_info.wave_stamp - \n\t\t\t\t\t\t\t1000. / cp->wave_data.rec_freq[i]);\n\t\t\t\t cp->print_ptr += len;\n\t\t\t\t cp->print_ptr += 1;\n\t\t\t\t *cp->print_ptr++ = 'm';\n\t\t\t\t *cp->print_ptr++ = 's';\n\n\t\t\t\t cp->print_ptr += 92;\n\t\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t }\n\n\t\t\t printCharLine(cp, WITH_RETURN);\n\t\t }\n\t }\n\n\n\t printStrLine(cp, analog_desc_line_tab1[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t return;\n }\n\n LOCAL void printWaveHeadUart(Print *cp)\n {\n\t INT32 i =0,j=0,k=0,analog_offset=0;\n\t INT8 *local_ptr = NULL,local_buffer[128] = { 0 },*p_local_buf = NULL,*p_str=NULL;\n\t DataFields *p_datafield = NULL;\n\t INT32 local_index=0,local_cnt = 0, analog_index = 0;\n\t FaultReadCtrl read_ctrl = { 0 };\n\t PrintRefInfo *p_ref_info = NULL;\n\t RefParameterItems *p_ref_tbl_item= NULL;\n\n\t *cp->print_ptr++ = 0x1c;                   // 打印机命令:FS .--解除汉字方式\n\t *cp->print_ptr++ = '.';\n\n\t *cp->print_ptr++ = 0x0f;                   // 打印机命令:SI--设定压缩打印\n\n\t *cp->print_ptr++ = 0x1b;                   // 打印机命令:ESC E--设定粗体打印\n\t *cp->print_ptr++ = 'E';\n\t printCharLine(cp,WITHOUT_RETURN);\n\n\t for(i=0; i<cp->each_page_pulse_num[cp->specific_info.base_index]; i++)\n\t {\n\t\t *cp->print_ptr++ = 0x1b;\n\t\t *cp->print_ptr++ = '$';\n\t\t *cp->print_ptr++ = (((UINT16)cp->specific_info.unit_width*(i+1))/3)%256;\n\t\t *cp->print_ptr++ = (((UINT16)cp->specific_info.unit_width*(i+1))/3)/256;\n\t\t printCharLine(cp,WITHOUT_RETURN);\n\n\t\t if(i<9) *cp->print_ptr++ = (i+1)+'0';\n\t\t else *cp->print_ptr++ = (i+1)+'7';\n\n\t\t printCharLine(cp,WITHOUT_RETURN);\n\t }\n\n\t for(i=0; i<cp->specific_info.group_num; i++)\n\t {\n\t\t for(j=0; j<cp->specific_info.group_column_num[i]; j++)\n\t\t {\n\t\t\t local_cnt = 0;\n\t\t\t p_ref_info = (PrintRefInfo*)s_ref_tbl_cfg[EN_REF_TBL_USER_INST_AI].p_ref_info;\n\t\t\t p_ref_tbl_item = p_ref_info->p_tbl;\n\t\t\t for(k=0; k<p_ref_tbl_item->num; k++)\n\t\t\t {\n\t\t\t\t p_datafield = p_ref_info->p_item[k].p_datafield;\n\t\t\t\t if( DESC_WAVE_VISIBLE(p_datafield) == 0)\n\t\t\t\t\t continue;\n\n\t\t\t\t if(cp->specific_info.wave_shift[i][j]==local_cnt)\n\t\t\t\t {\n\t\t\t\t\t local_index = k;\n\t\t\t\t\t break;\n\t\t\t\t }\n\t\t\t\t local_cnt++;\n\t\t\t }\n\n\t\t\t // 处理打印控制\n\t\t\t p_datafield = p_ref_info->p_item[local_index].p_datafield;\n\t\t\t if(p_datafield==NULL) continue;\n\n\t\t\t *cp->print_ptr++ = 0x1b;                     // 打印机命令:ESC $--设定绝对水平打印位置\n\t\t\t *cp->print_ptr++ = '$';\n\n\t\t\t analog_offset = 0;\n\t\t\t for(k=0; k<i; k++)\n\t\t\t\t analog_offset += cp->specific_info.group_column_num[k];\n\t\t\t *cp->print_ptr++ = ((UINT16)(cp->specific_info.unit_width\n\t\t\t\t *((cp->each_page_pulse_num[cp->specific_info.base_index]+1+1)+(analog_offset+j)*4))/3)%256;\n\t\t\t *cp->print_ptr++ = ((UINT16)(cp->specific_info.unit_width\n\t\t\t\t *((cp->each_page_pulse_num[cp->specific_info.base_index]+1+1)+(analog_offset+j)*4))/3)/256;\n\n\t\t\t printCharLine(cp,WITHOUT_RETURN);\n\n\t\t\t // modify by daigang, 由于平台宏支撑问题，模拟通道打印波形头一律用A1、A2、...\n\t\t\t sprintf(local_buffer, \"A%d\", analog_index+1);\n\t\t\t analog_index++;\n\t\t\t printAddStrToBuf(cp, local_buffer);          \n\t\t\t // 波形头的英文缩写\n\t\t\t //            if(p_datafield->desc_no==65535)\t// 未配置，则固定从datafield的desc中获取\n\t\t\t //            {\n\t\t\t //            \taddStrToPrintBuf(cp,p_datafield->desc);\n\t\t\t //            }\n\t\t\t //            else\n\t\t\t //            {\n\t\t\t //                // （放于英文描述最后的括号里）固定从英文描述中获得\n\t\t\t //                p_str = getEnglishDesc(p_datafield->desc_no);    \n\t\t\t //                if(p_str)\n\t\t\t //                {\n\t\t\t //                    printf(\"--------english desc=%s\\n\",p_str);\n\t\t\t //                    p_local_buf = strchr(p_str,'(');\n\t\t\t //                    if(p_local_buf)\n\t\t\t //                    {\n\t\t\t //                        p_local_buf++;\n\t\t\t //                        addStrToPrintBuf(cp,p_local_buf);\n\t\t\t //                        cp->print_ptr -= 1;   // -1为')'\n\t\t\t //                    }\n\t\t\t //                    else                            // 若在描述中未找到'(',则固定打印描述XXXX\n\t\t\t //                        addStrToPrintBuf(cp,p_str);\n\t\t\t //                }\n\t\t\t //                else\n\t\t\t //                {\n\t\t\t //                    printf(\"getEnglishDesc is NULL, desc_no=%d,name=%s, desc=%s\\n\", p_datafield->desc_no,p_datafield->name,p_datafield->desc);\n\t\t\t //                    addStrToPrintBuf(cp,\"XXXX\");\n\t\t\t //                }\n\t\t\t //            }\n\t\t }\n\t }\n\n\t *cp->print_ptr++ = 0x12;                   // 打印机命令:DC2--解除压缩打印\n\n\t *cp->print_ptr++ = 0x1c;                   // 打印机命令:FS &--设定汉字方式\n\t *cp->print_ptr++ = '&';\n\n\t *cp->print_ptr++ = 0x1b;                   // 打印机命令:ESC F--解除粗体打印\n\t *cp->print_ptr++ = 'F';\n\t printCharLine(cp,WITH_RETURN);\n\n\t *cp->print_ptr++ = 0x1b;                   // 打印机命令:ESC* m,nL nH--设置图形方式\n\t *cp->print_ptr++ = '*';\n\t *cp->print_ptr++ = 39;\n\t *cp->print_ptr++ = cp->specific_info.graph_width%256;\n\t *cp->print_ptr++ = cp->specific_info.graph_width/256;\n\n\t local_ptr = cp->print_ptr;\n\t // 清空图形打印缓存\n\n\t for(i=0; i<3*cp->specific_info.graph_width; i++)\n\t\t *cp->print_ptr++ = 0;  // 由于字符方式打印一行后缓存全部清为空格(即0x20)\n\n\t for(i=0; i<(cp->each_page_pulse_num[cp->specific_info.base_index]\n\t +cp->each_page_analog_num[cp->specific_info.base_index]*4+2); i++)\n\t {\n\t\t for(j=0; j<cp->specific_info.unit_width; j++)\n\t\t {\n\t\t\t if(i==0)\n\t\t\t\t *local_ptr = 0x00;\n\t\t\t else if( (i<=cp->each_page_pulse_num[cp->specific_info.base_index])\n\t\t\t\t && (j==0) )\n\t\t\t\t *local_ptr = 0xfc;\n\t\t\t else if( (i>cp->each_page_pulse_num[cp->specific_info.base_index])\n\t\t\t\t && (((i-cp->each_page_pulse_num[cp->specific_info.base_index]-1+2)%4)==0)\n\t\t\t\t && (j==0) )\n\t\t\t\t *local_ptr = 0xfc;\n\t\t\t else\n\t\t\t\t *local_ptr = 0x00;\n\n\t\t\t if(j==0) *(local_ptr+1) = 0xfc;\n\t\t\t else *(local_ptr+1) = 0x00;\n\n\t\t\t *(local_ptr+2) = 0xff;\n\t\t\t local_ptr += 3;\n\t\t }\n\t }\n\n\t *cp->print_ptr++ = 0x0F;                   // 设定压缩打印\n\n\n\t read_ctrl.field = FAULT_DF_WAVE_BKL;\n\t read_ctrl.off = 0;\n\t read_ctrl.num = 1;   \n\t getHisFaultData(&cp->wave_data.fault_head,&read_ctrl,(void*)&cp->wave_data.smpl_blk_head);\n\t cp->specific_info.wave_stamp = (cp->wave_data.smpl_blk_head.start_t.sec\n\t\t - cp->wave_data.smpl_blk_head.trig_t.sec)*1000.\n\t\t + (cp->wave_data.smpl_blk_head.start_t.us\n\t\t - cp->wave_data.smpl_blk_head.trig_t.us)/1000.;\n\t sprintf(local_buffer,\"%09.2f\",cp->specific_info.wave_stamp);\n\t \n\t zero_scale_line = floor(cp->specific_info.wave_stamp)*(cp->dev_cfg.system_freq)/(-500);\n\t\n\t \n\t printAddStrToBuf(cp,(INT8*)local_buffer);\n\t *cp->print_ptr++ = 'm';\n\t *cp->print_ptr++ = 's';\n\n\t *cp->print_ptr++ = 0x12;                   // 解除压缩打印\n\n\t printCharLine(cp,WITH_RETURN);\n\n\t return;\n }\n\n LOCAL void printWaveHead(Print *cp)\n {\n\t INT32 i = 0, pos = 0;\n\t INT8 local_buffer[128] = { 0 };\n\t INT32 bytes = 0, len = 0;\n\t FaultReadCtrl read_ctrl = { 0 };\n\t PrintRefInfo *p_ref_info = NULL;\n\t RefParameterItems *p_ref_tbl_item = NULL;\n\n\t // 设定粗体打印\n\t *cp->print_ptr++ = ESC;\n\t *cp->print_ptr++ = '(';\n\t *cp->print_ptr++ = 's';\n\t *cp->print_ptr++ = '3';\n\t *cp->print_ptr++ = 'B';\n\t printCharLine(cp, WITHOUT_RETURN);\n\n\t for (i = 0; i < cp->each_page_pulse_num[cp->specific_info.base_index] + \n\t\t\t\tcp->each_page_analog_num[cp->specific_info.base_index]; i++)\n\t {\n\t\t // 文字分辨率设置为720DPI，图形分辨率设置为75DPI，由于模块化没设计好，今后如修改这两个参数注意更新\n\t\t pos = (cp->specific_info.position[i] - 5) * 720 / 75;\n\n\t\t // 设定光标位置\n\t\t *cp->print_ptr++ = ESC;\n\t\t *cp->print_ptr++ = '*';\n\t\t *cp->print_ptr++ = 'p';\n\t\t len = sprintf(cp->print_ptr, \"%d\", pos);\n\t\t cp->print_ptr += len;\n\t\t *cp->print_ptr++ = 'X';\n\n\t\t if (i < cp->each_page_pulse_num[cp->specific_info.base_index])\n\t\t {\n\t\t\t *cp->print_ptr++ = i + 1 + '0';\n\t\t }\n\t\t else\n\t\t {\n\t\t\t len = sprintf(cp->print_ptr, \"A%d\", i - cp->each_page_pulse_num[cp->specific_info.base_index] + 1);\n\t\t\t cp->print_ptr += len;\n\t\t }\n\t }\n\t printCharLine(cp, WITH_RETURN);\n\n\t // 解除粗体打印\n\t *cp->print_ptr++ = ESC;\n\t *cp->print_ptr++ = '(';\n\t *cp->print_ptr++ = 's';\n\t *cp->print_ptr++ = '0';\n\t *cp->print_ptr++ = 'B';\n\t printCharLine(cp, WITHOUT_RETURN);\n\t \n\t /*read_ctrl.field = FAULT_DF_WAVE_BKL;\n\t read_ctrl.off = 0;\n\t read_ctrl.num = 1;\n\t getHisFaultData(&cp->wave_data.fault_head, &read_ctrl, (void *)&cp->wave_data.smpl_blk_head);\n\t cp->specific_info.wave_stamp = (cp->wave_data.smpl_blk_head.start_t.sec -\n\t\t cp->wave_data.smpl_blk_head.trig_t.sec) * 1000. +\n\t\t (cp->wave_data.smpl_blk_head.start_t.us -\n\t\t cp->wave_data.smpl_blk_head.trig_t.us) / 1000.;\n\t len = sprintf(cp->print_ptr, \"%09.2f\", cp->specific_info.wave_stamp);\n\t cp->print_ptr += len;\n\t *cp->print_ptr++ = 'm';\n\t *cp->print_ptr++ = 's';*/\n\n\t *cp->print_ptr++ = 't';\n\t *cp->print_ptr++ = '1';\n\t printCharLine(cp, WITHOUT_RETURN);\n\n\t return;\n }\n\n LOCAL void setWaveAxis(Print *cp,UINT32 wave_frequency)\n {\n\t INT32 i;\n\t INT8 *local_ptr;\n\n\t *cp->print_ptr++ = 0x1b;                           // 打印机命令:ESC* m,nL nH--设置图形方式\n\t *cp->print_ptr++ = '*';\n\t *cp->print_ptr++ = 39;\n\t *cp->print_ptr++ = cp->specific_info.graph_width%256;\n\t *cp->print_ptr++ = cp->specific_info.graph_width/256;\n\n\t // 清空图形打印缓存\n\t for(i=0; i<3*cp->specific_info.graph_width; i++)\n\t\t *cp->print_ptr++ = 0;  // 由于字符方式打印一行后缓存全部清为空格（即0x20）\n\n\t local_ptr = cp->print_buf+5;\n\t // 设定每路纵向零点\n\t for(i=0; i<(cp->each_page_pulse_num[cp->specific_info.base_index]\n\t +cp->each_page_analog_num[cp->specific_info.base_index]); i++)\n\t {\n\t\t *(local_ptr+cp->specific_info.position[i]*3+0) = 0xff;\n\t\t *(local_ptr+cp->specific_info.position[i]*3+1) = 0xff;\n\t\t *(local_ptr+cp->specific_info.position[i]*3+2) = 0xff;\n\t }\n\n\t if(wave_frequency>=cp->task_freq)\n\t {\n\t\t // 每两行(一个周波),行末打印时标点[奇数行]\n\t\t if( (cp->specific_info.line_number%2) && (wave_frequency%1200==0) )\n\t\t {\n\t\t\t for(i=0; i<(cp->each_page_pulse_num[cp->specific_info.base_index]\n\t\t\t +cp->each_page_analog_num[cp->specific_info.base_index]); i++)\n\t\t\t {\n\t\t\t\t *(local_ptr+cp->specific_info.position[i]*3-7) = 0x01;\n\t\t\t\t *(local_ptr+cp->specific_info.position[i]*3-4) = 0x01;\n\t\t\t\t *(local_ptr+cp->specific_info.position[i]*3-1) = 0x01;\n\t\t\t\t *(local_ptr+cp->specific_info.position[i]*3+5) = 0x01;\n\t\t\t\t *(local_ptr+cp->specific_info.position[i]*3+8) = 0x01;\n\t\t\t\t *(local_ptr+cp->specific_info.position[i]*3+11) = 0x01;\n\t\t\t }\n\t\t }\n\n\t\t // 每四行且可以被1200整除(若为1200Hz则对应两个周波),则行首打印一次横向标尺\n\t\t if( ((cp->specific_info.line_number%4)==0) && (wave_frequency%1200==0) )\n\t\t {\n\t\t\t for(i=0; i<cp->specific_info.graph_width*3; i+=3*8)\n\t\t\t\t *(local_ptr+i) |= 0x80;\n\t\t }\n\t\t // 当到0ms时且在第一块，以两倍密度打印横向标尺\n\t\t if( cp->specific_info.line_number == zero_scale_line\n\t\t \t&& is_print_zero_scale == 1)\n\t\t {\n\t\t \tfor(i=0; i<cp->specific_info.graph_width*3; i+=3*2)\n\t\t\t\t *(local_ptr+i) |= 0x80;\n\t\t\tis_print_zero_scale = 0;\n\t\t }\n\t }\n\n\t cp->specific_info.line_number++;\n\n\t return;\n }\n\n LOCAL INT32 setTripPulse(Print *cp,UINT32 frequency,UINT8 fan_index,\n\t UINT16 print_line_index,INT32 print_dot_num)\n {\n\t UINT16 i=0,j=0,k=0,print_line_num=0;\n\t INT8 *local_ptr=NULL,lit_line_index=0;\n\t FLOAT32 stamp_last_dot=0.;\n\n\t // 跳过图形打印设置命令\n\t local_ptr = cp->print_buf+5;\n\n\t if(frequency>=cp->task_freq)\n\t\t print_line_num = print_dot_num*2;      // 2为由于插值点而产生的\n\t else\n\t\t print_line_num = print_dot_num*4;      // 4是由于幅值固定每点打印6个点    4*6＝24对应24针\n\n\t stamp_last_dot = cp->specific_info.wave_stamp;\n\t // 每打印一行为3*8个象素小行\n\t for(i=0;i<print_line_num;i++)\n\t {\n\t\t if(frequency>=cp->task_freq)\n\t\t\t // 注意:lit_line_index在ProcessTripPulse是用于取数据的,而插值点是无数据取的\n\t\t\t lit_line_index = i/2;\n\t\t else\n\t\t\t lit_line_index = i/4;\n\n\t\t processTripPulse(cp,frequency,fan_index,print_line_index,lit_line_index);\n\t\t for(j=0;j<cp->each_page_pulse_num[cp->specific_info.base_index];j++)\n\t\t {\n\t\t\t // 跳闸脉冲为空心的(便于看出动作与返回)\n\t\t\t if( ((cp->specific_info.pulse_value>>j)&0x01)\n\t\t\t\t != ((cp->specific_info.pulse_last_value>>j)&0x01) )\n\t\t\t {   // 跳闸脉冲1->0或0->1\n\t\t\t\t for(k=0;k<=cp->specific_info.unit_width/3;k++)\n\t\t\t\t\t *(local_ptr+(cp->specific_info.position[j]+k)*3+i/8) |= (1<<(7-i%8)); // 跳闸脉冲宽度1/3象素单元\n\t\t\t }\n\t\t\t else if(((cp->specific_info.pulse_value>>j)&0x01)!=0)\n\t\t\t {       // 当前值是1\n\t\t\t\t k = cp->specific_info.unit_width/3;                     // 只打印最外侧的动作线\n\t\t\t\t *(local_ptr+(cp->specific_info.position[j]+k)*3+i/8) |= (1<<(7-i%8));\n\t\t\t }\n\t\t }\n\t\t // 保存上点\n\t\t cp->specific_info.pulse_last_value = cp->specific_info.pulse_value;\n\n\t\t stamp_last_dot = cp->specific_info.wave_stamp;\n\t\t if(frequency>=cp->task_freq)\n\t\t\t cp->specific_info.wave_stamp += 1000.0/(frequency*2.0);\n\t\t else\n\t\t\t cp->specific_info.wave_stamp += 1000.0/(frequency*4.0);\n\t }\n\n\t return 0;\n }\n\n LOCAL void processTripPulse(Print *cp,UINT32 frequency,UINT8 fan_index,\n\t UINT16 print_line_index,UINT8 lit_line_index)\n {\n\t UINT16 j=0,fan_wave_start=0,index=0;\n\n\t if(fan_index==0) \n\t\t fan_wave_start = 0;\n\t else\n\t\t fan_wave_start = cp->wave_data.stamp_dot_num[fan_index-1];\n\t if(frequency>=cp->task_freq)\n\t\t index = print_line_index*12+lit_line_index;\n\t else\n\t\t index = print_line_index*6+lit_line_index;\n\n\t for(j=0; j<cp->each_page_pulse_num[cp->specific_info.base_index]; j++)\n\t {\n\n\t\t if( cp->wave_data.p_user_bin_buf[(fan_wave_start+index)\n\t\t\t *cp->wave_data.bin_int16_num+(cp->p_each_page_pulse_offset[cp->specific_info.base_index][j]>>4)]\n\t\t &(1<<(cp->p_each_page_pulse_offset[cp->specific_info.base_index][j]&0x0f)) )\n\t\t\t cp->specific_info.pulse_value |= (1<<j);\n\t\t else\n\t\t\t cp->specific_info.pulse_value &= ~(1<<j);\n\t }\n\n\t return;\n }\n\n LOCAL void setWaveInstant(Print *cp,UINT8 fan_index,UINT16 print_line_index,\n\t INT32 print_dot_num,INT32 fan_print_line_num)\n {\n\t UINT16 i=0,j=0,k=0,m=0,n=0,fan_wave_start=0;\n\t FLOAT64 sign_value=0.,insert_sign_value=0.;\n\t INT32 shift_width=0;\n\t INT8 *local_ptr=NULL;\n\n\t // 跳过图形打印设置命令\n\t local_ptr = cp->print_buf+5;\n\n\t // 完整一行模拟量波形的是24象素点,其中包括12个实际点和12个插值点\n\t for(i=0;i<print_dot_num;i++)\n\t {\n\t\t for(j=0;j<cp->specific_info.group_num;j++)\n\t\t {\n\t\t\t for(k=0;k<cp->specific_info.group_column_num[j];k++)\n\t\t\t {\n\t\t\t\t n=0;\n\t\t\t\t for(m=0;m<j;m++)\n\t\t\t\t\t n += cp->specific_info.group_column_num[m];\n\n\t\t\t\t if(fan_index==0) \n\t\t\t\t\t fan_wave_start = 0;\n\t\t\t\t else\n\t\t\t\t\t fan_wave_start = cp->wave_data.stamp_dot_num[fan_index-1];\n\t\t\t\t // 第一采样点\n\t\t\t\t sign_value = cp->wave_data.p_analog_buf[(fan_wave_start+print_line_index*12+i)\n\t\t\t\t\t *cp->wave_data.ana_num+cp->specific_info.wave_shift[j][k]];\n\n\t\t\t\t sign_value = (sign_value*cp->wave_data.p_analog_coef_a[cp->specific_info.wave_shift[j][k]]\n\t\t\t\t +cp->wave_data.p_analog_coef_b[cp->specific_info.wave_shift[j][k]]);\n\t\t\t\t //                            *cp->specific_info.group_norm[cp->specific_info.group_data_max_ps[j]][j];\n\t\t\t\t if(sign_value>0)\n\t\t\t\t {   //防止越限处理\n\t\t\t\t\t if(sign_value>cp->specific_info.max_value[j])\n\t\t\t\t\t\t sign_value = cp->specific_info.max_value[j];\n\t\t\t\t }\n\t\t\t\t else\n\t\t\t\t {\n\t\t\t\t\t if((-sign_value)>cp->specific_info.max_value[j])\n\t\t\t\t\t\t sign_value = -cp->specific_info.max_value[j];\n\t\t\t\t }\n\t\t\t\t if(cp->specific_info.max_value[j])\n\t\t\t\t\t shift_width = sign_value*2*cp->specific_info.unit_width/cp->specific_info.max_value[j];\n\t\t\t\t else\n\t\t\t\t\t shift_width = 0;\n\t\t\t\t *(local_ptr+(cp->specific_info.position[n+k+cp->each_page_pulse_num[cp->specific_info.base_index]]+shift_width)*3+i*2/8) \n\t\t\t\t\t |= (1<<(7-(i*2)%8));\n\n\t\t\t\t // 是本个FAN的最后一点，则没有插值点可以使用（极端情况会造成内存访问出错）\n\t\t\t\t if( (print_line_index==fan_print_line_num-1)&&(i==(print_dot_num-1)) ) continue;\n\t\t\t\t // 第二采样点\n\t\t\t\t insert_sign_value = cp->wave_data.p_analog_buf[(fan_wave_start+print_line_index*12+i+1)\n\t\t\t\t\t *cp->wave_data.ana_num+cp->specific_info.wave_shift[j][k]];\n\t\t\t\t insert_sign_value = (insert_sign_value*cp->wave_data.p_analog_coef_a[cp->specific_info.wave_shift[j][k]]\n\t\t\t\t +cp->wave_data.p_analog_coef_b[cp->specific_info.wave_shift[j][k]]);\n\t\t\t\t //                                   *cp->specific_info.group_norm[cp->specific_info.group_data_max_ps[j]][j];\n\t\t\t\t if(insert_sign_value>0)\n\t\t\t\t {   //防止越限处理\n\t\t\t\t\t if(insert_sign_value>cp->specific_info.max_value[j])\n\t\t\t\t\t\t insert_sign_value = cp->specific_info.max_value[j];\n\t\t\t\t }\n\t\t\t\t else\n\t\t\t\t {\n\t\t\t\t\t if((-insert_sign_value)>cp->specific_info.max_value[j])\n\t\t\t\t\t\t insert_sign_value = -cp->specific_info.max_value[j];\n\t\t\t\t }\n\t\t\t\t //插值点\n\t\t\t\t insert_sign_value = (sign_value+insert_sign_value)/2;\n\n\t\t\t\t if(cp->specific_info.max_value[j])\n\t\t\t\t\t shift_width = (insert_sign_value*2*cp->specific_info.unit_width/cp->specific_info.max_value[j]);\n\t\t\t\t else\n\t\t\t\t\t shift_width = 0;\n\t\t\t\t *(local_ptr+(cp->specific_info.position[n+k+cp->each_page_pulse_num[cp->specific_info.base_index]]+shift_width)*3+(i*2+1)/8) \n\t\t\t\t\t |= (1<<(7-(i*2+1)%8));\n\t\t\t }\n\t\t }\n\t }\n\n\t return;\n }\n\n LOCAL void setWaveAmplitude(Print *cp,UINT8 fan_index,UINT16 print_line_index,INT32 print_dot_num)\n {\n\t UINT16 i=0,j=0,k=0,m=0,n=0,local_left=0,local_right=0,fan_wave_start=0;\n\t FLOAT64 sign_value=0.,shift_width=0.;\n\t INT8 *local_ptr=NULL;\n\n\t // 跳过图形打印设置命令\n\t local_ptr = cp->print_buf+5;\n\n\t // 一行幅值波形的是print_dot_num象素点\n\t for(i=0; i<print_dot_num; i++)\n\t {\n\t\t for(j=0; j<cp->specific_info.group_num; j++)\n\t\t {\n\t\t\t for(k=0; k<cp->specific_info.group_column_num[j]; k++)\n\t\t\t {\n\t\t\t\t n=0;\n\t\t\t\t for(m=0; m<j; m++)\n\t\t\t\t\t n += cp->specific_info.group_column_num[m];\n\n\t\t\t\t if(fan_index==0) \n\t\t\t\t\t fan_wave_start = 0;\n\t\t\t\t else\n\t\t\t\t\t fan_wave_start = cp->wave_data.stamp_dot_num[fan_index-1];\n\t\t\t\t sign_value = cp->wave_data.p_analog_buf[(fan_wave_start+print_line_index*6+i)\n\t\t\t\t\t *cp->wave_data.ana_num+cp->specific_info.wave_shift[j][k]];\n\t\t\t\t sign_value = (sign_value*cp->wave_data.p_analog_coef_a[cp->specific_info.wave_shift[j][k]]\n\t\t\t\t +cp->wave_data.p_analog_coef_b[cp->specific_info.wave_shift[j][k]]);\n\t\t\t\t //                            *cp->specific_info.group_norm[cp->specific_info.group_data_max_ps[j]][j];\n\n\t\t\t\t // 防止越限处理\n\t\t\t\t if(sign_value>0)\n\t\t\t\t {\n\t\t\t\t\t if(sign_value>cp->specific_info.max_value[j])\n\t\t\t\t\t\t sign_value = cp->specific_info.max_value[j];\n\t\t\t\t }\n\t\t\t\t else\n\t\t\t\t {\n\t\t\t\t\t if((-sign_value)>cp->specific_info.max_value[j])\n\t\t\t\t\t\t sign_value = -cp->specific_info.max_value[j];\n\t\t\t\t }\n\n\t\t\t\t if(cp->specific_info.max_value[j])\n\t\t\t\t\t shift_width = (sign_value*2*cp->specific_info.unit_width/cp->specific_info.max_value[j]);\n\t\t\t\t else\n\t\t\t\t\t shift_width = 0;\n\n\t\t\t\t if(sign_value>=0)\n\t\t\t\t {\n\t\t\t\t\t local_left = cp->specific_info.position[n+k+cp->each_page_pulse_num[cp->specific_info.base_index]]-shift_width;\n\t\t\t\t\t local_right = cp->specific_info.position[n+k+cp->each_page_pulse_num[cp->specific_info.base_index]]+shift_width;\n\n\t\t\t\t\t for(m=local_left; m<local_right; m++)\n\t\t\t\t\t\t *(local_ptr+m*3+i/2) |= (1<<(4-i%2*4));\n\t\t\t\t }\n\t\t\t\t else // 若幅值小于零，则只打印负半轴\n\t\t\t\t {\n\t\t\t\t\t local_left = cp->specific_info.position[n+k+cp->each_page_pulse_num[cp->specific_info.base_index]]+shift_width;\n\t\t\t\t\t local_right = cp->specific_info.position[n+k+cp->each_page_pulse_num[cp->specific_info.base_index]];\n\n\t\t\t\t\t for(m=local_left; m<local_right; m++)\n\t\t\t\t\t\t *(local_ptr+m*3+i/2) |= (1<<(4-i%2*4));\n\t\t\t\t }\n\t\t\t }\n\t\t }\n\t }\n\n\t return;\n }\n\n LOCAL void setWaveDotAxis(Print *cp,UINT8 end_line)\n {\n\t UINT16 i=0;\n\t INT8 *local_ptr=NULL;\n\n\t *cp->print_ptr++ = 0x1b;                           // 打印机命令:ESC* m,nL nH--设置图形方式\n\t *cp->print_ptr++ = '*';\n\t *cp->print_ptr++ = 39;\n\t *cp->print_ptr++ = cp->specific_info.graph_width%256;\n\t *cp->print_ptr++ = cp->specific_info.graph_width/256;\n\n\t // 清空图形打印缓存\n\t for(i=0;i<3*cp->specific_info.graph_width;i++)\n\t\t *cp->print_ptr++ = 0;  // 由于字符方式打印一行后缓存全部清为空格（即0x20）\n\n\t local_ptr = cp->print_buf+5;\n\t // 设定每路纵向零点\n\t for(i=0; i<(cp->each_page_pulse_num[cp->specific_info.base_index]\n\t +cp->each_page_analog_num[cp->specific_info.base_index]); i++)\n\t {\n\t\t *(local_ptr+cp->specific_info.position[i]*3+0) = 0x33;\n\t\t *(local_ptr+cp->specific_info.position[i]*3+1) = 0x33;\n\t\t *(local_ptr+cp->specific_info.position[i]*3+2) = 0x33;\n\t }\n\t if(end_line==1)\n\t {\n\t\t for(i=0;i<cp->specific_info.graph_width*3;i+=3*8)\n\t\t\t *(local_ptr+i) |= 0x80;  //行首打印横向标尺\n\t }\n\t if(end_line==2)\n\t {\n\t\t for(i=0;i<cp->specific_info.graph_width*3;i+=3*8)\n\t\t\t *(local_ptr+i+2) |= 0x01; //行末打印横向标尺\n\t }\n\n\t return;\n }\n\n LOCAL void printWaveFormUart(Print *cp)\n {\n\t INT32 i = 0,j=0,print_line_num=0,print_line_last=0,print_dot_num=0;\n\t UINT32 fan_dot_num=0;\n\t INT8 local_buffer[16]={0};\n\n\t // 跳闸脉冲\n\t cp->specific_info.pulse_value = 0;\n\t cp->specific_info.pulse_last_value = 0;\n\n\t //    printf(\"print wave blk_num=%d\\n\",cp->nflash_wave_data.fault_head.blk_num);\n\t // FAN波形块数\n\t is_print_zero_scale = 1;\n\t for(i=0;i<cp->wave_data.fault_head.fan_num;i++)\n\t {\n\t\t cp->specific_info.line_number = 0;\n\t\t // 本个FAN录波点数\n\t\t fan_dot_num = cp->wave_data.rate_dot_num[i];\n\n\t\t // 瞬时值录波\n\t\t if(cp->wave_data.rec_freq[i]>=cp->task_freq)\n\t\t {\n\t\t\t print_line_num = (fan_dot_num*2+23)/24;      // 由于录波点数不保证是24的整数倍（24点与24针打印机对应）,因而打印最后一行时必须处理最后可能的剩余点\n\t\t\t print_line_last = fan_dot_num*2%24;          // 最后一行需要打印的点数\n\t\t\t // 打印行数\n\t\t\t for(j=0;j<print_line_num;j++)\n\t\t\t {\n\t\t\t\t // 最后一行且为非整6点行，则控制换行量，以使得下块波形能与之相连\n\t\t\t\t if((j==print_line_num-1)&&(print_line_last!=0)) print_dot_num = print_line_last;\n\t\t\t\t else print_dot_num = 24;\n\n\t\t\t\t // 最后一行且为非整6点行，则控制换行量，以使得下块波形能与之相连\n\t\t\t\t if((j==print_line_num-1)&&(print_line_last!=0))\n\t\t\t\t {\n\t\t\t\t\t *cp->print_ptr++ = 0x1b;               // 打印机命令:ESC + n--设置n/360英寸的换行量\n\t\t\t\t\t *cp->print_ptr++ = '+';\n\t\t\t\t\t *cp->print_ptr++ = print_line_last*2;\n\t\t\t\t\t printCharLine(cp,WITHOUT_RETURN);\n\t\t\t\t }\n\t\t\t\t setWaveAxis(cp,(UINT32)cp->wave_data.rec_freq[i]);\n\t\t\t\t setTripPulse(cp,(UINT32)cp->wave_data.rec_freq[i],i,j,print_dot_num/2);\n\t\t\t\t setWaveInstant(cp,i,j,print_dot_num/2,print_line_num);\n\n\t\t\t\t // 在每个瞬时值录波的开始打印相对时间(第一块除外)\n\t\t\t\t //if( (j==0)&&(i!=0) )\n\t\t\t\t if((j==0)&&(i!=0))\t\t\t//modified by wzc, 增加0ms时标\n\t\t\t\t {\n\t\t\t\t\t *cp->print_ptr++ = 0x0f;                   // 设定压缩打印\n\t\t\t\t\t // 由于时间在setTripPulse已经增加，此时打时标要减掉已经增加的时间\n\t\t\t\t\t  sprintf(local_buffer,\"%09.2f\",cp->specific_info.wave_stamp\n\t\t\t\t\t  -1000.0/(cp->wave_data.rec_freq[i]*2.0)*print_dot_num);\n\t\t\t\t\t  printAddStrToBuf(cp,(INT8*)local_buffer);\n\t\t\t\t\t *cp->print_ptr++ = 'm';\n\t\t\t\t\t *cp->print_ptr++ = 's';\n\t\t\t\t\t *cp->print_ptr++ = 0x12;                   // 解除压缩打印\n\t\t\t\t  }\n\n\t \t\t\t//modified by wzc, 增加0ms时标,只在第一块打印\n\t\t\t\t  if( (i==0) && (j == zero_scale_line))\n\t\t\t\t  {\n\t\t\t\t\t sprintf(local_buffer, getLocalLangByAbbr(\"RELATIVE_TIME\",0));\n\t\t\t\t\t strcat(local_buffer, \"0\");\n\t\t\t\t\t printAddStrToBuf(cp,(INT8*)local_buffer);\n\t\t\t\t\t *cp->print_ptr++ = 'm';\n\t\t\t\t\t *cp->print_ptr++ = 's';\n\t\t\t\t\t *cp->print_ptr++ = 0x12;                   // 解除压缩打印\n\t \t\t\t  }\n\t\t\t\t\t \n\t\t\t\t printCharLine(cp,WITH_RETURN);\n\n\t\t\t\t // 恢复原来的换行量\n\t\t\t\t if((j==print_line_num-1)&&(print_line_last!=0))\n\t\t\t\t {\n\t\t\t\t\t *cp->print_ptr++ = 0x1b;                   // 打印机命令:ESC + n--设置n/360英寸的换行量\n\t\t\t\t\t *cp->print_ptr++ = '+';\n\t\t\t\t\t *cp->print_ptr++ = 48;\n\t\t\t\t\t printCharLine(cp,WITHOUT_RETURN);\n\t\t\t\t }\n\t\t\t }\n\t\t }\n\t\t // 幅值录波\n\t\t else\n\t\t {\n\t\t\t print_line_num = (fan_dot_num+5)/6;        // 每行打印6个幅值点\n\t\t\t print_line_last = fan_dot_num%6;           // 最后一行的余数点数\n\t\t\t // 打印行数\n\t\t\t for(j=0;j<print_line_num;j++)\n\t\t\t {\n\t\t\t\t // 最后一行且为非整6点行，则控制换行量，以使得下块波形能与之相连\n\t\t\t\t if((j==print_line_num-1)&&(print_line_last!=0))\n\t\t\t\t {\n\t\t\t\t\t *cp->print_ptr++ = 0x1b;               // 打印机命令:ESC + n--设置n/360英寸的换行量\n\t\t\t\t\t *cp->print_ptr++ = '+';\n\t\t\t\t\t *cp->print_ptr++ = print_line_last*8;\n\t\t\t\t\t printCharLine(cp,WITHOUT_RETURN);\n\t\t\t\t }\n\t\t\t\t setWaveAxis(cp,(UINT32)cp->wave_data.rec_freq[i]);\n\t\t\t\t if((j==print_line_num-1)&&(print_line_last!=0)) print_dot_num = print_line_last;\n\t\t\t\t else print_dot_num = 6;\n\n\t\t\t\t setTripPulse(cp,cp->wave_data.rec_freq[i],i,j,print_dot_num);\n\t\t\t\t setWaveAmplitude(cp,i,j,print_dot_num);\n\n\t\t\t\t printCharLine(cp,WITH_RETURN);\n\n\t\t\t\t // 恢复原来的换行量\n\t\t\t\t if((j==print_line_num-1)&&(print_line_last!=0))\n\t\t\t\t {\n\t\t\t\t\t *cp->print_ptr++ = 0x1b;                   // 打印机命令:ESC + n--设置n/360英寸的换行量\n\t\t\t\t\t *cp->print_ptr++ = '+';\n\t\t\t\t\t *cp->print_ptr++ = 48;\n\t\t\t\t\t printCharLine(cp,WITHOUT_RETURN);\n\t\t\t\t }\n\t\t\t }\n\t\t }\n\t }\n\t setWaveDotAxis(cp,0);\n\t printCharLine(cp,WITH_RETURN);\n\n\t printCharLine(cp,WITH_RETURN);\n\n\t return;\n }\n\n LOCAL void printWaveForm(Print *cp)\n {\n\t INT32 i = 0, j = 0, print_line_num = 0, print_dot_num = 0, len = 0, bytes = 0;\n\t UINT32 fan_dot_num = 0;\n\t INT8 local_buffer[16] = { 0 }, index = 0;\n\t LOCAL INT8 s_index = 1;\n\n\t // 跳闸脉冲\n\t cp->specific_info.pulse_value = 0;\n\t cp->specific_info.pulse_last_value = 0;\n\n\t // FAN波形块数\n\t for (i = 0; i < cp->wave_data.fault_head.fan_num; i++)\n\t {\n\t\t cp->specific_info.line_number = 0;\n\n\t\t // 本个FAN录波点数\n\t\t fan_dot_num = cp->wave_data.rate_dot_num[i];\n\n\t\t // 瞬时值录波\n\t\t if (cp->wave_data.rec_freq[i] >= cp->task_freq)\n\t\t {\n\t\t\t // 进行插值处理，故总点数需要乘以2\n\t\t\t print_line_num = fan_dot_num * 2;\n\n\t\t\t // 设定光标纵向位移单位\n\t\t\t *cp->print_ptr++ = ESC;\n\t\t\t *cp->print_ptr++ = '&';\n\t\t\t *cp->print_ptr++ = 'l';\n\t\t\t *cp->print_ptr++ = '0';\n\t\t\t *cp->print_ptr++ = 'C';\n\n\t\t\t // 开始图形打印，ESC * r 1 A\n\t\t\t *cp->print_ptr++ = ESC;\n\t\t\t *cp->print_ptr++ = '*';\n\t\t\t *cp->print_ptr++ = 'r';\n\t\t\t *cp->print_ptr++ = '1';\n\t\t\t *cp->print_ptr++ = 'A';\n\n\t\t\t // 逐行打印\n\t\t\t for (j = 0; j < print_line_num; j++)\n\t\t\t {\n\t\t\t\t // 设置图形光栅数据大小，ESC * b 0 m # W ###......\n\t\t\t\t *cp->print_ptr++ = ESC;\n\t\t\t\t *cp->print_ptr++ = '*';\n\t\t\t\t *cp->print_ptr++ = 'b';\n\t\t\t\t *cp->print_ptr++ = '0';\n\t\t\t\t *cp->print_ptr++ = 'm';\n\t\t\t\t bytes = (cp->specific_info.graph_width + 7) >> 3;\n\t\t\t\t len = sprintf(cp->print_ptr, \"%d\", bytes);\n\t\t\t\t cp->print_ptr += len;\n\t\t\t\t *cp->print_ptr++ = 'W';\n\t\t\t\t s_local_ptr = cp->print_ptr;\n\t\t\t\t cp->print_ptr += bytes;\n\t\t\t\t \n\t\t\t\t printSetWaveAxis(cp, (UINT32)cp->wave_data.rec_freq[i]);\n\t\t\t\t printTripPulse(cp, (UINT32)cp->wave_data.rec_freq[i], i);\n\t\t\t\t printWaveAmpInstant(cp, i, print_line_num / 2);\n\n\t\t\t\t // 在每个瞬时值录波的开始打印相对时间（第一块除外）\n\t\t\t\t if ((0 != i) && (0 == j))\n\t\t\t\t { \n\t\t\t\t\t /* print_dot_num = 100;\n\t\t\t\t\t while(print_dot_num--)\n\t\t\t\t\t *cp->print_ptr++ = ' ';\n\t\t\t\t\t sprintf(local_buffer, \"%9.2f\", cp->specific_info.wave_stamp - \n\t\t\t\t\t 1000. / (cp->wave_data.rec_freq[i] * 2.0));\n\t\t\t\t\t printAddStrToBuf(cp, local_buffer);\n\t\t\t\t\t *cp->print_ptr++ = 'm';\n\t\t\t\t\t *cp->print_ptr++ = 's';*/\n\t\t\t\t\t s_index += 1;\n\t\t\t\t\t sprintf(local_buffer, \"t%d\", s_index);\n\t\t\t\t\t printAddStrToBuf(cp, local_buffer);\n\t\t\t\t }\n\n\t\t\t\t cp->specific_info.line_number++;\n\n\t\t\t\t printCharLine(cp, WITH_RETURN);\n\t\t\t }\n\n\t\t\t // 结束图形打印， ESC * r C\n\t\t\t *cp->print_ptr++ = ESC;\n\t\t\t *cp->print_ptr++ = '*';\n\t\t\t *cp->print_ptr++ = 'r';\n\t\t\t *cp->print_ptr++ = 'C';\n\n\t\t\t printCharLine(cp, WITHOUT_RETURN);\n\t\t }\n\t\t else\n\t\t {\n\t\t\t // 幅值录波\n\t\t\t print_line_num = fan_dot_num;\n\n\t\t\t // 设定光标纵向位移单位\n\t\t\t *cp->print_ptr++ = ESC;\n\t\t\t *cp->print_ptr++ = '&';\n\t\t\t *cp->print_ptr++ = 'l';\n\t\t\t *cp->print_ptr++ = '0';\n\t\t\t *cp->print_ptr++ = 'C';\n\n\t\t\t // 开始图形打印，ESC * r 1 A\n\t\t\t *cp->print_ptr++ = ESC;\n\t\t\t *cp->print_ptr++ = '*';\n\t\t\t *cp->print_ptr++ = 'r';\n\t\t\t *cp->print_ptr++ = '1';\n\t\t\t *cp->print_ptr++ = 'A';\n\n\t\t\t // 逐行打印\n\t\t\t for (j = 0; j < print_line_num; j++)\n\t\t\t {\n\t\t\t\t // 设置图形光栅数据大小，ESC * b 0 m # W ###......\n\t\t\t\t *cp->print_ptr++ = ESC;\n\t\t\t\t *cp->print_ptr++ = '*';\n\t\t\t\t *cp->print_ptr++ = 'b';\n\t\t\t\t *cp->print_ptr++ = '0';\n\t\t\t\t *cp->print_ptr++ = 'm';\n\t\t\t\t bytes = (cp->specific_info.graph_width + 7) >> 3;\n\t\t\t\t len = sprintf(cp->print_ptr, \"%d\", bytes);\n\t\t\t\t cp->print_ptr += len;\n\t\t\t\t *cp->print_ptr++ = 'W';\n\t\t\t\t s_local_ptr = cp->print_ptr;\n\t\t\t\t cp->print_ptr += bytes;\n\n\t\t\t\t printSetWaveAxis(cp, (UINT32)cp->wave_data.rec_freq[i]);\n\t\t\t\t printTripPulse(cp, (UINT32)cp->wave_data.rec_freq[i], i);\n\t\t\t\t printWaveAmplitude(cp, i, print_line_num);\n\n\t\t\t\t cp->specific_info.line_number++;\n\n\t\t\t\t printCharLine(cp, WITHOUT_RETURN);\n\t\t\t }\n\n\t\t\t // 结束图形打印， ESC * r C\n\t\t\t *cp->print_ptr++ = ESC;\n\t\t\t *cp->print_ptr++ = '*';\n\t\t\t *cp->print_ptr++ = 'r';\n\t\t\t *cp->print_ptr++ = 'C';\n\n\t\t\t printCharLine(cp, WITHOUT_RETURN);\n\t\t }\n\t }\n\n\t print_line_num = 24;\n\t while(print_line_num--)\n\t {\n\t\t printSetWaveDotAxis(cp, 0);\n\t }\n\n\t // 恢复行间距\n\t *cp->print_ptr++ = ESC;\n\t *cp->print_ptr++ = '&';\n\t *cp->print_ptr++ = 'l';\n\t *cp->print_ptr++ = '1';\n\t *cp->print_ptr++ = '6';\n\t *cp->print_ptr++ = 'D';\n\t printCharLine(cp, WITHOUT_RETURN);\n\t \n\t printCharLine(cp, WITH_RETURN);\n\t printCharLine(cp, WITH_RETURN);\n\n\t return;\n }\n\n LOCAL void printSetWaveAxis(Print *cp, UINT32 wave_frequency)\n {\n\t INT32 i = 0, bytes = 0;\n\t INT8 *local_ptr = s_local_ptr;\n\t UINT16 pos = 0;\n\n\t bytes = (cp->specific_info.graph_width + 7) >> 3;\n\n\t // 清空图形打印缓存\n\t for (i = 0; i < bytes; i++)\n\t {\n\t\t *local_ptr++ = 0;\n\t }\n\n\t local_ptr = s_local_ptr;\n\n\t // 设定每路纵向零点\n\t for (i = 0; i < (cp->each_page_pulse_num[cp->specific_info.base_index] + \n\t\t\t\t\t  cp->each_page_analog_num[cp->specific_info.base_index]); i++)\n\t {\n\t\t *(local_ptr + (cp->specific_info.position[i] >> 3)) |= (1 << (7 - cp->specific_info.position[i] % 8));\n\t }\n\n\t if (wave_frequency >= cp->task_freq)\n\t {\n\t\t // 每48个点设定标度小短线\n\t\t if ((0 == cp->specific_info.line_number % 48) && (0 == wave_frequency % 1200))\n\t\t {\n\t\t\t for (i = 0; i < (cp->each_page_pulse_num[cp->specific_info.base_index] + \n\t\t\t\t\t\t\t  cp->each_page_analog_num[cp->specific_info.base_index]); i++)\n\t\t\t {\n\t\t\t\t pos = cp->specific_info.position[i];\n//\t\t\t\t *(local_ptr + ((pos - 3) >> 3)) |= (1 << (7 - (pos - 3) % 8));\n\t\t\t\t *(local_ptr + ((pos - 2) >> 3)) |= (1 << (7 - (pos - 2) % 8));\n\t\t\t\t *(local_ptr + ((pos - 1) >> 3)) |= (1 << (7 - (pos - 1) % 8));\n\t\t\t\t *(local_ptr + ((pos + 1) >> 3)) |= (1 << (7 - (pos + 1) % 8));\n\t\t\t\t *(local_ptr + ((pos + 2) >> 3)) |= (1 << (7 - (pos + 2) % 8));\n//\t\t\t\t *(local_ptr + ((pos + 3) >> 3)) |= (1 << (7 - (pos + 3) % 8));\n\t\t\t }\n\t\t }\n\n\t\t // 每四行设定波形分割线\n\t\t if ((0 == cp->specific_info.line_number % 96) && (0 == wave_frequency % 1200))\n\t\t {\n\t\t\t for (i = 0; i < cp->specific_info.graph_width; i += 8)\n\t\t\t {\n\t\t\t\t *(local_ptr + (i >> 3)) |= 0x80;\n\t\t\t }\n\t\t }\n\t }\n\n\t return;\n }\n\n LOCAL INT32 printTripPulse(Print *cp, UINT32 frequency, UINT8 fan_index)\n {\n\t UINT16 j = 0, k = 0;\n\t INT8 *local_ptr = s_local_ptr, lit_line_index = 0;\n\t FLOAT32 stamp_last_dot = 0.;\n\n\t stamp_last_dot = cp->specific_info.wave_stamp;\n\n\t if (frequency >= cp->task_freq)\n\t {\n\t\t lit_line_index = cp->specific_info.line_number / 2;\n\t }\n\t else\n\t {\n\t\t lit_line_index = cp->specific_info.line_number / 4;\n\t }\n\n\t printProcessTripPulse(cp, frequency, fan_index, lit_line_index);\n\n\t for (j = 0; j < cp->each_page_pulse_num[cp->specific_info.base_index]; j++)\n\t {\n\t\t if( ((cp->specific_info.pulse_value >> j) & 0x01)\n\t\t\t != ((cp->specific_info.pulse_last_value >> j) & 0x01))\n\t\t {\n\t\t\t for (k = 0; k <= cp->specific_info.unit_width / 3; k++)\n\t\t\t {\n\t\t\t\t *(local_ptr + ((cp->specific_info.position[j] + k) >> 3)) |= (1 << (7 - (cp->specific_info.position[j] + k) % 8));\n\t\t\t }\n\t\t }\n\t\t else if(((cp->specific_info.pulse_value>>j) & 0x01) != 0)\n\t\t {    \n\t\t\t k = cp->specific_info.unit_width / 3; \n\t\t\t *(local_ptr+((cp->specific_info.position[j]+k) >> 3)) |= (1 << (7 - (cp->specific_info.position[j] + k) % 8));\n\t\t }\n\t }\n\n\t // 保存上点\n\t cp->specific_info.pulse_last_value = cp->specific_info.pulse_value;\n\n\t stamp_last_dot = cp->specific_info.wave_stamp;\n\t if (frequency >= cp->task_freq)\n\t {\n\t\t cp->specific_info.wave_stamp += 1000. / (frequency * 2.);\n\t }\n\t else\n\t {\n\t\t cp->specific_info.wave_stamp += 1000. / (frequency * 4.);\n\t }\n\n\t return 0;\n }\n\n LOCAL void printProcessTripPulse(Print *cp, UINT32 frequency, UINT8 fan_index, UINT8 lit_line_index)\n {\n\t UINT16 j = 0, fan_wave_start = 0, index = 0;\n\n\t if (0 == fan_index)\n\t {\n\t\t fan_wave_start = 0;\n\t }\n\t else\n\t {\n\t\t fan_wave_start = cp->wave_data.stamp_dot_num[fan_index - 1];\n\t }\n\n\t index = lit_line_index;\n\n\t for (j = 0; j < cp->each_page_pulse_num[cp->specific_info.base_index]; j++)\n\t {\n\t\t if (cp->wave_data.p_user_bin_buf[(fan_wave_start + index) * cp->wave_data.bin_int16_num +\n\t\t\t\t\t(cp->p_each_page_pulse_offset[cp->specific_info.base_index][j] >> 4)] &\n\t\t\t\t\t(1 << (cp->p_each_page_pulse_offset[cp->specific_info.base_index][j] & 0x0f)))\n\t\t {\n\t\t\t cp->specific_info.pulse_value |= (1 << j);\n\t\t }\n\t\t else\n\t\t {\n\t\t\t cp->specific_info.pulse_value &= ~(1 << j);\n\t\t }\n\t }\n\n\t if (frequency)\n\t {\n\t }\n\n\t return;\n }\n\n LOCAL void printWaveAmpInstant(Print *cp, UINT8 fan_index, INT32 print_line)\n {\n\t UINT16 i = 0, j = 0, k = 0, m = 0, n = 0, fan_wave_start = 0;\n\t FLOAT64 sign_value = 0., insert_sign_value = 0.;\n\t INT32 shift_width = 0, pos = 0;\n\t INT8 *local_ptr = s_local_ptr;\n\n\t if ((cp->specific_info.line_number >> 1) == print_line - 1)\n\t {\n\t\t return;\n\t }\n\n\t for (j = 0; j < cp->specific_info.group_num; j++)\n\t {\n\t\t for (k = 0; k < cp->specific_info.group_column_num[j]; k++)\n\t\t {\n\t\t\t n = 0;\n\t\t\t for (m = 0; m < j; m++)\n\t\t\t {\n\t\t\t\t n += cp->specific_info.group_column_num[m];\n\t\t\t }\n\n\t\t\t if (0 == fan_index)\n\t\t\t {\n\t\t\t\t fan_wave_start = 0;\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t fan_wave_start = cp->wave_data.stamp_dot_num[fan_index - 1];\n\t\t\t }\n\n\t\t\t // 实际采样点\n\t\t\t sign_value = cp->wave_data.p_analog_buf[(fan_wave_start + cp->specific_info.line_number / 2) * cp->wave_data.ana_num +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcp->specific_info.wave_shift[j][k]];\n\n\n\t\t\t sign_value = (sign_value * cp->wave_data.p_analog_coef_a[cp->specific_info.wave_shift[j][k]]\n\t\t\t\t\t\t\t\t+ cp->wave_data.p_analog_coef_b[cp->specific_info.wave_shift[j][k]]);\n\n\t\t\t // 防止越限处理\n\t\t\t if (sign_value > 0)\n\t\t\t {\n\t\t\t\t if (sign_value > cp->specific_info.max_value[j])\n\t\t\t\t {\n\t\t\t\t\t sign_value = cp->specific_info.max_value[j];\n\t\t\t\t }\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t if ((-sign_value) > cp->specific_info.max_value[j])\n\t\t\t\t {\n\t\t\t\t\t sign_value = -cp->specific_info.max_value[j];\n\t\t\t\t }\n\t\t\t }\n\n\t\t\t if (cp->specific_info.max_value[j])\n\t\t\t {\n\t\t\t\t shift_width = sign_value * 2 * cp->specific_info.unit_width / cp->specific_info.max_value[j];\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t shift_width = 0;\n\t\t\t }\n\n\t\t\t pos = cp->specific_info.position[n + k + cp->each_page_pulse_num[cp->specific_info.base_index]] + shift_width;\n\t\t\t \n\t\t\t if (0 == cp->specific_info.line_number % 2)\n\t\t\t {\n\t\t\t\t *(local_ptr+(pos >> 3)) |= (1 << (7 - pos % 8));\n\t\t\t\t continue;\n\t\t\t }\n\n\t\t\t // 插值处理\n\t\t\t insert_sign_value = cp->wave_data.p_analog_buf[(fan_wave_start + cp->specific_info.line_number / 2 + 1) * cp->wave_data.ana_num +\n\t\t\t\t\t\t\t\t\tcp->specific_info.wave_shift[j][k]];\n\n\t\t\t insert_sign_value = (insert_sign_value * cp->wave_data.p_analog_coef_a[cp->specific_info.wave_shift[j][k]]\n\t\t\t\t\t\t\t\t\t+ cp->wave_data.p_analog_coef_b[cp->specific_info.wave_shift[j][k]]);\n\n\t\t\t // 防止越限处理\n\t\t\t if (insert_sign_value > 0)\n\t\t\t {\n\t\t\t\t if (insert_sign_value > cp->specific_info.max_value[j])\n\t\t\t\t {\n\t\t\t\t\t insert_sign_value = cp->specific_info.max_value[j];\n\t\t\t\t }\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t if ((-insert_sign_value) > cp->specific_info.max_value[j])\n\t\t\t\t {\n\t\t\t\t\t insert_sign_value = -cp->specific_info.max_value[j];\n\t\t\t\t }\n\t\t\t }\n\n\t\t\t insert_sign_value = (sign_value + insert_sign_value) / 2;\n\n\t\t\t if (cp->specific_info.max_value[j])\n\t\t\t {\n\t\t\t\t shift_width = insert_sign_value * 2 * cp->specific_info.unit_width / cp->specific_info.max_value[j];\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t shift_width = 0;\n\t\t\t }\n\n\t\t\t pos = cp->specific_info.position[n + k + cp->each_page_pulse_num[cp->specific_info.base_index]] + shift_width;\n\n\t\t\t *(local_ptr+(pos >> 3)) |= (1 << (7 - pos % 8));\n\t\t }\n\t }\n\n\t return;\n }\n\n LOCAL void printWaveAmplitude(Print *cp, UINT8 fan_index, INT32 print_line)\n {\n\t UINT16 i = 0, j = 0, k = 0, m = 0, n = 0, local_left = 0, local_right = 0, fan_wave_start = 0;\n\t FLOAT64 sign_value = 0., shift_width = 0.;\n\t INT8 *local_ptr = s_local_ptr;\n\n\t // 每6行打印一个幅值\n\t if ((cp->specific_info.line_number == print_line - 1) || (0 != cp->specific_info.line_number % 6))\n\t {\n\t\t return;\n\t }\n\n\t for (j = 0; j < cp->specific_info.group_num; j++)\n\t {\n\t\t for (k = 0; k < cp->specific_info.group_column_num[j]; k++)\n\t\t {\n\t\t\t n = 0;\n\t\t\t for (m = 0; m < j; m++)\n\t\t\t {\n\t\t\t\t n += cp->specific_info.group_column_num[m];\n\t\t\t }\n\n\t\t\t if (0 == fan_index)\n\t\t\t {\n\t\t\t\t fan_wave_start = 0;\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t fan_wave_start = cp->wave_data.stamp_dot_num[fan_index - 1];\n\t\t\t }\n\n\t\t\t sign_value = cp->wave_data.p_analog_buf[(fan_wave_start + cp->specific_info.line_number)\n\t\t\t\t\t\t\t* cp->wave_data.ana_num + cp->specific_info.wave_shift[j][k]];\n\n\t\t\t sign_value = (sign_value * cp->wave_data.p_analog_coef_a[cp->specific_info.wave_shift[j][k]]\n\t\t\t\t\t\t\t+ cp->wave_data.p_analog_coef_b[cp->specific_info.wave_shift[j][k]]);\n\n\t\t\t // 越限处理\n\t\t\t if (sign_value > 0)\n\t\t\t {\n\t\t\t\t if (sign_value > cp->specific_info.max_value[j])\n\t\t\t\t {\n\t\t\t\t\t sign_value = cp->specific_info.max_value[j];\n\t\t\t\t }\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t if ((-sign_value) > cp->specific_info.max_value[j])\n\t\t\t\t {\n\t\t\t\t\t sign_value = -cp->specific_info.max_value[j];\n\t\t\t\t }\n\t\t\t }\n\n\t\t\t if (cp->specific_info.max_value[j])\n\t\t\t {\n\t\t\t\t shift_width = (sign_value * 2 * cp->specific_info.unit_width / cp->specific_info.max_value[j]);\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t shift_width = 0;\n\t\t\t }\n\n\t\t\t if (sign_value > 0)\n\t\t\t {\n\t\t\t\t local_left = cp->specific_info.position[n + k + cp->each_page_pulse_num[cp->specific_info.base_index]] - shift_width;\n\t\t\t\t local_right = cp->specific_info.position[n + k + cp->each_page_pulse_num[cp->specific_info.base_index]] + shift_width;\n\n\t\t\t\t for (m = local_left; m < local_right; m++)\n\t\t\t\t {\n\t\t\t\t\t *(local_ptr + (m >> 3)) |= 1 << (7 - m % 8);\n\t\t\t\t }\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t local_left = cp->specific_info.position[n + k + cp->each_page_pulse_num[cp->specific_info.base_index]] + shift_width;\n\t\t\t\t local_right = cp->specific_info.position[n + k + cp->each_page_pulse_num[cp->specific_info.base_index]];\n\n\t\t\t\t for (m = local_left; m < local_right; m++)\n\t\t\t\t {\n\t\t\t\t\t *(local_ptr + (m >> 3)) |= 1 << (7 - m % 8);\n\t\t\t\t }\n\t\t\t }\n\t\t }\n\t }\n\n\t return;\n }\n\n LOCAL void printSetWaveDotAxis(Print *cp, UINT8 end_line)\n {\n\t UINT16 i = 0;\n\t INT8 *local_ptr = NULL;\n\t INT32 bytes = 0, len = 0;\n\n\t // 设定光标纵向位移单位\n\t *cp->print_ptr++ = ESC;\n\t *cp->print_ptr++ = '&';\n\t *cp->print_ptr++ = 'l';\n\t *cp->print_ptr++ = '0';\n\t *cp->print_ptr++ = 'C';\n\n\t // 开始图形打印，ESC * r 1 A\n\t *cp->print_ptr++ = ESC;\n\t *cp->print_ptr++ = '*';\n\t *cp->print_ptr++ = 'r';\n\t *cp->print_ptr++ = '1';\n\t *cp->print_ptr++ = 'A';\n\n\t // 设置图形光栅数据大小，ESC * b 0 m # W ###......\n\t *cp->print_ptr++ = ESC;\n\t *cp->print_ptr++ = '*';\n\t *cp->print_ptr++ = 'b';\n\t *cp->print_ptr++ = '0';\n\t *cp->print_ptr++ = 'm';\n\t bytes = (cp->specific_info.graph_width + 7) >> 3;\n\t len = sprintf(cp->print_ptr, \"%d\", bytes);\n\t cp->print_ptr += len;\n\t *cp->print_ptr++ = 'W';\n\t s_local_ptr = cp->print_ptr;\n\t cp->print_ptr += bytes;\n\n\t // 清空图形打印缓存\n\t local_ptr = s_local_ptr;\n\t for (i = 0; i < bytes; i++)\n\t {\n\t\t *local_ptr++ = 0;\n\t }\n\n\t // 设定每路纵向零点\n\t local_ptr = s_local_ptr;\n\t for (i = 0; i < cp->each_page_pulse_num[cp->specific_info.base_index] +\n\t\t\t\t\t cp->each_page_analog_num[cp->specific_info.base_index]; i++)\n\t {\n\t\t *(local_ptr + (cp->specific_info.position[i] >> 3)) |= 1 << (7 - cp->specific_info.position[i] % 8);\n\t }\n\n\t // 结束图形打印， ESC * r C\n\t *cp->print_ptr++ = ESC;\n\t *cp->print_ptr++ = '*';\n\t *cp->print_ptr++ = 'r';\n\t *cp->print_ptr++ = 'C';\n\n\t if (end_line)\n\t {\n\t }\n\n\t return;\n }\n\n /* 打印自检报告 */\n LOCAL void printSelfsupervRpt(Print *cp)\n {\n\t if (PRINT_UART_PROTOCOL == cp->print_method)\n\t {\n\t\t printSelfsupervRptUart(cp);\n\t }\n\t else\n\t {\n\t\t printSelfsupervRptNet(cp);\n\t }\n\t \n\t return;\n }\n\nLOCAL void printSelfsupervRptUart(Print *cp)\n{\n\tUINT32 rpt_no_start = 0, rpt_no_end = 0;\n\tINT32 i = 0;\n\tUINT16 event_num = 0;\n\tEventData event_data = { 0 };\n\tHisEventReadCtrl read_ctrl = { 0 };\n\tINT32 offset = 0;\n\n\tevent_num = getInt16(cp->print_shm_content.print_para_val, &offset);\n\trpt_no_start = getInt32(cp->print_shm_content.print_para_val, &offset);\n\trpt_no_end = getInt32(cp->print_shm_content.print_para_val, &offset);\n\n\tprintHeaderLineUart(cp, slan_selfcheck_header_str.desc[cp->dev_cfg.lang_sel]);\n\tprintStrLine(cp, selfcheck_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\tprintStrLine(cp, selfcheck_line_tab1[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\tread_ctrl.start_no = rpt_no_start;\n\tread_ctrl.last_no = rpt_no_end;\n\tread_ctrl.order = 0;\n\n\tfor (i = 0; i < event_num; i++)\n\t{\n\t\tread_ctrl.off = i;\n\t\tif (0 == getHisEvent(EN_CHECK_EVENT, &read_ctrl, &event_data))\n\t\t{\n\t\t\tprintSelfsupervRptItem(cp, &event_data);\n\t\t}\n\t}\n\n\tprintStrLine(cp, selfcheck_line_tab4[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\tprintCharLine(cp, WITH_RETURN);\n\n\treturn;\n}\n\nLOCAL void printSelfsupervRptNet(Print *cp)\n{\n\tUINT32 rpt_no_start = 0, rpt_no_end = 0;\n\tINT32 i = 0;\n\tUINT16 event_num = 0;\n\tEventData event_data = { 0 };\n\tHisEventReadCtrl read_ctrl = { 0 };\n\tINT32 offset = 0;\n\n\tevent_num = getInt16(cp->print_shm_content.print_para_val, &offset);\n\trpt_no_start = getInt32(cp->print_shm_content.print_para_val, &offset);\n\trpt_no_end = getInt32(cp->print_shm_content.print_para_val, &offset);\n\n\tprintHeaderLineNet(cp, slan_selfcheck_header_str.desc[cp->dev_cfg.lang_sel]);\n\tprintStrLine(cp, selfcheck_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\tprintStrLine(cp, selfcheck_line_tab1[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\tread_ctrl.start_no = rpt_no_start;\n\tread_ctrl.last_no = rpt_no_end;\n\tread_ctrl.order = 0;\n\n\tfor (i = 0; i < event_num; i++)\n\t{\n\t\tread_ctrl.off = i;\n\t\tif (0 == getHisEvent(EN_CHECK_EVENT, &read_ctrl, &event_data))\n\t\t{\n\t\t\tprintSelfsupervRptItem(cp, &event_data);\n\t\t}\n\t}\n\n\tprintStrLine(cp, selfcheck_line_tab4[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\tprintCharLine(cp, WITH_RETURN);\n\t\n\treturn;\n}\n\nLOCAL void printSelfsupervRptItem(Print *cp, EventData *p_data)\n{\n\tDataFields *p_datafield = NULL;\n\tINT8 time_str[32] = { 0 };\n\tPrintRefInfo *p_ref_info = NULL;\n\n\tprintStrLine(cp, selfcheck_line_tab2[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\tprintAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\tcp->print_ptr += 2;\n\n\tsprintf(cp->print_ptr, \"%04d\", p_data->data.sys_chk.no);\n\tcp->print_ptr += 4;\n\t*cp->print_ptr = ' ';\n\tcp->print_ptr += 2;\n\tprintAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\tcp->print_ptr += 3;\n\n\tlongSecAndVsecToManTime(p_data->data.sys_chk.t.sec, p_data->data.sys_chk.t.us, time_str);\n\tprintAddStrToBufAndModifyPtr(cp, time_str, strlen(time_str) + 2);\n\tprintAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\tcp->print_ptr += 3;\n\n\tcp->print_ptr += 7;\n\tprintAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\tcp->print_ptr += 8;\n\t\n\tp_ref_info = (PrintRefInfo *)s_ref_tbl_cfg[EN_REF_TBL_SELF_CHECK].p_ref_info;\n\tp_datafield = p_ref_info->p_item[p_data->data.sys_chk.st_no].p_datafield;\n\tif (p_datafield)\n\t{\n\t\tprintAddStrToBufAndModifyPtr(cp, p_datafield->desc, 38);\n\t}\n\telse\n\t{\n\t\tcp->print_ptr += 38;\n\t}\n\n\tprintAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\tcp->print_ptr += 2;\n\tif (p_data->data.sys_chk.st_val)\n\t{\n\t\tprintAddStrToBufAndModifyPtr(cp, clear_to_set_str[cp->print_method][cp->dev_cfg.lang_sel], 8);\n\t}\n\telse\n\t{\n\t\tprintAddStrToBufAndModifyPtr(cp, set_to_clear_str[cp->print_method][cp->dev_cfg.lang_sel], 8);\n\t}\n\n\tprintAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\tprintCharLine(cp, WITH_RETURN);\n\n\treturn;\n}\n\n /* 打印变位报告 */\n LOCAL void printBinchgRpt(Print *cp)\n {\n\t if (PRINT_UART_PROTOCOL == cp->print_method)\n\t {\n\t\t printBinchgRptUart(cp);\n\t }\n\t else\n\t {\n\t\t printBinchgRptNet(cp);\n\t }\n\n\t return;\n }\n\n LOCAL void printBinchgRptUart(Print *cp)\n {\n\t UINT32 rpt_no_start = 0, rpt_no_end = 0;\n\t INT32 i = 0;\n\t UINT16 event_num = 0;\n\t EventData event_data = { 0 };\n\t HisEventReadCtrl read_ctrl = { 0 };\n\t INT32 offset = 0;\n\n\t event_num = getInt16(cp->print_shm_content.print_para_val, &offset);\n\t rpt_no_start = getInt32(cp->print_shm_content.print_para_val, &offset);\n\t rpt_no_end = getInt32(cp->print_shm_content.print_para_val, &offset);\n\n\t printHeaderLineUart(cp, slan_binchg_header_str.desc[cp->dev_cfg.lang_sel]);\n\t printStrLine(cp, binchg_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t printStrLine(cp, binchg_line_tab1[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t read_ctrl.start_no = rpt_no_start;\n\t read_ctrl.last_no = rpt_no_end;\n\t read_ctrl.order = 0;\n\n\t for (i = 0; i < event_num; i++)\n\t {\n\t\t read_ctrl.off = i;\n\t\t if (0 == getHisEvent(EN_BI_EVENT, &read_ctrl, &event_data))\n\t\t {\n\t\t\t printBinchgRptItem(cp, &event_data);\n\t\t }\n\t }\n\n\t printStrLine(cp, binchg_line_tab4[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t printCharLine(cp, WITH_RETURN);\n\n\t return;\n }\n\n LOCAL void printBinchgRptNet(Print *cp)\n {\n\t UINT32 rpt_no_start = 0, rpt_no_end = 0;\n\t INT32 i = 0;\n\t UINT16 event_num = 0;\n\t EventData event_data = { 0 };\n\t HisEventReadCtrl read_ctrl = { 0 };\n\t INT32 offset = 0;\n\n\t event_num = getInt16(cp->print_shm_content.print_para_val, &offset);\n\t rpt_no_start = getInt32(cp->print_shm_content.print_para_val, &offset);\n\t rpt_no_end = getInt32(cp->print_shm_content.print_para_val, &offset);\n\n\t printHeaderLineNet(cp, slan_binchg_header_str.desc[cp->dev_cfg.lang_sel]);\n\t printStrLine(cp, binchg_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t printStrLine(cp, binchg_line_tab1[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t read_ctrl.start_no = rpt_no_start;\n\t read_ctrl.last_no = rpt_no_end;\n\t read_ctrl.order = 0;\n\n\t for (i = 0; i < event_num; i++)\n\t {\n\t\t read_ctrl.off = i;\n\t\t if (0 == getHisEvent(EN_BI_EVENT, &read_ctrl, &event_data))\n\t\t {\n\t\t\t printBinchgRptItem(cp, &event_data);\n\t\t }\n\t }\n\n\t printStrLine(cp, binchg_line_tab4[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t printCharLine(cp, WITH_RETURN);\n\t \n\t return;\n }\n\n LOCAL void printBinchgRptItem(Print *cp, EventData *p_data)\n {\n\t DataFields *p_datafield = NULL;\n\t INT8 time_str[32] = { 0 };\n\t PrintRefInfo *p_ref_info = NULL;\n\n\t printStrLine(cp, binchg_line_tab2[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t cp->print_ptr += 2;\n\n\t sprintf(cp->print_ptr, \"%04d\", p_data->data.bi.no);\n\t cp->print_ptr += 4;\n\t *cp->print_ptr = ' ';\n\t cp->print_ptr += 2;\n\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t cp->print_ptr += 4;\n\n\t longSecAndVsecToManTime(p_data->data.bi.t.sec, p_data->data.bi.t.us, time_str);\n\t printAddStrToBufAndModifyPtr(cp, time_str, strlen(time_str) + 9);\n\n\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t cp->print_ptr += 8;\n\n\t p_ref_info = (PrintRefInfo*)s_ref_tbl_cfg[EN_REF_TBL_BINCHG].p_ref_info;\n\t p_datafield = p_ref_info->p_item[p_data->data.bi.st_no].p_datafield;\n\t if(p_datafield)\n\t\t printAddStrToBufAndModifyPtr(cp, p_datafield->desc, 42);\n\t else\n\t\t cp->print_ptr += 42;\n\n\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t cp->print_ptr += 2;\n\t if( p_data->data.bi.st_val )\n\t\t printAddStrToBufAndModifyPtr(cp, clear_to_set_str[cp->print_method][cp->dev_cfg.lang_sel], 8);\n\t else\n\t\t printAddStrToBufAndModifyPtr(cp, set_to_clear_str[cp->print_method][cp->dev_cfg.lang_sel], 8);\n\n\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t printCharLine(cp, WITH_RETURN);\n\n\t return;\n }\n\n /* 打印SOE报告 */\n LOCAL void printSoeRpt(Print *cp)\n {\n\t if (PRINT_UART_PROTOCOL == cp->print_method)\n\t {\n\t\t printSoeRptUart(cp);\n\t }\n\t else\n\t {\n\t\t printSoeRptNet(cp);\n\t }\n\n\t return;\n }\n\n LOCAL void printSoeRptUart(Print *cp)\n {\n\t UINT32 rpt_no_start = 0, rpt_no_end = 0;\n\t INT32 i = 0;\n\t UINT16 event_num = 0;\n\t EventData event_data = { 0 };\n\t HisEventReadCtrl read_ctrl = { 0 };\n\t INT32 offset = 0;\n\n\t event_num = getInt16(cp->print_shm_content.print_para_val, &offset);\n\t rpt_no_start = getInt32(cp->print_shm_content.print_para_val, &offset);\n\t rpt_no_end = getInt32(cp->print_shm_content.print_para_val, &offset);\n\n\t printHeaderLineUart(cp, slan_soe_header_str.desc[cp->dev_cfg.lang_sel]);\n\t printStrLine(cp, soe_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t printStrLine(cp, soe_line_tab1[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t read_ctrl.start_no = rpt_no_start;\n\t read_ctrl.last_no = rpt_no_end;\n\t read_ctrl.order = 0;\n\n\t for (i = 0; i < event_num; i++)\n\t {\n\t\t read_ctrl.off = i;\n\t\t if (0 == getHisEvent(EN_YX_EVENT, &read_ctrl, &event_data))\n\t\t {\n\t\t\t printSoeRptItem(cp, &event_data);\n\t\t }\n\t }\n\n\t printStrLine(cp, soe_line_tab4[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t printCharLine(cp, WITH_RETURN);\n\n\t return;\n }\n\n LOCAL void printSoeRptNet(Print *cp)\n {\n\t UINT32 rpt_no_start = 0, rpt_no_end = 0;\n\t INT32 i = 0;\n\t UINT16 event_num = 0;\n\t EventData event_data = { 0 };\n\t HisEventReadCtrl read_ctrl = { 0 };\n\t INT32 offset = 0;\n\n\t event_num = getInt16(cp->print_shm_content.print_para_val, &offset);\n\t rpt_no_start = getInt32(cp->print_shm_content.print_para_val, &offset);\n\t rpt_no_end = getInt32(cp->print_shm_content.print_para_val, &offset);\n\n\t printHeaderLineNet(cp, slan_soe_header_str.desc[cp->dev_cfg.lang_sel]);\n\t printStrLine(cp, soe_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t printStrLine(cp, soe_line_tab1[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t read_ctrl.start_no = rpt_no_start;\n\t read_ctrl.last_no = rpt_no_end;\n\t read_ctrl.order = 0;\n\n\t for (i = 0; i < event_num; i++)\n\t {\n\t\t read_ctrl.off = i;\n\t\t if (0 == getHisEvent(EN_YX_EVENT, &read_ctrl, &event_data))\n\t\t {\n\t\t\t printSoeRptItem(cp, &event_data);\n\t\t }\n\t }\n\n\t printStrLine(cp, soe_line_tab4[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t printCharLine(cp, WITH_RETURN);\n\n\t return;\n }\n\n LOCAL void printSoeRptItem(Print *cp, EventData *p_data)\n {\n\t DataFields *p_datafield = NULL;\n\t INT8 time_str[32] = { 0 };\n\t PrintRefInfo *p_ref_info = NULL;\n\n\t printStrLine(cp, soe_line_tab2[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t cp->print_ptr += 2;\n\n\t sprintf(cp->print_ptr, \"%04d\", p_data->data.yx.no);\n\t cp->print_ptr += 4;\n\t *cp->print_ptr = ' ';\n\t cp->print_ptr += 2;\n\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t cp->print_ptr += 4;\n\n\t longSecAndVsecToManTime(p_data->data.yx.t.sec, p_data->data.yx.t.us, time_str);\n\t printAddStrToBufAndModifyPtr(cp, time_str, strlen(time_str) + 9);\n\n\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t cp->print_ptr += 8;\n\n\t p_ref_info = (PrintRefInfo*)s_ref_tbl_cfg[EN_REF_TBL_YX].p_ref_info;\n\t p_datafield = p_ref_info->p_item[p_data->data.yx.st_no].p_datafield;\n\t if(p_datafield)\n\t\t printAddStrToBufAndModifyPtr(cp, p_datafield->desc, 42);\n\t else\n\t\t cp->print_ptr += 42;\n\n\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t cp->print_ptr += 2;\n\t if( p_data->data.yx.st_val )\n\t\t printAddStrToBufAndModifyPtr(cp, clear_to_set_str[cp->print_method][cp->dev_cfg.lang_sel], 8);\n\t else\n\t\t printAddStrToBufAndModifyPtr(cp, set_to_clear_str[cp->print_method][cp->dev_cfg.lang_sel], 8);\n\n\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t printCharLine(cp, WITH_RETURN);\n\n\t return;\n }\n\n /* 打印通道自检报告 */\n LOCAL void printChanSupervRpt(Print *cp)\n {\n\t if (PRINT_UART_PROTOCOL == cp->print_method)\n\t {\n\t\t printChanSupervRptUart(cp);\n\t }\n\t else\n\t {\n\t\t printChanSupervRptNet(cp);\n\t }\n\n\t return;\n }\n\n LOCAL void printChanSupervRptUart(Print *cp)\n {\n\t UINT32 rpt_no_start = 0, rpt_no_end = 0;\n\t INT32 i = 0;\n\t UINT16 event_num = 0;\n\t EventData event_data = { 0 };\n\t HisEventReadCtrl read_ctrl = { 0 };\n\t UINT8 chan_index = 0;\n\t INT32 chan_enum_val = 0;\n\t INT32 offset = 0;\n\n\t event_num = getInt16(cp->print_shm_content.print_para_val, &offset);\n\t rpt_no_start = getInt32(cp->print_shm_content.print_para_val, &offset);\n\t rpt_no_end = getInt32(cp->print_shm_content.print_para_val, &offset);\n\t chan_index = getChar(cp->print_shm_content.print_para_val, &offset);\n\n\t if(chan_index < PRINT_MAX_CHAN_NUM)\n\t\t printHeaderLineUart(cp, slan_chan_superv_header_str[chan_index].desc[cp->dev_cfg.lang_sel]);\n\t else\n\t\t printHeaderLineUart(cp, slan_chan_superv_header_str[0].desc[cp->dev_cfg.lang_sel]);\n\n\t printStrLine(cp, chan_superv_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t printStrLine(cp, chan_superv_line_tab1[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t read_ctrl.start_no = rpt_no_start;\n\t read_ctrl.last_no = rpt_no_end;\n\t read_ctrl.order = 0;\n\n\t for(i = 0; i < event_num; i++)\n\t {\n\t\t read_ctrl.off = i;\n\t\t if(chan_index == 0)\n\t\t {\n\t\t\t chan_enum_val = EN_CHAN_A_CHK_EVENT;\n\t\t }\n\t\t else if(chan_index == 1)\n\t\t {\n\t\t\t chan_enum_val = EN_CHAN_B_CHK_EVENT;\n\t\t }\n\t\t else if(chan_index == 2)\n\t\t {\n\t\t\t chan_enum_val = EN_CHAN_C_CHK_EVENT;\n\t\t }\n\t\t else if(chan_index == 3)\n\t\t {\n\t\t\t chan_enum_val = EN_CHAN_D_CHK_EVENT;\n\t\t }\n\t\t else\n\t\t {\n\t\t\t chan_enum_val = EN_CHAN_A_CHK_EVENT;\n\t\t }\n\n\t\t if(getHisEvent(chan_enum_val, &read_ctrl, &event_data) == 0)\n\t\t {\n\t\t\t printChanSupervRptItem(cp, &event_data, chan_index);\n\t\t }\n\t }\n\n\t printStrLine(cp, chan_superv_line_tab4[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t printCharLine(cp, WITH_RETURN);\n\n\t return;\n }\n\n LOCAL void printChanSupervRptNet(Print *cp)\n {\n\t UINT32 rpt_no_start = 0, rpt_no_end = 0;\n\t INT32 i = 0;\n\t UINT16 event_num = 0;\n\t EventData event_data = { 0 };\n\t HisEventReadCtrl read_ctrl = { 0 };\n\t UINT8 chan_index = 0;\n\t INT32 chan_enum_val = 0;\n\t INT32 offset = 0;\n\n\t event_num = getInt16(cp->print_shm_content.print_para_val, &offset);\n\t rpt_no_start = getInt32(cp->print_shm_content.print_para_val, &offset);\n\t rpt_no_end = getInt32(cp->print_shm_content.print_para_val, &offset);\n\t chan_index = getChar(cp->print_shm_content.print_para_val, &offset);\n\n\t if(chan_index < PRINT_MAX_CHAN_NUM)\n\t\t printHeaderLineNet(cp, slan_chan_superv_header_str[chan_index].desc[cp->dev_cfg.lang_sel]);\n\t else\n\t\t printHeaderLineNet(cp, slan_chan_superv_header_str[0].desc[cp->dev_cfg.lang_sel]);\n\n\t printStrLine(cp, chan_superv_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t printStrLine(cp, chan_superv_line_tab1[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t read_ctrl.start_no = rpt_no_start;\n\t read_ctrl.last_no = rpt_no_end;\n\t read_ctrl.order = 0;\n\n\t for(i = 0; i < event_num; i++)\n\t {\n\t\t read_ctrl.off = i;\n\t\t if(chan_index == 0)\n\t\t {\n\t\t\t chan_enum_val = EN_CHAN_A_CHK_EVENT;\n\t\t }\n\t\t else if(chan_index == 1)\n\t\t {\n\t\t\t chan_enum_val = EN_CHAN_B_CHK_EVENT;\n\t\t }\n\t\t else if(chan_index == 2)\n\t\t {\n\t\t\t chan_enum_val = EN_CHAN_C_CHK_EVENT;\n\t\t }\n\t\t else if(chan_index == 3)\n\t\t {\n\t\t\t chan_enum_val = EN_CHAN_D_CHK_EVENT;\n\t\t }\n\t\t else\n\t\t {\n\t\t\t chan_enum_val = EN_CHAN_A_CHK_EVENT;\n\t\t }\n\n\t\t if(getHisEvent(chan_enum_val, &read_ctrl, &event_data) == 0)\n\t\t {\n\t\t\t printChanSupervRptItem(cp, &event_data, chan_index);\n\t\t }\n\t }\n\n\t printStrLine(cp, chan_superv_line_tab4[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t printCharLine(cp, WITH_RETURN);\n\n\t return;\n }\n\n LOCAL void printChanSupervRptItem(Print *cp, EventData *p_data, INT8 chan_index)\n {\n\t INT32 j = 0, local_cnt = 0;\n\t INT8 time_str[32] = { 0 };\n\t PrintRefInfo *p_ref_info = NULL;\n\t RefParameterItems *p_ref_tbl_item = NULL;\n\n\t printStrLine(cp, chan_superv_line_tab2[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t cp->print_ptr += 2;\n\n\t sprintf(cp->print_ptr, \"%04d\", p_data->data.chan_chk.no);\n\t cp->print_ptr += 4;\n\t *cp->print_ptr = ' ';\n\t cp->print_ptr += 2;\n\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t cp->print_ptr += 4;\n\n\t longSecAndVsecToManTime(p_data->data.chan_chk.t.sec, p_data->data.chan_chk.t.us, time_str);\n\t printAddStrToBufAndModifyPtr(cp, time_str, strlen(time_str) + 5);\n\n\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t cp->print_ptr += 2;\n\n\t local_cnt = 0;\n\t p_ref_info = s_ref_tbl_cfg[EN_REF_TBL_CHAN_A_CHECK + chan_index].p_ref_info;\n\t p_ref_tbl_item = p_ref_info->p_tbl;\n\t for(j=0;j<p_ref_tbl_item->num;j++)\n\t {\n\t\t sprintf(cp->print_ptr + local_cnt * 5, \"%04X\", p_data->data.chan_chk.val[j] & 0xFFFF);\n\t\t *(cp->print_ptr + local_cnt * 5 + 4) = ' ';\n\t\t local_cnt++;\n\t }\n\t cp->print_ptr += 64;\n\n\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t printCharLine(cp, WITH_RETURN);\n\n\t return;\n }\n\n /* 打印通道统计报告 */\n LOCAL void printChanStatisRpt(Print *cp)\n {\n\t if (PRINT_UART_PROTOCOL == cp->print_method)\n\t {\n\t\t printChanStatisRptUart(cp);\n\t }\n\t else\n\t {\n\t\t printChanStatisRptNet(cp);\n\t }\n\n\t return;\n }\n\n LOCAL void printChanStatisRptUart(Print *cp)\n {\n\t UINT32 rpt_no_start = 0, rpt_no_end = 0;\n\t INT32 i = 0;\n\t UINT16 event_num = 0;\n\t EventData event_data = { 0 }, event_data_pre = { 0 };\n\t HisEventReadCtrl read_ctrl = { 0 }, read_ctrl_pre = { 0 };\n\t UINT8 chan_index = 0;\n\t INT32 chan_enum_val = 0;\n\t INT32 offset = 0;\n\n\t event_num = getInt16(cp->print_shm_content.print_para_val, &offset);\n\t rpt_no_start = getInt32(cp->print_shm_content.print_para_val, &offset);\n\t rpt_no_end = getInt32(cp->print_shm_content.print_para_val, &offset);\n\t chan_index = getChar(cp->print_shm_content.print_para_val, &offset);\n\n\t if(chan_index < PRINT_MAX_CHAN_NUM)\n\t\t printHeaderLineUart(cp, (slan_chan_statis_header_str[chan_index]).desc[cp->dev_cfg.lang_sel]);\n\t else\n\t\t printHeaderLineUart(cp, (slan_chan_statis_header_str[0]).desc[cp->dev_cfg.lang_sel]);\n\n\t printStrLine(cp, chan_statis_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t printStrLine(cp, chan_statis_line_tab1[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\n\t read_ctrl.start_no = rpt_no_start;\n\t read_ctrl.last_no = rpt_no_end;\n\t read_ctrl.order = 0;\n\n\t read_ctrl_pre.start_no = rpt_no_start;\n\t read_ctrl_pre.last_no = rpt_no_end;\n\t read_ctrl_pre.order = 0;\n\n\t for(i = 0; i < event_num; i++)\n\t {\n\t\t read_ctrl.off = i;\n\t\t if(i)\n\t\t\t read_ctrl_pre.off = i - 1;\n\t\t else\n\t\t\t read_ctrl_pre.off = i;\n\n\t\t if(chan_index == 0)\n\t\t {\n\t\t\t chan_enum_val = EN_CHAN_A_STAT_EVENT;\n\t\t }\n\t\t else if(chan_index == 1)\n\t\t {\n\t\t\t chan_enum_val = EN_CHAN_B_STAT_EVENT;\n\t\t }\n\t\t else if(chan_index == 2)\n\t\t {\n\t\t\t chan_enum_val = EN_CHAN_C_STAT_EVENT;\n\t\t }\n\t\t else if(chan_index == 3)\n\t\t {\n\t\t\t chan_enum_val = EN_CHAN_D_STAT_EVENT;\n\t\t }\n\t\t else\n\t\t {\n\t\t\t chan_enum_val = EN_CHAN_A_STAT_EVENT;\n\t\t }\n\n\t\t if( (getHisEvent(chan_enum_val, &read_ctrl, &event_data) == 0)\n\t\t\t && (getHisEvent(chan_enum_val, &read_ctrl_pre, &event_data_pre) == 0) )\n\t\t {\n\t\t\t printChanStatisticRptItem(cp,&event_data, &event_data_pre, chan_index, i);\n\t\t }\n\t }\n\n\t printStrLine(cp, chan_statis_line_tab4[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t printCharLine(cp, WITH_RETURN);\n\n\t return;\n }\n\n LOCAL void printChanStatisRptNet(Print *cp)\n {\n\t UINT32 rpt_no_start = 0, rpt_no_end = 0;\n\t INT32 i = 0;\n\t UINT16 event_num = 0;\n\t EventData event_data = { 0 }, event_data_pre = { 0 };\n\t HisEventReadCtrl read_ctrl = { 0 }, read_ctrl_pre = { 0 };\n\t UINT8 chan_index = 0;\n\t INT32 chan_enum_val = 0;\n\t INT32 offset = 0;\n\n\t event_num = getInt16(cp->print_shm_content.print_para_val, &offset);\n\t rpt_no_start = getInt32(cp->print_shm_content.print_para_val, &offset);\n\t rpt_no_end = getInt32(cp->print_shm_content.print_para_val, &offset);\n\t chan_index = getChar(cp->print_shm_content.print_para_val, &offset);\n\n\t if(chan_index < PRINT_MAX_CHAN_NUM)\n\t\t printHeaderLineNet(cp, (slan_chan_statis_header_str[chan_index]).desc[cp->dev_cfg.lang_sel]);\n\t else\n\t\t printHeaderLineNet(cp, (slan_chan_statis_header_str[0]).desc[cp->dev_cfg.lang_sel]);\n\n\t printStrLine(cp, chan_statis_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t printStrLine(cp, chan_statis_line_tab1[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\n\t read_ctrl.start_no = rpt_no_start;\n\t read_ctrl.last_no = rpt_no_end;\n\t read_ctrl.order = 0;\n\n\t read_ctrl_pre.start_no = rpt_no_start;\n\t read_ctrl_pre.last_no = rpt_no_end;\n\t read_ctrl_pre.order = 0;\n\n\t for(i = 0; i < event_num; i++)\n\t {\n\t\t read_ctrl.off = i;\n\t\t if(i)\n\t\t\t read_ctrl_pre.off = i - 1;\n\t\t else\n\t\t\t read_ctrl_pre.off = i;\n\n\t\t if(chan_index == 0)\n\t\t {\n\t\t\t chan_enum_val = EN_CHAN_A_STAT_EVENT;\n\t\t }\n\t\t else if(chan_index == 1)\n\t\t {\n\t\t\t chan_enum_val = EN_CHAN_B_STAT_EVENT;\n\t\t }\n\t\t else if(chan_index == 2)\n\t\t {\n\t\t\t chan_enum_val = EN_CHAN_C_STAT_EVENT;\n\t\t }\n\t\t else if(chan_index == 3)\n\t\t {\n\t\t\t chan_enum_val = EN_CHAN_D_STAT_EVENT;\n\t\t }\n\t\t else\n\t\t {\n\t\t\t chan_enum_val = EN_CHAN_A_STAT_EVENT;\n\t\t }\n\n\t\t if( (getHisEvent(chan_enum_val, &read_ctrl, &event_data) == 0)\n\t\t\t && (getHisEvent(chan_enum_val, &read_ctrl_pre, &event_data_pre) == 0) )\n\t\t {\n\t\t\t printChanStatisticRptItemNet(cp,&event_data, &event_data_pre, chan_index, i);\n\t\t }\n\t }\n\n\t printStrLine(cp, chan_statis_line_tab4[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t printCharLine(cp, WITH_RETURN);\n\n\t return;\n }\n\n LOCAL void printChanStatisticRptItem(Print *cp, EventData *p_data, EventData *p_data_pre, INT8 chan_index, INT8 unfirst_rpt)\n {\n\t INT32 i = 0;\n\t INT8 time_str[32] = { 0 }, local_buf[256] = { 0 };\n\t DataFields *p_datafield = NULL;\n\t InVar local_in_value = { 0 };\n\t PrintRefInfo *p_ref_info= NULL;\n\t RefParameterItems *p_ref_tbl_item= NULL;\n\n\t printStrLine(cp, chan_statistic_line_tab2[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t sprintf(cp->print_ptr, \"%04d\", p_data->data.chan_sta.no);\n\t cp->print_ptr += 4;\n\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t cp->print_ptr += 2;\n\n\t longSecAndVsecToManTime(p_data->data.chan_sta.t.sec, p_data->data.chan_sta.t.us, time_str);\n\t printAddStrToBufAndModifyPtr(cp, time_str, strlen(time_str) + 3);\n\n\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t p_ref_info = (PrintRefInfo*)s_ref_tbl_cfg[EN_REF_TBL_CHAN_A_STAT + chan_index].p_ref_info;\n\t p_datafield = p_ref_info->p_item[0].p_datafield;\n\n\t if(p_datafield)\n\t {\n\t\t printAddStrToBufAndModifyPtr(cp, p_datafield->desc, 22);\n\t }\n\t else\n\t {\n\t\t cp->print_ptr += 22;\n\t }\n\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t cp->print_ptr += 2;\n\t local_in_value.value = *((INT32*)&p_data->data.chan_sta.val[0]);\n\t printInvarFormatToBuffer(p_datafield, &local_in_value, cp->print_ptr\n\t\t ,cp->print_ptr+8-1, printGetInVar(EN_IN_SIG_PRIM_OR_SEC) - 1);\n\t cp->print_ptr += 9;    \n\t if(p_datafield)\n\t {\n\t\t printAddStrToBufAndModifyPtr(cp, p_datafield->unit, 3);\n\t }\n\t else\n\t {\n\t\t cp->print_ptr += 3;\n\t }\n\n\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t if(unfirst_rpt)\n\t {\n\t\t if(p_datafield)\n\t\t {\n\t\t\t strcpy(local_buf, p_datafield->desc);\n\t\t\t strcat(local_buf, slan_chan_statis_diff_str.desc[cp->dev_cfg.lang_sel]);\n\t\t\t printAddStrToBufAndModifyPtr(cp, local_buf, 22);\n\t\t }\n\t\t else\n\t\t {\n\t\t\t cp->print_ptr += 22;\n\t\t }\n\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t cp->print_ptr += 2;\n\n\t\t local_in_value.value = *((INT32*)&p_data->data.chan_sta.val[0])\n\t\t\t -*((INT32*)&p_data_pre->data.chan_sta.val[0]);\n\t\t printInvarFormatToBuffer(p_datafield, &local_in_value, cp->print_ptr\n\t\t\t ,cp->print_ptr+8-1, printGetInVar(EN_IN_SIG_PRIM_OR_SEC) - 1);\n\t\t cp->print_ptr += 9;\n\n\t\t if(p_datafield)\n\t\t {\n\t\t\t printAddStrToBufAndModifyPtr(cp, p_datafield->unit, 3);\n\t\t }\n\t\t else\n\t\t {\n\t\t\t cp->print_ptr += 3;\n\t\t }\n\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t }\n\t else\n\t {\n\t\t cp->print_ptr += 22;\n\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t cp->print_ptr += 14;\n\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t }\n\t printCharLine(cp, WITH_RETURN);\n\n\t p_ref_tbl_item = p_ref_info->p_tbl;\n\t for(i=1;i<p_ref_tbl_item->num;i++)\n\t {\n\t\t printStrLine(cp, chan_statistic_line_tab3[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t cp->print_ptr += 4;\n\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t cp->print_ptr += 28;\n\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t\t p_datafield = p_ref_info->p_item[i].p_datafield;\n\t\t if(p_datafield)\n\t\t {\n\t\t\t printAddStrToBufAndModifyPtr(cp, p_datafield->desc, 22);\n\t\t }\n\t\t else\n\t\t {\n\t\t\t cp->print_ptr += 22;\n\t\t }\n\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t\t cp->print_ptr += 2;\n\t\t local_in_value.value = *((INT32*)&p_data->data.chan_sta.val[i]);\n\t\t printInvarFormatToBuffer(p_datafield, &local_in_value, cp->print_ptr\n\t\t\t ,cp->print_ptr+8-1, printGetInVar(EN_IN_SIG_PRIM_OR_SEC) - 1);\n\t\t cp->print_ptr += 9;\n\n\t\t if(p_datafield)\n\t\t {\n\t\t\t printAddStrToBufAndModifyPtr(cp, p_datafield->unit, 3);\n\t\t }\n\t\t else\n\t\t {\n\t\t\t cp->print_ptr += 3;\n\t\t }\n\n\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t\t if(unfirst_rpt)\n\t\t {\n\t\t\t if(p_datafield)\n\t\t\t {\n\t\t\t\t strcpy(local_buf, p_datafield->desc);\n\t\t\t\t strcat(local_buf, slan_chan_statis_diff_str.desc[cp->dev_cfg.lang_sel]);\n\t\t\t\t printAddStrToBufAndModifyPtr(cp, local_buf, 22);\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t cp->print_ptr += 22;\n\t\t\t }\n\t\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t cp->print_ptr += 2;\n\n\t\t\t local_in_value.value = *((INT32*)&p_data->data.chan_sta.val[i])\n\t\t\t\t -*((INT32*)&p_data_pre->data.chan_sta.val[i]);\n\t\t\t printInvarFormatToBuffer(p_datafield, &local_in_value, cp->print_ptr\n\t\t\t\t ,cp->print_ptr+8-1, printGetInVar(EN_IN_SIG_PRIM_OR_SEC) - 1);\n\t\t\t cp->print_ptr += 9;\n\n\t\t\t if(p_datafield)\n\t\t\t {\n\t\t\t\t printAddStrToBufAndModifyPtr(cp, p_datafield->unit, 3);\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t cp->print_ptr += 3;\n\t\t\t }\n\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t }\n\t\t else\n\t\t {\n\t\t\t cp->print_ptr += 22;\n\t\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t cp->print_ptr += 14;\n\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t }\n\n\t\t printCharLine(cp,WITH_RETURN);\n\t }\n\n\t return;\n }\n\n LOCAL void printChanStatisticRptItemNet(Print *cp, EventData *p_data, EventData *p_data_pre, INT8 chan_index, INT8 unfirst_rpt)\n {\n\t INT32 i = 0;\n\t INT8 time_str[32] = { 0 }, local_buf[256] = { 0 };\n\t DataFields *p_datafield = NULL;\n\t InVar local_in_value = { 0 };\n\t PrintRefInfo *p_ref_info= NULL;\n\t RefParameterItems *p_ref_tbl_item= NULL;\n\n\t printStrLine(cp, chan_statistic_line_tab2[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t sprintf(cp->print_ptr, \"%04d\", p_data->data.chan_sta.no);\n\t cp->print_ptr += 4;\n\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n//\t cp->print_ptr += 2;\n\n\t longSecAndVsecToManTime(p_data->data.chan_sta.t.sec, p_data->data.chan_sta.t.us, time_str);\n\t printAddStrToBufAndModifyPtr(cp, time_str, strlen(time_str)+1);\n\n\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t p_ref_info = (PrintRefInfo*)s_ref_tbl_cfg[EN_REF_TBL_CHAN_A_STAT + chan_index].p_ref_info;\n\t p_datafield = p_ref_info->p_item[0].p_datafield;\n\n\t if(p_datafield)\n\t {\n\t\t printAddStrToBufAndModifyPtr(cp, p_datafield->desc, 22);\n\t }\n\t else\n\t {\n\t\t cp->print_ptr += 22;\n\t }\n\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t cp->print_ptr += 2;\n\t local_in_value.value = *((INT32*)&p_data->data.chan_sta.val[0]);\n\t printInvarFormatToBuffer(p_datafield, &local_in_value, cp->print_ptr\n\t\t ,cp->print_ptr+8-1, printGetInVar(EN_IN_SIG_PRIM_OR_SEC) - 1);\n\t cp->print_ptr += 9;    \n\t if(p_datafield)\n\t {\n\t\t printAddStrToBufAndModifyPtr(cp, p_datafield->unit, 3);\n\t }\n\t else\n\t {\n\t\t cp->print_ptr += 3;\n\t }\n\n\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t if(unfirst_rpt)\n\t {\n\t\t if(p_datafield)\n\t\t {\n\t\t\t strcpy(local_buf, p_datafield->desc);\n\t\t\t strcat(local_buf, slan_chan_statis_diff_str.desc[cp->dev_cfg.lang_sel]);\n\t\t\t printAddStrToBufAndModifyPtr(cp, local_buf, 22);\n\t\t }\n\t\t else\n\t\t {\n\t\t\t cp->print_ptr += 22;\n\t\t }\n\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t cp->print_ptr += 2;\n\n\t\t local_in_value.value = *((INT32*)&p_data->data.chan_sta.val[0])\n\t\t\t -*((INT32*)&p_data_pre->data.chan_sta.val[0]);\n\t\t printInvarFormatToBuffer(p_datafield, &local_in_value, cp->print_ptr\n\t\t\t ,cp->print_ptr+8-1, printGetInVar(EN_IN_SIG_PRIM_OR_SEC) - 1);\n\t\t cp->print_ptr += 9;\n\n\t\t if(p_datafield)\n\t\t {\n\t\t\t printAddStrToBufAndModifyPtr(cp, p_datafield->unit, 3);\n\t\t }\n\t\t else\n\t\t {\n\t\t\t cp->print_ptr += 3;\n\t\t }\n\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t }\n\t else\n\t {\n\t\t cp->print_ptr += 22;\n\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t cp->print_ptr += 14;\n\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t }\n\t printCharLine(cp, WITH_RETURN);\n\n\t p_ref_tbl_item = p_ref_info->p_tbl;\n\t for(i=1;i<p_ref_tbl_item->num;i++)\n\t {\n\t\t printStrLine(cp, chan_statistic_line_tab3[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t cp->print_ptr += 4;\n\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t cp->print_ptr += 24;\n\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t\t p_datafield = p_ref_info->p_item[i].p_datafield;\n\t\t if(p_datafield)\n\t\t {\n\t\t\t printAddStrToBufAndModifyPtr(cp, p_datafield->desc, 22);\n\t\t }\n\t\t else\n\t\t {\n\t\t\t cp->print_ptr += 22;\n\t\t }\n\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t\t cp->print_ptr += 2;\n\t\t local_in_value.value = *((INT32*)&p_data->data.chan_sta.val[i]);\n\t\t printInvarFormatToBuffer(p_datafield, &local_in_value, cp->print_ptr\n\t\t\t ,cp->print_ptr+8-1, printGetInVar(EN_IN_SIG_PRIM_OR_SEC) - 1);\n\t\t cp->print_ptr += 9;\n\n\t\t if(p_datafield)\n\t\t {\n\t\t\t printAddStrToBufAndModifyPtr(cp, p_datafield->unit, 3);\n\t\t }\n\t\t else\n\t\t {\n\t\t\t cp->print_ptr += 3;\n\t\t }\n\n\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t\t if(unfirst_rpt)\n\t\t {\n\t\t\t if(p_datafield)\n\t\t\t {\n\t\t\t\t strcpy(local_buf, p_datafield->desc);\n\t\t\t\t strcat(local_buf, slan_chan_statis_diff_str.desc[cp->dev_cfg.lang_sel]);\n\t\t\t\t printAddStrToBufAndModifyPtr(cp, local_buf, 22);\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t cp->print_ptr += 22;\n\t\t\t }\n\t\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t cp->print_ptr += 2;\n\n\t\t\t local_in_value.value = *((INT32*)&p_data->data.chan_sta.val[i])\n\t\t\t\t -*((INT32*)&p_data_pre->data.chan_sta.val[i]);\n\t\t\t printInvarFormatToBuffer(p_datafield, &local_in_value, cp->print_ptr\n\t\t\t\t ,cp->print_ptr+8-1, printGetInVar(EN_IN_SIG_PRIM_OR_SEC) - 1);\n\t\t\t cp->print_ptr += 9;\n\n\t\t\t if(p_datafield)\n\t\t\t {\n\t\t\t\t printAddStrToBufAndModifyPtr(cp, p_datafield->unit, 3);\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t cp->print_ptr += 3;\n\t\t\t }\n\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t }\n\t\t else\n\t\t {\n\t\t\t cp->print_ptr += 22;\n\t\t\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t\t cp->print_ptr += 14;\n\t\t\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t\t }\n\n\t\t printCharLine(cp,WITH_RETURN);\n\t }\n\n\t return;\n }\n\n /* 打印103规约 */\n LOCAL void printIec103Proto(Print *cp)\n {\n\t if (PRINT_UART_PROTOCOL == cp->print_method)\n\t {\n\t\t printIec103ProtoUart(cp);\n\t }\n\t else\n\t {\n\t\t printIec103ProtoNet(cp);\n\t }\n\n\t return;\n }\n\n LOCAL void printIec103ProtoUart(Print *cp)\n {\n\t FILE *fp = NULL;\n\n\t fp = fopen(\"/shr/103inf.txt\",\"r\");\n\t if(fp == NULL) \n\t {\n\t\t PRINTINFO(CONSOLE_SHOW, \"[print]: (_func_pritnIec103ProtoNet) Open file failed!\\n\");\n\t\t return;\n\t }\n\n\t while(1)\n\t {\n\t\t if( fgets(cp->component_buf, 8192, fp) == NULL )\n\t\t {\n\t\t\t fclose(fp);\n\t\t\t return;\n\t\t }\n\n\t\t if(feof(fp)) \n\t\t {\n\t\t\t break;\n\t\t }\n\n\t\t printAddStrToBuf(cp, cp->component_buf);\n\t\t printCharLine(cp, WITH_RETURN);\n\t }\n\n\t fclose(fp);\n\n\t return;\n }\n\n LOCAL void printIec103ProtoNet(Print *cp)\n {\n\t FILE *fp = NULL;\n\n\t fp = fopen(\"/shr/103inf.txt\",\"r\");\n\t if(fp == NULL) \n\t {\n\t\t PRINTINFO(CONSOLE_SHOW, \"[print]: (_func_pritnIec103ProtoNet) Open file failed!\\n\");\n\t\t return;\n\t }\n\n\t while(1)\n\t {\n\t\t if( fgets(cp->component_buf, 8192, fp) == NULL )\n\t\t {\n\t\t\t fclose(fp);\n\t\t\t return;\n\t\t }\n\n\t\t if(feof(fp)) \n\t\t {\n\t\t\t break;\n\t\t }\n\n\t\t printAddStrToBuf(cp, cp->component_buf);\n\t\t printCharLine(cp, WITH_RETURN);\n\t }\n\n\t fclose(fp);\n\n\t return;\n }\n\n /* 打印操作报告 */\n LOCAL void printOpRpt(Print *cp)\n {\n\t if (PRINT_UART_PROTOCOL == cp->print_method)\n\t {\n\t\t printOpRptUart(cp);\n\t }\n\t else\n\t {\n\t\t printOpRptNet(cp);\n\t }\n\n\t return;\n }\n\n LOCAL void printOpRptUart(Print *cp)\n {\n\t UINT32 rpt_no_start = 0, rpt_no_end = 0;\n\t INT32 i = 0;\n\t UINT16 event_num = 0;\n\t EventData event_data = { 0 };\n\t HisEventReadCtrl read_ctrl = { 0 };\n\t INT32 opt_enum_val = 0;\n\t INT32 offset = 0;\n\n\t event_num = getInt16(cp->print_shm_content.print_para_val, &offset);\n\t rpt_no_start = getInt32(cp->print_shm_content.print_para_val, &offset);\n\t rpt_no_end = getInt32(cp->print_shm_content.print_para_val, &offset);\n\n\t printHeaderLineUart(cp, slan_op_header_str.desc[cp->dev_cfg.lang_sel]);\n\n\t printStrLine(cp, op_statis_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t printStrLine(cp, op_statis_line_tab1[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\n\t read_ctrl.start_no = rpt_no_start;\n\t read_ctrl.last_no = rpt_no_end;\n\t read_ctrl.order = 0;\n\n\t for(i=0;i<event_num;i++)\n\t {\n\t\t read_ctrl.off = i;\n\n\t\t opt_enum_val = EN_ORDER_EVENT;\n\t\t if( (getHisEvent(opt_enum_val, &read_ctrl, &event_data) == 0))\n\t\t {\n\t\t\t printOneOpRpt(cp,&event_data);\n\t\t }\n\t }\n\n\t printStrLine(cp, op_statis_line_tab4[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t printCharLine(cp, WITH_RETURN);\n\n\t return;\n }\n\n LOCAL void printOpRptNet(Print *cp)\n {\n\t UINT32 rpt_no_start = 0, rpt_no_end = 0;\n\t INT32 i = 0;\n\t UINT16 event_num = 0;\n\t EventData event_data = { 0 };\n\t HisEventReadCtrl read_ctrl = { 0 };\n\t INT32 opt_enum_val = 0;\n\t INT32 offset = 0;\n\n\t event_num = getInt16(cp->print_shm_content.print_para_val, &offset);\n\t rpt_no_start = getInt32(cp->print_shm_content.print_para_val, &offset);\n\t rpt_no_end = getInt32(cp->print_shm_content.print_para_val, &offset);\n\n\t printHeaderLineNet(cp, slan_op_header_str.desc[cp->dev_cfg.lang_sel]);\n\n\t printStrLine(cp, op_statis_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t printStrLine(cp, op_statis_line_tab1[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\n\t read_ctrl.start_no = rpt_no_start;\n\t read_ctrl.last_no = rpt_no_end;\n\t read_ctrl.order = 0;\n\n\t for(i=0;i<event_num;i++)\n\t {\n\t\t read_ctrl.off = i;\n\n\t\t opt_enum_val = EN_ORDER_EVENT;\n\t\t if( (getHisEvent(opt_enum_val, &read_ctrl, &event_data) == 0))\n\t\t {\n\t\t\t printOneOpRptNet(cp,&event_data);\n\t\t }\n\t }\n\n\t printStrLine(cp, op_statis_line_tab4[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t printCharLine(cp, WITH_RETURN);\n\n\t return;\n }\n\n LOCAL void printOneOpRpt(Print *cp, EventData *p_data)\n {\n\t DataFields *p_datafield = NULL;\n\t INT8 time_str[32] = { 0 };\n\t PrintRefInfo *p_ref_info = NULL;\n\n\t printStrLine(cp, op_line_tab2[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t sprintf(cp->print_ptr, \"%04d\", p_data->data.order.no);\n\t cp->print_ptr += 4;\n\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t longSecAndVsecToManTime(p_data->data.order.t.sec, p_data->data.order.t.us, time_str);\n\t printAddStrToBufAndModifyPtr(cp, time_str, strlen(time_str) + 1);\n\n\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t switch(p_data->data.order.inf.ctrl_type)\n\t {\n\t case 1:\n\t\t p_ref_info = (PrintRefInfo*)s_ref_tbl_cfg[EN_REF_TBL_YK].p_ref_info;\n\t\t break;\n\n\t case 2:\n\t\t p_ref_info = (PrintRefInfo*)s_ref_tbl_cfg[EN_REF_TBL_YS].p_ref_info;\n\t\t break;\n\n\t case 3:\n\t\t p_ref_info = (PrintRefInfo*)s_ref_tbl_cfg[EN_REF_TBL_YT].p_ref_info;\n\t\t break;\n\n\t default:\n\t\t return;\n\t }\n\n\t p_datafield = p_ref_info->p_item[p_data->data.order.inf.index].p_datafield;\n\t if(p_datafield)\n\t {\n\t\t printAddStrToBufAndModifyPtr(cp, p_datafield->desc, 20);\n\t }\n\t else\n\t {\n\t\t cp->print_ptr += 20;\n\t }\n\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t switch(p_data->data.order.inf.ctrl_cause)\n\t {\n\t case OBJ_ON_BUSY:\n\t\t printAddStrToBufAndModifyPtr(cp, slan_op_ctrl_result[0].desc[cp->dev_cfg.lang_sel], 16);\n\t\t break;\n\n\t case CTRL_INVALID:\n\t\t printAddStrToBufAndModifyPtr(cp, slan_op_ctrl_result[1].desc[cp->dev_cfg.lang_sel], 16);\n\t\t break;\n\n\t case EXE_TIME_OUT:\n\t\t printAddStrToBufAndModifyPtr(cp, slan_op_ctrl_result[2].desc[cp->dev_cfg.lang_sel], 16);\n\t\t break;\n\n\t case DEV_STATUS_BS:\n\t\t printAddStrToBufAndModifyPtr(cp, slan_op_ctrl_result[3].desc[cp->dev_cfg.lang_sel], 16);\n\t\t break;\n\n\t case DEV_LOCAL_CTRL:\n\t\t printAddStrToBufAndModifyPtr(cp, slan_op_ctrl_result[4].desc[cp->dev_cfg.lang_sel], 16);\n\t\t break;\n\n\t case DEV_TEST:\n\t\t printAddStrToBufAndModifyPtr(cp, slan_op_ctrl_result[5].desc[cp->dev_cfg.lang_sel], 16);\n\t\t break;\n\n\t case ERROR_OPTION_VALUE:\n\t\t printAddStrToBufAndModifyPtr(cp, slan_op_ctrl_result[6].desc[cp->dev_cfg.lang_sel], 16);\n\t\t break;\n\n\t case ERROR_SEL_VALUE:\n\t\t printAddStrToBufAndModifyPtr(cp, slan_op_ctrl_result[7].desc[cp->dev_cfg.lang_sel], 16);\n\t\t break;\n\n\t case ERROR_CLOSE_TYPE:\n\t\t printAddStrToBufAndModifyPtr(cp, slan_op_ctrl_result[8].desc[cp->dev_cfg.lang_sel], 16);\n\t\t break;\n\n\t case ERROR_RELATION_CONDITIION:\n\t\t printAddStrToBufAndModifyPtr(cp, slan_op_ctrl_result[9].desc[cp->dev_cfg.lang_sel], 16);\n\t\t break;\n\n\t case ERROR_SYNC_CONDITIION:\n\t\t printAddStrToBufAndModifyPtr(cp, slan_op_ctrl_result[10].desc[cp->dev_cfg.lang_sel], 16);\n\t\t break;\n\n\t case ERROR_U_LOW:\n\t\t printAddStrToBufAndModifyPtr(cp, slan_op_ctrl_result[11].desc[cp->dev_cfg.lang_sel], 16);\n\t\t break;\n\n\t case ERROR_PTDX:\n\t\t printAddStrToBufAndModifyPtr(cp, slan_op_ctrl_result[12].desc[cp->dev_cfg.lang_sel], 16);\n\t\t break;\n\n\t case ERROR_VDIF:\n\t\t printAddStrToBufAndModifyPtr(cp, slan_op_ctrl_result[13].desc[cp->dev_cfg.lang_sel], 16);\n\t\t break;\n\n\t case ERROR_FDIF:\n\t\t printAddStrToBufAndModifyPtr(cp, slan_op_ctrl_result[14].desc[cp->dev_cfg.lang_sel], 16);\n\t\t break;\n\n\t case ERROR_DFDIF:\n\t\t printAddStrToBufAndModifyPtr(cp, slan_op_ctrl_result[15].desc[cp->dev_cfg.lang_sel], 16);\n\t\t break;\n\n\t case ERROR_ADIF:\n\t\t printAddStrToBufAndModifyPtr(cp, slan_op_ctrl_result[16].desc[cp->dev_cfg.lang_sel], 16);\n\t\t break;\n\n\t case ERROR_U_HIG:\n\t\t printAddStrToBufAndModifyPtr(cp, slan_op_ctrl_result[17].desc[cp->dev_cfg.lang_sel], 16);\n\t\t break;\n\n\t case ERROR_U_CONDITIION:\n\t\t printAddStrToBufAndModifyPtr(cp, slan_op_ctrl_result[18].desc[cp->dev_cfg.lang_sel], 16);\n\t\t break;\n\n\t case CTRL_SUCCESS:\n\t\t printAddStrToBufAndModifyPtr(cp, slan_op_ctrl_result[19].desc[cp->dev_cfg.lang_sel], 16);\n\t\t break;\n\n\t default:\n\t\t printAddStrToBufAndModifyPtr(cp, \" \", 16);\n\t\t break;\n\t }\n\n\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t if((1 == p_data->data.order.inf.ctrl_type) && \n\t\t (0x02 == p_data->data.order.inf.ctrl_value.l_value & 0x03))\n\t {\n\t\t switch(p_data->data.order.inf.ctrl_para)\n\t\t {\n\t\t case 0x00:\n\t\t\t printAddStrToBufAndModifyPtr(cp,slan_op_ctrl_para[0].desc[cp->dev_cfg.lang_sel],8);\n\t\t\t break;\n\n\t\t case 0x03:\n\t\t\t printAddStrToBufAndModifyPtr(cp,slan_op_ctrl_para[1].desc[cp->dev_cfg.lang_sel],8);\n\t\t\t break;\n\n\t\t case 0x01:\n\t\t\t printAddStrToBufAndModifyPtr(cp,slan_op_ctrl_para[2].desc[cp->dev_cfg.lang_sel],8);\n\t\t\t break;\n\n\t\t case 0x02:\n\t\t\t printAddStrToBufAndModifyPtr(cp,slan_op_ctrl_para[3].desc[cp->dev_cfg.lang_sel],8);\n\t\t\t break;\n\n\t\t default:\n\t\t\t printAddStrToBufAndModifyPtr(cp,\"    /    \",8);\n\t\t\t break;\n\t\t }\n\t }\n\t else \n\t {\n\t\t printAddStrToBufAndModifyPtr(cp,\"    /    \",8);\n\t }\n\n\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t if(1 == p_data->data.order.inf.ctrl_type)\n\t {\n\t\t switch(p_data->data.order.inf.ctrl_value.l_value & 0x03)\n\t\t {\n\t\t case 0x01:\n\t\t\t printAddStrToBufAndModifyPtr(cp,slan_op_statis_ctrl_direc[0].desc[cp->dev_cfg.lang_sel],8);\n\t\t\t break;\n\n\t\t case 0x02:\n\t\t\t printAddStrToBufAndModifyPtr(cp,slan_op_statis_ctrl_direc[1].desc[cp->dev_cfg.lang_sel],8);\n\t\t\t break;\n\n\t\t default:\n\t\t\t printAddStrToBufAndModifyPtr(cp,\" \",8);\n\t\t\t break;\n\t\t }\n\t }\n\t else if(2 == p_data->data.order.inf.ctrl_type)\n\t {\n\t\t sprintf(cp->print_ptr,\"%08f\",p_data->data.order.inf.ctrl_value.f_value);\n\t\t cp->print_ptr += 8;\n\t }\n\t else if(3 == p_data->data.order.inf.ctrl_type)\n\t {\n\t\t switch(p_data->data.order.inf.ctrl_value.l_value & 0x03)\n\t\t {\n\t\t case 0x00:\n\t\t\t printAddStrToBufAndModifyPtr(cp,slan_op_statis_ctrl_direc[2].desc[cp->dev_cfg.lang_sel],8);\n\t\t\t break;\n\n\t\t case 0x01:\n\t\t\t printAddStrToBufAndModifyPtr(cp,slan_op_statis_ctrl_direc[3].desc[cp->dev_cfg.lang_sel],8);\n\t\t\t break;\n\n\t\t case 0x02:\n\t\t\t printAddStrToBufAndModifyPtr(cp,slan_op_statis_ctrl_direc[4].desc[cp->dev_cfg.lang_sel],8);\n\t\t\t break;\n\n\t\t default:\n\t\t\t printAddStrToBufAndModifyPtr(cp,\" \",8);\n\t\t\t break;\n\t\t }\n\t }\n\t else \n\t {\n\t\t printAddStrToBufAndModifyPtr(cp,\" \",8);\n\t }\n\n\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);  \n\t switch(p_data->data.order.inf.ctrl_step)\n\t {\n\t case SELECT:\n\t\t printAddStrToBufAndModifyPtr(cp,slan_op_statis_ctrl_step[1].desc[cp->dev_cfg.lang_sel],4);\n\t\t break;\n\n\t case EXECUTE:\n\t\t printAddStrToBufAndModifyPtr(cp,slan_op_statis_ctrl_step[2].desc[cp->dev_cfg.lang_sel],4);\n\t\t break;\n\n\t case CANCEL:\n\t\t printAddStrToBufAndModifyPtr(cp,slan_op_statis_ctrl_step[3].desc[cp->dev_cfg.lang_sel],4);\n\t\t break;\n\n\t default:\n\t\t printAddStrToBufAndModifyPtr(cp,\" \",4);\n\t\t break;\n\t }\n\n\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t switch(p_data->data.order.inf.ctrl_src_id)\n\t {\n\t case IEC103:\n\t\t printAddStrToBufAndModifyPtr(cp,slan_op_statis_ctrl_type[0].desc[cp->dev_cfg.lang_sel],8);\n\t\t break;\n\n\t case IEC61850:\n\t\t printAddStrToBufAndModifyPtr(cp,slan_op_statis_ctrl_type[1].desc[cp->dev_cfg.lang_sel],8);\n\t\t break;\n\n\t case LCD:\n\t\t printAddStrToBufAndModifyPtr(cp,slan_op_statis_ctrl_type[2].desc[cp->dev_cfg.lang_sel],8);\n\t\t break;\n\n\t default:\n\t\t printAddStrToBufAndModifyPtr(cp,\" \",8);\n\t\t break;\n\t }\n\n\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t sprintf(cp->print_ptr,\"%06d\",(p_data->data.order.inf.ctrl_con_id & 0x0000ffff));\n\t cp->print_ptr += 6;\n\n\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t printCharLine(cp,WITH_RETURN);\n\n\t return;\n }\n\n LOCAL void printOneOpRptNet(Print *cp, EventData *p_data)\n {\n\t DataFields *p_datafield = NULL;\n\t INT8 time_str[32] = { 0 };\n\t PrintRefInfo *p_ref_info = NULL;\n\n\t printStrLine(cp, op_line_tab2[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\t sprintf(cp->print_ptr, \"%04d\", p_data->data.order.no);\n\t cp->print_ptr += 4;\n\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t longSecAndVsecToManTime(p_data->data.order.t.sec, p_data->data.order.t.us, time_str);\n\t printAddStrToBufAndModifyPtr(cp, time_str, strlen(time_str) + 1);\n\n\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t switch(p_data->data.order.inf.ctrl_type)\n\t {\n\t case 1:\n\t\t p_ref_info = (PrintRefInfo*)s_ref_tbl_cfg[EN_REF_TBL_YK].p_ref_info;\n\t\t break;\n\n\t case 2:\n\t\t p_ref_info = (PrintRefInfo*)s_ref_tbl_cfg[EN_REF_TBL_YS].p_ref_info;\n\t\t break;\n\n\t case 3:\n\t\t p_ref_info = (PrintRefInfo*)s_ref_tbl_cfg[EN_REF_TBL_YT].p_ref_info;\n\t\t break;\n\n\t default:\n\t\t return;\n\t }\n\n\t p_datafield = p_ref_info->p_item[p_data->data.order.inf.index].p_datafield;\n\t if(p_datafield)\n\t {\n\t\t printAddStrToBufAndModifyPtr(cp, p_datafield->desc, 20);\n\t }\n\t else\n\t {\n\t\t cp->print_ptr += 20;\n\t }\n\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t switch(p_data->data.order.inf.ctrl_cause)\n\t {\n\t case OBJ_ON_BUSY:\n\t\t printAddStrToBufAndModifyPtr(cp, slan_op_ctrl_result[0].desc[cp->dev_cfg.lang_sel], 16);\n\t\t break;\n\n\t case CTRL_INVALID:\n\t\t printAddStrToBufAndModifyPtr(cp, slan_op_ctrl_result[1].desc[cp->dev_cfg.lang_sel], 16);\n\t\t break;\n\n\t case EXE_TIME_OUT:\n\t\t printAddStrToBufAndModifyPtr(cp, slan_op_ctrl_result[2].desc[cp->dev_cfg.lang_sel], 16);\n\t\t break;\n\n\t case DEV_STATUS_BS:\n\t\t printAddStrToBufAndModifyPtr(cp, slan_op_ctrl_result[3].desc[cp->dev_cfg.lang_sel], 16);\n\t\t break;\n\n\t case DEV_LOCAL_CTRL:\n\t\t printAddStrToBufAndModifyPtr(cp, slan_op_ctrl_result[4].desc[cp->dev_cfg.lang_sel], 16);\n\t\t break;\n\n\t case DEV_TEST:\n\t\t printAddStrToBufAndModifyPtr(cp, slan_op_ctrl_result[5].desc[cp->dev_cfg.lang_sel], 16);\n\t\t break;\n\n\t case ERROR_OPTION_VALUE:\n\t\t printAddStrToBufAndModifyPtr(cp, slan_op_ctrl_result[6].desc[cp->dev_cfg.lang_sel], 16);\n\t\t break;\n\n\t case ERROR_SEL_VALUE:\n\t\t printAddStrToBufAndModifyPtr(cp, slan_op_ctrl_result[7].desc[cp->dev_cfg.lang_sel], 16);\n\t\t break;\n\n\t case ERROR_CLOSE_TYPE:\n\t\t printAddStrToBufAndModifyPtr(cp, slan_op_ctrl_result[8].desc[cp->dev_cfg.lang_sel], 16);\n\t\t break;\n\n\t case ERROR_RELATION_CONDITIION:\n\t\t printAddStrToBufAndModifyPtr(cp, slan_op_ctrl_result[9].desc[cp->dev_cfg.lang_sel], 16);\n\t\t break;\n\n\t case ERROR_SYNC_CONDITIION:\n\t\t printAddStrToBufAndModifyPtr(cp, slan_op_ctrl_result[10].desc[cp->dev_cfg.lang_sel], 16);\n\t\t break;\n\n\t case ERROR_U_LOW:\n\t\t printAddStrToBufAndModifyPtr(cp, slan_op_ctrl_result[11].desc[cp->dev_cfg.lang_sel], 16);\n\t\t break;\n\n\t case ERROR_PTDX:\n\t\t printAddStrToBufAndModifyPtr(cp, slan_op_ctrl_result[12].desc[cp->dev_cfg.lang_sel], 16);\n\t\t break;\n\n\t case ERROR_VDIF:\n\t\t printAddStrToBufAndModifyPtr(cp, slan_op_ctrl_result[13].desc[cp->dev_cfg.lang_sel], 16);\n\t\t break;\n\n\t case ERROR_FDIF:\n\t\t printAddStrToBufAndModifyPtr(cp, slan_op_ctrl_result[14].desc[cp->dev_cfg.lang_sel], 16);\n\t\t break;\n\n\t case ERROR_DFDIF:\n\t\t printAddStrToBufAndModifyPtr(cp, slan_op_ctrl_result[15].desc[cp->dev_cfg.lang_sel], 16);\n\t\t break;\n\n\t case ERROR_ADIF:\n\t\t printAddStrToBufAndModifyPtr(cp, slan_op_ctrl_result[16].desc[cp->dev_cfg.lang_sel], 16);\n\t\t break;\n\n\t case ERROR_U_HIG:\n\t\t printAddStrToBufAndModifyPtr(cp, slan_op_ctrl_result[17].desc[cp->dev_cfg.lang_sel], 16);\n\t\t break;\n\n\t case ERROR_U_CONDITIION:\n\t\t printAddStrToBufAndModifyPtr(cp, slan_op_ctrl_result[18].desc[cp->dev_cfg.lang_sel], 16);\n\t\t break;\n\n\t case CTRL_SUCCESS:\n\t\t printAddStrToBufAndModifyPtr(cp, slan_op_ctrl_result[19].desc[cp->dev_cfg.lang_sel], 16);\n\t\t break;\n\n\t default:\n\t\t printAddStrToBufAndModifyPtr(cp, \" \", 16);\n\t\t break;\n\t }\n\n\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t if((1 == p_data->data.order.inf.ctrl_type) && \n\t\t (0x02 == p_data->data.order.inf.ctrl_value.l_value & 0x03))\n\t {\n\t\t switch(p_data->data.order.inf.ctrl_para)\n\t\t {\n\t\t case 0x00:\n\t\t\t printAddStrToBufAndModifyPtr(cp,slan_op_ctrl_para[0].desc[cp->dev_cfg.lang_sel],8);\n\t\t\t break;\n\n\t\t case 0x03:\n\t\t\t printAddStrToBufAndModifyPtr(cp,slan_op_ctrl_para[1].desc[cp->dev_cfg.lang_sel],8);\n\t\t\t break;\n\n\t\t case 0x01:\n\t\t\t printAddStrToBufAndModifyPtr(cp,slan_op_ctrl_para[2].desc[cp->dev_cfg.lang_sel],8);\n\t\t\t break;\n\n\t\t case 0x02:\n\t\t\t printAddStrToBufAndModifyPtr(cp,slan_op_ctrl_para[3].desc[cp->dev_cfg.lang_sel],8);\n\t\t\t break;\n\n\t\t default:\n\t\t\t printAddStrToBufAndModifyPtr(cp,\"    /    \",8);\n\t\t\t break;\n\t\t }\n\t }\n\t else \n\t {\n\t\t printAddStrToBufAndModifyPtr(cp,\"    /    \",8);\n\t }\n\n\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t if(1 == p_data->data.order.inf.ctrl_type)\n\t {\n\t\t switch(p_data->data.order.inf.ctrl_value.l_value & 0x03)\n\t\t {\n\t\t case 0x01:\n\t\t\t printAddStrToBufAndModifyPtr(cp,slan_op_statis_ctrl_direc[0].desc[cp->dev_cfg.lang_sel],2);\n\t\t\t break;\n\n\t\t case 0x02:\n\t\t\t printAddStrToBufAndModifyPtr(cp,slan_op_statis_ctrl_direc[1].desc[cp->dev_cfg.lang_sel],2);\n\t\t\t break;\n\n\t\t default:\n\t\t\t printAddStrToBufAndModifyPtr(cp,\" \",2);\n\t\t\t break;\n\t\t }\n\t }\n\t else if(2 == p_data->data.order.inf.ctrl_type)\n\t {\n\t\t sprintf(cp->print_ptr,\"%02f\",p_data->data.order.inf.ctrl_value.f_value);\n\t\t cp->print_ptr += 2;\n\t }\n\t else if(3 == p_data->data.order.inf.ctrl_type)\n\t {\n\t\t switch(p_data->data.order.inf.ctrl_value.l_value & 0x03)\n\t\t {\n\t\t case 0x00:\n\t\t\t printAddStrToBufAndModifyPtr(cp,slan_op_statis_ctrl_direc[2].desc[cp->dev_cfg.lang_sel],2);\n\t\t\t break;\n\n\t\t case 0x01:\n\t\t\t printAddStrToBufAndModifyPtr(cp,slan_op_statis_ctrl_direc[3].desc[cp->dev_cfg.lang_sel],2);\n\t\t\t break;\n\n\t\t case 0x02:\n\t\t\t printAddStrToBufAndModifyPtr(cp,slan_op_statis_ctrl_direc[4].desc[cp->dev_cfg.lang_sel],2);\n\t\t\t break;\n\n\t\t default:\n\t\t\t printAddStrToBufAndModifyPtr(cp,\" \",2);\n\t\t\t break;\n\t\t }\n\t }\n\t else \n\t {\n\t\t printAddStrToBufAndModifyPtr(cp,\" \",2);\n\t }\n\n\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);  \n\t switch(p_data->data.order.inf.ctrl_step)\n\t {\n\t case SELECT:\n\t\t printAddStrToBufAndModifyPtr(cp,slan_op_statis_ctrl_step[1].desc[cp->dev_cfg.lang_sel],4);\n\t\t break;\n\n\t case EXECUTE:\n\t\t printAddStrToBufAndModifyPtr(cp,slan_op_statis_ctrl_step[2].desc[cp->dev_cfg.lang_sel],4);\n\t\t break;\n\n\t case CANCEL:\n\t\t printAddStrToBufAndModifyPtr(cp,slan_op_statis_ctrl_step[3].desc[cp->dev_cfg.lang_sel],4);\n\t\t break;\n\n\t default:\n\t\t printAddStrToBufAndModifyPtr(cp,\" \",4);\n\t\t break;\n\t }\n\n\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t switch(p_data->data.order.inf.ctrl_src_id)\n\t {\n\t case IEC103:\n\t\t printAddStrToBufAndModifyPtr(cp,slan_op_statis_ctrl_type[0].desc[cp->dev_cfg.lang_sel],8);\n\t\t break;\n\n\t case IEC61850:\n\t\t printAddStrToBufAndModifyPtr(cp,slan_op_statis_ctrl_type[1].desc[cp->dev_cfg.lang_sel],8);\n\t\t break;\n\n\t case LCD:\n\t\t printAddStrToBufAndModifyPtr(cp,slan_op_statis_ctrl_type[2].desc[cp->dev_cfg.lang_sel],8);\n\t\t break;\n\n\t default:\n\t\t printAddStrToBufAndModifyPtr(cp,\" \",8);\n\t\t break;\n\t }\n\n\t printAddStrToBuf(cp, print_char_tab2[cp->print_method][cp->dev_cfg.lang_sel]);\n\t sprintf(cp->print_ptr,\"%06d\",(p_data->data.order.inf.ctrl_con_id & 0x0000ffff));\n\t cp->print_ptr += 6;\n\n\t printAddStrToBuf(cp, print_char_tab1[cp->print_method][cp->dev_cfg.lang_sel]);\n\n\t printCharLine(cp,WITH_RETURN);\n\n\t return;\n }\n\n /* 打印信息头 */\n LOCAL void printHeaderLineUart(Print *cp, INT8 *header_str)\n {\n\t UINT8 total_length = 0, middle_start = 0;\n\t INT8 time_str[32] = { 0 }, local_buf[32] = { 0 };\n\t INT8 *p_equip_name = NULL;\n\t DataFields *p_datafield = NULL;\n\t DevInfo *p_dev_inf = NULL;\n\n\t p_dev_inf = getDevInfo();\n\t if (NULL == p_dev_inf)\n\t {\n\t\t return;\n\t }\n\n\t total_length = strlen(p_dev_inf->dev_type) + strlen(p_dev_inf->dev_name)\n\t\t + strlen(title_line_line[cp->print_method][cp->dev_cfg.lang_sel])\n\t\t + strlen(header_str);\n\n\t if (total_length < PRINT_LINE_CHAR_LEN / 2)\n\t {\n\t\t // 倍宽打印\n\t\t *cp->print_ptr++ = 0x1c;\n\t\t *cp->print_ptr++ = 0x0e;\n\t\t middle_start = (PRINT_LINE_CHAR_LEN / 2 - total_length) / 2;\n\t }\n\t else\n\t {\n\t\t middle_start = (PRINT_LINE_CHAR_LEN - total_length) / 2;\n\t }\n\n\t // 居中\n\t memset(cp->print_ptr, ' ', middle_start);\n\t cp->print_ptr += middle_start;\n\n\t printAddStrToBuf(cp, p_dev_inf->dev_type);\n\t printAddStrToBuf(cp, \" \");\n\t printAddStrToBuf(cp, p_dev_inf->dev_name);\n\t printAddStrToBuf(cp, title_line_line[cp->print_method][cp->dev_cfg.lang_sel]);\n\t printAddStrToBuf(cp, header_str);\n\n\t // 取消倍宽打印\n\t *cp->print_ptr++ = 0x1c;\n\t *cp->print_ptr++ = 0x14;\n\t printCharLine(cp, WITH_RETURN);\n\n\t // 分割线\n\t printStrLine(cp, title_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t // 第一行，厂站名称\n\t cp->print_ptr += 2;\n\t sprintf(local_buf, \"B%02d.print.station_name\", my_addr);\n\t p_datafield = getParameterWithName(local_buf);\n\t if (NULL == p_datafield)\n\t {\n\t\t PRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printHeaderLine) Get parameter err!\\n\");\n\t\t return;\n\t }\n\n\t printAddStrToBuf(cp, p_datafield->desc);\n\t printAddStrToBuf(cp, \":\");\n\t printAddStrToBufAndModifyPtr(cp, cp->dev_cfg.sta_name, 16);\n\n\t // 设备编号\n\t cp->print_ptr += 10;\n\t sprintf(local_buf, \"B%02d.print.device_no\", my_addr);\n\t p_datafield = getParameterWithName(local_buf);\n\t if (NULL == p_datafield)\n\t {\n\t\t PRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printHeaderLine) Get parameter err1!\\n\");\n\t\t return;\n\t }\n\n\t printAddStrToBuf(cp, p_datafield->desc);\n\t printAddStrToBuf(cp, \":\");\n\t printAddStrToBuf(cp, cp->dev_cfg.dev_no);\n\n\t // 间隔号（线路保护独有）\n\t if (0 == strcmp(cp->dev_cfg.bay_no, \"SY_RESERVE_STRING\"))\n\t {\n\t\t cp->print_ptr += 30;\n\t }\n\t else\n\t {\n\t\t cp->print_ptr += 6;\n\t\t sprintf(local_buf, \"B%02d.print.bay_no\", my_addr);\n\t\t p_datafield = getParameterWithName(local_buf);\n\t\t if (NULL == p_datafield)\n\t\t {\n\t\t\t PRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printHeaderLine) Get parameter err2!\\n\");\n\t\t\t return;\n\t\t }\n\n\t\t printAddStrToBuf(cp, p_datafield->desc);\n\t\t printAddStrToBuf(cp, \":\");\n\t\t printAddStrToBuf(cp, cp->dev_cfg.bay_no);\n\n\t\t cp->print_ptr += 6;\n\t }\n\n\t // 装置地址\n\t cp->print_ptr += 6;\n\t printAddStrToBuf(cp, slan_device_addr.desc[cp->dev_cfg.lang_sel]);\n\t printAddStrToBuf(cp, \":\");\n\t sprintf(local_buf, \"%d\", cp->dev_cfg.dev_addr);\n\t printAddStrToBufAndModifyPtr(cp, local_buf, 5);\n\n\t printCharLine(cp,WITH_RETURN);\n\n\t // 第2行，生产厂家\n\t cp->print_ptr += 2;\n\t printAddStrToBuf(cp, slan_manufacturer_str.desc[cp->dev_cfg.lang_sel]);\n\t printAddStrToBuf(cp, \":\");\n\t printAddStrToBuf(cp, p_dev_inf->factory);\n\t cp->print_ptr += 2;\n\n\t // 版本号\n\t cp->print_ptr += 6;\n\t printAddStrToBuf(cp, slan_prog_ver_str.desc[cp->dev_cfg.lang_sel]);\n\t printAddStrToBuf(cp, \":\");\n\t printAddStrToBufAndModifyPtr(cp, p_dev_inf->ver, 5);\n\n\t // 校验码\n\t cp->print_ptr += 16;\n\t printAddStrToBuf(cp, slan_prog_chksum.desc[cp->dev_cfg.lang_sel]);\n\t printAddStrToBuf(cp, \":\");\n\t printAddStrToBufAndModifyPtr(cp, p_dev_inf->dev_prog_crc_str, 8);\n\n\t // 程序时间\n\t cp->print_ptr += 10;\n\t printAddStrToBuf(cp, slan_prog_time.desc[cp->dev_cfg.lang_sel]);\n\t printAddStrToBuf(cp, \":\");\n\t printAddStrToBuf(cp, p_dev_inf->dev_prog_time_str);\n\n\t printCharLine(cp, WITH_RETURN);\n\n\t // 第3行，管理序号\n\t cp->print_ptr += 2;\n\t printAddStrToBuf(cp, slan_subq_no_str.desc[cp->dev_cfg.lang_sel]);\n\t printAddStrToBuf(cp, \":\");\n\t printAddStrToBufAndModifyPtr(cp, p_dev_inf->subq_no, 16);\n\n\t // 打印时间\n\t cp->print_ptr += 22;\n\t printAddStrToBuf(cp, slan_print_time_str.desc[cp->dev_cfg.lang_sel]);\n\t printAddStrToBuf(cp, \":\");\n\t longSecToManTime(local_sys_s, time_str);\n\t printAddStrToBuf(cp, time_str);\n\n\t printCharLine(cp, WITH_RETURN);\n\n\t return;\n }\n\n LOCAL void printHeaderLineNet(Print *cp, INT8 *header_str)\n {\n\t UINT8 total_length = 0, middle_start = 0;\n\t INT8 time_str[32] = { 0 }, local_buf[32] = { 0 };\n\t INT8 *p_equip_name = NULL;\n\t DataFields *p_datafield = NULL;\n\t DevInfo *p_dev_inf = NULL;\n\n\t p_dev_inf = getDevInfo();\n\t if (NULL == p_dev_inf)\n\t {\n\t\t return;\n\t }\n\n\t total_length = strlen(p_dev_inf->dev_type) + strlen(p_dev_inf->dev_name)\n\t\t\t\t\t+ strlen(title_line_line[cp->print_method][cp->dev_cfg.lang_sel])\n\t\t\t\t\t+ strlen(header_str);\n\n\t // 加粗\n\t *cp->print_ptr++ = ESC;\n\t *cp->print_ptr++ = '(';\n\t *cp->print_ptr++ = 's';\n\t *cp->print_ptr++ = '1';\n\t *cp->print_ptr++ = '2';\n\t *cp->print_ptr++ = 'V';\n\n\t *cp->print_ptr++ = ESC;\n\t *cp->print_ptr++ = '(';\n\t *cp->print_ptr++ = 's';\n\t *cp->print_ptr++ = '3';\n\t *cp->print_ptr++ = 'B';\n\t printCharLine(cp, WITHOUT_RETURN);\n\n\t// 居中\n\tmiddle_start = (PRINT_LINE_CHAR_LEN_NET - total_length) / 2;\n\tmemset(cp->print_ptr, ' ', middle_start);\n\tcp->print_ptr += middle_start;\n\n\tprintAddStrToBuf(cp, p_dev_inf->dev_type);\n\tprintAddStrToBuf(cp, \" \");\n\tprintAddStrToBuf(cp, p_dev_inf->dev_name);\n\tprintAddStrToBuf(cp, title_line_line[cp->print_method][cp->dev_cfg.lang_sel]);\n\tprintAddStrToBuf(cp, header_str);\n\tprintCharLine(cp, WITH_RETURN);\n\n\t// 取消加粗\n\t*cp->print_ptr++ = ESC;\n\t*cp->print_ptr++ = '(';\n\t*cp->print_ptr++ = 's';\n\t*cp->print_ptr++ = '1';\n\t*cp->print_ptr++ = '0';\n\t*cp->print_ptr++ = 'V';\n\n\t*cp->print_ptr++ = ESC;\n\t*cp->print_ptr++ = '(';\n\t*cp->print_ptr++ = 's';\n\t*cp->print_ptr++ = '0';\n\t*cp->print_ptr++ = 'B';\n\tprintCharLine(cp, WITHOUT_RETURN);\n\n\t // 分割线\n\t printStrLine(cp, title_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t // 第一行，厂站名称\n\t cp->print_ptr += 2;\n\t sprintf(local_buf, \"B%02d.print.station_name\", my_addr);\n\t p_datafield = getParameterWithName(local_buf);\n\t if (NULL == p_datafield)\n\t {\n\t\t PRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printHeaderLine) Get parameter err!\\n\");\n\t\t return;\n\t }\n\n\t printAddStrToBuf(cp, p_datafield->desc);\n\t printAddStrToBuf(cp, \":\");\n\t printAddStrToBufAndModifyPtr(cp, cp->dev_cfg.sta_name, 16);\n\n\t // 设备编号\n\t cp->print_ptr += 6;\n\t sprintf(local_buf, \"B%02d.print.device_no\", my_addr);\n\t p_datafield = getParameterWithName(local_buf);\n\t if (NULL == p_datafield)\n\t {\n\t\t PRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printHeaderLine) Get parameter err1!\\n\");\n\t\t return;\n\t }\n\n\t printAddStrToBuf(cp, p_datafield->desc);\n\t printAddStrToBuf(cp, \":\");\n\t printAddStrToBuf(cp, cp->dev_cfg.dev_no);\n\n\t // 间隔号（线路保护独有）\n\t if (0 == strcmp(cp->dev_cfg.bay_no, \"SY_RESERVE_STRING\"))\n\t {\n\t\t cp->print_ptr += 24;\n\t }\n\t else\n\t {\n\t\t cp->print_ptr += 6;\n\t\t sprintf(local_buf, \"B%02d.print.bay_no\", my_addr);\n\t\t p_datafield = getParameterWithName(local_buf);\n\t\t if (NULL == p_datafield)\n\t\t {\n\t\t\t PRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printHeaderLine) Get parameter err2!\\n\");\n\t\t\t return;\n\t\t }\n\n\t\t printAddStrToBuf(cp, p_datafield->desc);\n\t\t printAddStrToBuf(cp, \":\");\n\t\t printAddStrToBuf(cp, cp->dev_cfg.bay_no);\n\n\t\t //cp->print_ptr += 6;\n\t }\n\n\t // 装置地址\n\t cp->print_ptr += 6;\n\t printAddStrToBuf(cp, slan_device_addr.desc[cp->dev_cfg.lang_sel]);\n\t printAddStrToBuf(cp, \":\");\n\t sprintf(local_buf, \"%d\", cp->dev_cfg.dev_addr);\n\t printAddStrToBufAndModifyPtr(cp, local_buf, 5);\n\n\t printCharLine(cp,WITH_RETURN);\n\n\t // 第2行，生产厂家\n\t cp->print_ptr += 2;\n\t printAddStrToBuf(cp, slan_manufacturer_str.desc[cp->dev_cfg.lang_sel]);\n\t printAddStrToBuf(cp, \":\");\n\t printAddStrToBuf(cp, p_dev_inf->factory);\n\t cp->print_ptr += 2;\n\n\t // 版本号\n\t cp->print_ptr += 6;\n\t printAddStrToBuf(cp, slan_prog_ver_str.desc[cp->dev_cfg.lang_sel]);\n\t printAddStrToBuf(cp, \":\");\n\t printAddStrToBufAndModifyPtr(cp, p_dev_inf->ver, 5);\n\n\t // 校验码\n\t cp->print_ptr += 16;\n\t printAddStrToBuf(cp, slan_prog_chksum.desc[cp->dev_cfg.lang_sel]);\n\t printAddStrToBuf(cp, \":\");\n\t printAddStrToBufAndModifyPtr(cp, p_dev_inf->dev_prog_crc_str, 8);\n\n\t // 程序时间\n\t cp->print_ptr += 10;\n\t printAddStrToBuf(cp, slan_prog_time.desc[cp->dev_cfg.lang_sel]);\n\t printAddStrToBuf(cp, \":\");\n\t printAddStrToBuf(cp, p_dev_inf->dev_prog_time_str);\n\n\t printCharLine(cp, WITH_RETURN);\n\n\t // 第3行，管理序号\n\t cp->print_ptr += 2;\n\t printAddStrToBuf(cp, slan_subq_no_str.desc[cp->dev_cfg.lang_sel]);\n\t printAddStrToBuf(cp, \":\");\n\t printAddStrToBufAndModifyPtr(cp, p_dev_inf->subq_no, 16);\n\n\t // 打印时间\n\t cp->print_ptr += 22;\n\t printAddStrToBuf(cp, slan_print_time_str.desc[cp->dev_cfg.lang_sel]);\n\t printAddStrToBuf(cp, \":\");\n\t longSecToManTime(local_sys_s, time_str);\n\t printAddStrToBuf(cp, time_str);\n\n\t printCharLine(cp, WITH_RETURN);\n\n\t return;\n }\n\n /* 将内容拷贝进打印缓存 */\n LOCAL void printAddStrToBuf(Print *cp, const INT8 *string)\n {\n\t memcpy(cp->print_ptr, string, strlen(string));\n\t cp->print_ptr += strlen(string);\n\n\t return;\n }\n\n LOCAL void printAddStrToBufAndModifyPtr(Print *cp, const INT8 *string, INT32 offset)\n {\n\t  memcpy(cp->print_ptr, string, strlen(string));\n\t  cp->print_ptr += offset;\n\n\t  return;\n }\n\n /* 打印字符串 */\n LOCAL void printStrLine(Print *cp, const INT8 *string, INT8 if_return)\n {\n\t memcpy((void *)cp->print_ptr, (const void *)string, strlen(string));\n\t cp->print_ptr += strlen(string);\n\t printCharLine(cp, if_return);\n\n\t return;\n }\n\n /* 格式化字符串 */\n LOCAL INT32 printInvarFormatToBuffer(DataFields* p_datafield, InVar* p_invar, INT8 *p_buffer_left, INT8 *p_buffer_right, INT8 prim_or_second)\n {\n\t INT32 local_int_value = 0;\n\t FLOAT32 local_float_value = 0.;\n\t INT8 local_buffer[32] = { 0 };\n\t UINT8 local_value[8] = { 0 };\n\t INT8 *p_format = NULL, *p_local_ptr = NULL;\n\t INT32 i = 0, str_len = 0;\n\n\t p_format = strchr(p_datafield->format, '%');\n\t switch(p_datafield->type)\n\t {\n\t case BITS_TYPE:\n\t\t if (strchr(p_format, '-'))\n\t\t {\n\t\t\t *(p_buffer_left) = (*((UINT8 *)&p_invar->value)&0x01) + '0';\n\t\t }\n\t\t else\n\t\t {\n\t\t\t *(p_buffer_right) = (*((UINT8 *)&p_invar->value)&0x01) + '0';\n\t\t }\n\t\t break;\n\n\t case INT8_TYPE:\n\t case UINT8_TYPE:\n\t case INT16_TYPE:\n\t case UINT16_TYPE:\n\t case INT32_TYPE:\n\t case UINT32_TYPE:\n\t\t if (0 == strcmp(p_format, \"%t\"))\n\t\t {\n\t\t\t p_local_ptr = p_buffer_right - 17 + 4;\n\t\t\t longSecToManTime(*((UINT32 *)&p_invar->value), p_local_ptr);\n\t\t\t str_len = strlen(p_local_ptr);\n\t\t\t p_local_ptr[str_len] = ' ';\n\t\t\t break;\n\t\t }\n\t\t else if (0 == strcmp(p_format, \"%q\"))\n\t\t {\n\t\t\t for (i = 0; i < 4; i++)\n\t\t\t {\n\t\t\t\t local_value[i] = (*((UINT8 *)&p_invar->value) >> ((3 - i) * 8)) & 0xff;\n\t\t\t }\n\t\t\t local_value[4] = '\\0';\n\t\t\t sprintf(local_buffer, \"%s\", local_value);\n\n\t\t\t if (strchr(p_format, '-'))\n\t\t\t {\n\t\t\t\t memcpy(p_buffer_left, local_buffer, strlen(local_buffer));\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t memcpy(p_buffer_right - strlen(local_buffer) + 1, local_buffer, strlen(local_buffer));\n\t\t\t }\n\t\t\t break;\n\t\t }\n\n\t\t if (printCheckFormatString(p_format) < 0)\n\t\t {\n\t\t\t PRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printInvarFormatToBuffer) Format err!\\n\");\n\t\t\t return -1;\n\t\t }\n\n\t\t switch(p_datafield->type)\n\t\t {\n\t\t case INT8_TYPE:\n\t\t case UINT8_TYPE:\n\t\t\t if( p_datafield->is_unsigned\n\t\t\t\t || strchr((const char*)p_format,'c')\n\t\t\t\t || strchr((const char*)p_format,'u')\n\t\t\t\t || strchr((const char*)p_format,'x')\n\t\t\t\t || strchr((const char*)p_format,'X')\n\t\t\t\t || strchr((const char*)p_format,'o') )\n\t\t\t {\n\t\t\t\t local_int_value = *((UINT8*)&p_invar->value);\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t local_int_value = *((INT8*)&p_invar->value);\n\t\t\t }\n\t\t\t break;\n\n\t\t case INT16_TYPE:\n\t\t case UINT16_TYPE:\n\t\t\t if( p_datafield->is_unsigned\n\t\t\t\t || strchr((const char*)p_format,'u')\n\t\t\t\t || strchr((const char*)p_format,'x')\n\t\t\t\t || strchr((const char*)p_format,'X')\n\t\t\t\t || strchr((const char*)p_format,'o') )\n\t\t\t {\n\t\t\t\t local_int_value = *((UINT16*)&p_invar->value);\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t local_int_value = *((INT16*)&p_invar->value);\n\t\t\t }\n\t\t\t break;\n\n\t\t case INT32_TYPE:\n\t\t case UINT32_TYPE:\n\t\t\t if( p_datafield->is_unsigned\n\t\t\t\t || strchr((const char*)p_format,'u')\n\t\t\t\t || strchr((const char*)p_format,'x')\n\t\t\t\t || strchr((const char*)p_format,'X')\n\t\t\t\t || strchr((const char*)p_format,'o') )\n\t\t\t {\n\t\t\t\t local_int_value = *((UINT32*)&p_invar->value);\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t local_int_value = *((INT32*)&p_invar->value);\n\t\t\t }\n\t\t\t break;\n\n\t\t default:\n\t\t\t break;\n\t\t }\n\n\t\t if (fabs(p_datafield->u_value.float64.norm[prim_or_second] - 1.0) > 0.0001)\n\t\t {\n\t\t\t local_float_value = local_int_value;\n\t\t\t local_float_value = local_float_value*p_datafield->u_value.float64.norm[prim_or_second];\n\n\t\t\t if( strchr(p_datafield->format,'x') \n\t\t\t\t || strchr(p_datafield->format,'X') \n\t\t\t\t || strchr(p_datafield->format,'b')\n\t\t\t\t || strchr(p_datafield->format,'d')\n\t\t\t\t || strchr(p_datafield->format,'c')\n\t\t\t\t || strchr(p_datafield->format,'u') )\n\t\t\t {\n\t\t\t\t local_int_value = local_float_value;\n\t\t\t\t sprintf(local_buffer,(const char*)p_format,local_int_value);\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t sprintf(local_buffer,(const char*)p_format,local_float_value);\n\t\t\t }\n\t\t }\n\t\t else\n\t\t {\n\t\t\t if( strchr(p_datafield->format,'x') \n\t\t\t\t || strchr(p_datafield->format,'X') \n\t\t\t\t || strchr(p_datafield->format,'b')\n\t\t\t\t || strchr(p_datafield->format,'d')\n\t\t\t\t || strchr(p_datafield->format,'c')\n\t\t\t\t || strchr(p_datafield->format,'u') )\n\t\t\t {\n\t\t\t\t sprintf(local_buffer,(const INT8*)p_format,local_int_value);\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t local_float_value = local_int_value;\n\t\t\t\t sprintf(local_buffer,(const INT8*)p_format,local_float_value);\n\t\t\t }\n\t\t }\n\n\t\t if(strchr((const char*)p_format,'-'))\n\t\t {\n\t\t\t memcpy(p_buffer_left,local_buffer,strlen(local_buffer));\n\t\t }\n\t\t else\n\t\t {\n\t\t\t memcpy(p_buffer_right-strlen(local_buffer)+1,local_buffer,strlen(local_buffer));\n\t\t }\n\t\t break;\n\n\t\t case FLOAT_TYPE:\n\t\t\t if (printCheckFormatString(p_format) < 0)\n\t\t\t {\n\t\t\t\t PRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printInvarFormatToBuffer) Format err1!\\n\");\n\t\t\t\t return -1;\n\t\t\t }\n\n\t\t\t local_float_value = *((FLOAT32*)&p_invar->value)*p_datafield->u_value.float64.norm[prim_or_second];\n\t\t\t sprintf(local_buffer,(const char*)p_format,local_float_value);\n\t\t\t // 输出格式中是否有左对齐\n\t\t\t if(strchr((const char*)p_format,'-'))\n\t\t\t {\n\t\t\t\t memcpy(p_buffer_left,local_buffer,strlen(local_buffer));\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t memcpy(p_buffer_right-strlen(local_buffer)+1,local_buffer,strlen(local_buffer));\n\t\t\t }\n\t\t\t break;\n\n\t\t case NET_ADDR_TYPE:\n\t\t\t local_int_value = *((UINT32*)&p_invar->value);\n\t\t\t sprintf(local_buffer,\"%03d\",(INT32)(local_int_value>>24)&0xFF);\n\t\t\t local_buffer[3] = '.';\n\t\t\t sprintf(local_buffer+4,\"%03d\",(INT32)(local_int_value>>16)&0xFF);\n\t\t\t local_buffer[7] = '.';\n\t\t\t sprintf(local_buffer+8,\"%03d\",(INT32)(local_int_value>>8)&0xFF);\n\t\t\t local_buffer[11] = '.';\n\t\t\t sprintf(local_buffer+12,\"%03d\",(INT32)(local_int_value>>0)&0xFF);\n\t\t\t local_buffer[15] = '\\0';\n\t\t\t // 输出格式中是否有左对齐\n\t\t\t if(strchr((const char*)p_format,'-'))\n\t\t\t\t memcpy(p_buffer_left,local_buffer,strlen(local_buffer));\n\t\t\t else\n\t\t\t\t memcpy(p_buffer_right-strlen(local_buffer)+1,local_buffer,strlen(local_buffer));\n\t\t\t break;\n\n\t\t case STRUCT_TYPE:\n\t\t\t //sprintf(local_buffer,(const char*)p_format,(INT8*)p_invar);\n\t\t\t sprintf(local_buffer,(const char*)p_format,(INT8*)getLocalLangByAbbr((INT8*)p_invar->value,gp_print->dev_cfg.lang_sel));\n\t\t\t         \t\t//(INT8*)getLocalLangByAbbr((INT8*)p_invar->value,cp->dev_cfg.lang_sel));\n\t\t\t // 输出格式中是否有左对齐\n\t\t\t if(strchr((const char*)p_format,'-'))\n\t\t\t\t memcpy(p_buffer_left,local_buffer,strlen(local_buffer));\n\t\t\t else\n\t\t\t\t memcpy(p_buffer_right-strlen(local_buffer)+1,local_buffer,strlen(local_buffer));\n\t\t\t break;\n\n\t\t default:\n\t\t\t break;\n\t }\n\n\t return 0;\n }\n\n LOCAL INT32 printGetFormatbValue(DataFields *p_datafield)\n {\n\t INT8 *p_str = NULL, format_buf[16] = { 0 };\n\t INT32 str8_size = 0;\n\n\t p_str = strchr((const char*)p_datafield->format,'b');\n\t if(p_str==NULL) return 0;\n\n\t p_str = strchr((const char*)p_datafield->format,'-');\n\t if(p_str==NULL)\n\t\t p_str = strchr((const char*)p_datafield->format,'%');\n\t if(p_str==NULL) return 0;\n\n\t strcpy(format_buf,p_str+1);\n\t p_str = strchr((const char*)format_buf,'b');\n\t if(p_str) *p_str = '\\0';\n\n\t sscanf(format_buf,\"%d\\n\",&str8_size);\n\n\t return str8_size;\n }\n\n LOCAL INT32 printSetValueFormatToBuffer(DataFields* p_datafield, SettingValue* p_value, INT8* p_buffer_left, INT8* p_buffer_right)\n {\n\t INT8 local_buffer[32],format_buf[16];\n\t INT32 local_int_value,str8_size,i;\n\t UINT32 list_index,l_value,local_and_value,local_uint32_value;\n\t INT8 *p_format;\n\t FLOAT32 local_float_value;\n\n\t p_format = strchr((const INT8*)p_datafield->format,'%');\n\t // 数值\n\t switch( p_datafield->type )\n\t {\n\t case BITS_TYPE:\n\t\t // 输出格式中是否有左对齐\n\t\t if(strchr(p_format,'-'))\n\t\t\t *(p_buffer_left) = ((INT32)(p_value->u_value.f_value)&0x01) + '0';\n\t\t else\n\t\t\t *(p_buffer_right) = ((INT32)(p_value->u_value.f_value)&0x01) + '0';\n\t\t break;\n\t case INT8_TYPE:\n\t case UINT8_TYPE:\n\t case INT16_TYPE:\n\t case UINT16_TYPE:\n\t case INT32_TYPE:\n\t case UINT32_TYPE:\n\t\t if( printCheckFormatString(p_format)<0 ) \n\t\t\t return -1;\n\n\t\t local_float_value = p_value->u_value.f_value;\n\t\t local_uint32_value = p_value->u_value.f_value;\n\t\t //        if( strcmp(p_datafield->unit,\"mS\")==0 )\n\t\t //        {\n\t\t //            local_float_value /= 1000.0;\n\t\t //            local_uint32_value /= 1000;\n\t\t //        }\n\t\t //        if( ctrl_value&(1<<FORMAT_CTRL_UNIT_VAR) ) // 量纲可变\n\t\t //            *p_unit_k = changeFloatValueWithUnit(local_float_value,&local_float_value);\n\t\t if( strchr(p_datafield->format,'x') \n\t\t\t || strchr(p_datafield->format,'X') \n\t\t\t || strchr(p_datafield->format,'b')\n\t\t\t || strchr(p_datafield->format,'d')\n\t\t\t || strchr(p_datafield->format,'u') )\n\t\t {\n\t\t\t if( strchr(p_format,'b') ) \n\t\t\t {\n\t\t\t\t str8_size = printGetFormatbValue(p_datafield);\n\t\t\t\t local_and_value = 0;\n\t\t\t\t for(i=0;i<str8_size;i++)\n\t\t\t\t\t local_and_value |= (1<<i);\n\n\t\t\t\t sprintf(format_buf,\"%%%dX\",(str8_size+3)/4);\n\t\t\t\t sprintf(local_buffer,format_buf,local_uint32_value&local_and_value);\n\t\t\t }\n\t\t\t else if( strchr(p_format,'x')\n\t\t\t\t || strchr(p_format,'X')\n\t\t\t\t || strchr(p_format,'u') ) \n\t\t\t\t sprintf(local_buffer,p_format,local_uint32_value);\n\t\t\t else\n\t\t\t {\n\t\t\t\t local_int_value = local_float_value;\n\t\t\t\t sprintf(local_buffer,p_format,local_int_value);\n\t\t\t }\n\t\t }\n\t\t else\n\t\t\t sprintf(local_buffer,p_format,local_float_value);\n\n\t\t // 输出格式中是否有左对齐\n\t\t if(strchr(p_format,'-'))\n\t\t\t memcpy(p_buffer_left,local_buffer,strlen(local_buffer));\n\t\t else\n\t\t\t memcpy(p_buffer_right-strlen(local_buffer)+1,local_buffer,strlen(local_buffer));\n\t\t break;\n\t case FLOAT_TYPE:\n\t\t if( printCheckFormatString(p_format)<0 ) \n\t\t\t return -1;\n\n\t\t local_float_value = p_value->u_value.f_value;\n\t\t //        getDescFormatCtrlValue(p_datafield,&ctrl_value);\n\t\t //        if( strcmp(p_datafield->unit,\"mS\")==0 )\n\t\t //            local_float_value /= 1000.0;\n\t\t //        if( ctrl_value&(1<<FORMAT_CTRL_UNIT_VAR) ) // 量纲可变\n\t\t //            *p_unit_k = changeFloatValueWithUnit(local_float_value,&local_float_value);\n\t\t sprintf(local_buffer,p_format,local_float_value);\n\t\t // 输出格式中是否有左对齐\n\t\t if(strchr(p_format,'-'))\n\t\t\t memcpy(p_buffer_left,local_buffer,strlen(local_buffer));\n\t\t else\n\t\t\t memcpy(p_buffer_right-strlen(local_buffer)+1,local_buffer,strlen(local_buffer));\n\t\t break;\n\t case STRING_TYPE:\n\t\t // 输出格式中是否有左对齐\n\t\t if(strchr(p_format,'-'))\n\t\t\t memcpy(p_buffer_left,p_value->u_value.s_value,strlen(p_value->u_value.s_value));\n\t\t else\n\t\t\t memcpy(p_buffer_right-strlen(p_value->u_value.s_value)+1,p_value->u_value.s_value,strlen(p_value->u_value.s_value));\n\t\t break;\n\t case FLOAT_LIST_TYPE:\n\t\t sprintf(local_buffer,p_format,p_value->u_value.f_value);\n\t\t // 输出格式中是否有左对齐\n\t\t if(strchr(p_format,'-'))\n\t\t\t memcpy(p_buffer_left,local_buffer,strlen(local_buffer));\n\t\t else\n\t\t\t memcpy(p_buffer_right-strlen(local_buffer)+1,local_buffer,strlen(local_buffer));\n\t\t break;\n\t case INT32_LIST_TYPE:\n\t case BIT_LIST_TYPE:\n\t\t sprintf(local_buffer,p_format,(INT32)p_value->u_value.f_value);\n\t\t // 输出格式中是否有左对齐\n\t\t if(strchr(p_format,'-'))\n\t\t\t memcpy(p_buffer_left,local_buffer,strlen(local_buffer));\n\t\t else\n\t\t\t memcpy(p_buffer_right-strlen(local_buffer)+1,local_buffer,strlen(local_buffer));\n\t\t break;\n\t case STRING_LIST_TYPE:\n\t\t // 先得到索引值\n\t\t list_index = (INT32)p_value->u_value.f_value;  \n\t\t if(list_index >= p_datafield->list_num) list_index = 0;\n\t\t sprintf(local_buffer,\"%s\",\n\t\t\t getSettingListStr(p_datafield->s_list_no,p_datafield->list_num,list_index));\n\n\t\t // 输出格式中是否有左对齐\n\t\t if(strchr(p_format,'-'))\n\t\t\t memcpy(p_buffer_left,local_buffer,strlen(local_buffer));\n\t\t else\n\t\t\t memcpy(p_buffer_right-strlen(local_buffer)+1,local_buffer,strlen(local_buffer));\n\t\t break;\n\t case NET_ADDR_TYPE:\n\t\t l_value = (UINT32)p_value->u_value.f_value;\n\t\t sprintf(local_buffer,\"%03d\",(INT32)(l_value>>24)&0xFF);\n\t\t local_buffer[3] = '.';\n\t\t sprintf(local_buffer+4,\"%03d\",(INT32)(l_value>>16)&0xFF);\n\t\t local_buffer[7] = '.';\n\t\t sprintf(local_buffer+8,\"%03d\",(INT32)(l_value>>8)&0xFF);\n\t\t local_buffer[11] = '.';\n\t\t sprintf(local_buffer+12,\"%03d\",(INT32)(l_value>>0)&0xFF);\n\t\t local_buffer[15] = '\\0';\n\t\t // 输出格式中是否有左对齐\n\t\t if(strchr(p_format,'-'))\n\t\t\t memcpy(p_buffer_left,local_buffer,strlen(local_buffer));\n\t\t else\n\t\t\t memcpy(p_buffer_right-strlen(local_buffer)+1,local_buffer,strlen(local_buffer));\n\t\t break;\n\t default:\n\t\t break;\n\t }\n\n\t return 1;\n }\n\n LOCAL INT32 printCheckFormatString(const INT8 *p_format)\n {\n\t if (strchr(p_format, 's'))\n\t {\n\t\t PRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printCheckFormatString) Check foram err!\\n\");\n\t\t return -1;\n\t }\n\n\t return 1;\n }\n\n /* 获取波形数据 */\n LOCAL INT32 printGetWaveFile(Print *cp)\n {\n\t UINT16 read_num = 0;\n\t INT32 j = 0, k = 0, comtrade_data_type = 0;\n\t INT8 *p_buffer_ptr_app = NULL;\n\t INT8 ana_bin_num_str[8] = { 0 }, ana_num_str[8] = { 0 }, bin_num_str[8] = { 0 }, *int8_ptr = NULL;\n\t INT8 coef_a_str[16] = { 0 }, coef_b_str[16] = { 0 }, min_str[16] = { 0 }, max_str[16] = { 0 };\n\t INT8 ps_str[8] = { 0 }, rec_freq_str[16] = { 0 }, rec_dot_str[16] = { 0 };\n\t FILE *fp1 = NULL, *fp2 = NULL;\n\t INT32 ana_bin_num = 0, ana_num = 0, bin_num = 0;\n\t UINT8 err_flag = 0;\n\t INT32 dat_analog_value = 0;\n\t INT32 dat_bin_value = 0;\n\t INT16 data_analog_int16_value = 0;\n\t INT8 file_cfg_name[64] = { 0 }, file_dat_name[64] = { 0 };\n\n\t // 获取波形文件名称\n\t getWaveName(&cp->wave_data.fault_head.t, cp->wave_data.fault_head.nof,\n\t\t\t\t\tgp_wave_file_dir[EN_WAVE_USER_ID],\n\t\t\t\t\tgp_fault_file_ext_name[EN_FAULT_CFG_NAME_ID], file_cfg_name);\n\t getWaveName(&cp->wave_data.fault_head.t, cp->wave_data.fault_head.nof,\n\t\t\t\t\tgp_wave_file_dir[EN_WAVE_USER_ID],\n\t\t\t\t\tgp_fault_file_ext_name[EN_FAULT_DAT_NAME_ID], file_dat_name);\n\n\t // 从NAND FLASH中读出波形\n\t fp1 = fopen(file_cfg_name, \"r\");\n\t if (NULL == fp1)\n\t {\n\t\t printf(\"[print]: (_func_printGetWaveFile) Cann't open %s!\\n\", file_cfg_name);\n\t\t return -1;\n\t }\n\n\t fp2 = fopen(file_dat_name, \"r\");\n\t if (NULL == fp2)\n\t {\n\t\t printf(\"[print]: (_func_printGetWaveFile) Cann't open %s!\\n\", file_dat_name);\n\t\t fclose(fp1);\n\t\t return -1;\n\t }\n\n\t // 读取CFG文件\n\t p_buffer_ptr_app = cp->component_buf;\n\t if (NULL == fgets(p_buffer_ptr_app, PRINT_BUF_LEN, fp1))\n\t {\n\t\t printf(\"[print]: (_func_printGetWaveFile) Fgets err!\\n\");\n\t\t fclose(fp1);\n\t\t fclose(fp2);\n\t\t return -1;\n\t }\n\n\t if (NULL == fgets(p_buffer_ptr_app, PRINT_BUF_LEN, fp1))\n\t {\n\t\t printf(\"[print]: (_func_printGetWaveFile) Fgets err1!\\n\");\n\t\t fclose(fp1);\n\t\t fclose(fp2);\n\t\t return -1;\n\t }\n\n\t int8_ptr = strtok(p_buffer_ptr_app, \", \");\n\t if (int8_ptr)\n\t {\n\t\t strcpy(ana_bin_num_str, int8_ptr);\n\t }\n\n\t int8_ptr = strtok(NULL, \", \");\n\t if (int8_ptr)\n\t {\n\t\t strcpy(ana_num_str, int8_ptr);\n\t }\n\n\t int8_ptr = strtok(NULL, \", \");\n\t if (int8_ptr)\n\t {\n\t\t strcpy(bin_num_str, int8_ptr);\n\t }\n\n\t int8_ptr = strchr(ana_num_str, 'A');\n\t if (int8_ptr)\n\t {\n\t\t *int8_ptr = '\\0';\n\t }\n\n\t int8_ptr = strchr(bin_num_str, 'D');\n\t if (int8_ptr)\n\t {\n\t\t *int8_ptr = '\\0';\n\t }\n\n\t sscanf(ana_bin_num_str, \"%d\", &ana_bin_num);\n\t sscanf(ana_num_str, \"%d\", &ana_num);\n\t sscanf(bin_num_str, \"%d\", &bin_num);\n\t cp->wave_data.ana_num = ana_num;\n\t cp->wave_data.bin_num = bin_num;\n\t cp->wave_data.bin_int16_num = (bin_num + 15) >> 4;\n\n\t // 分配波形所需数据空间\n\t if (printMallocWaveHeap(cp) < 0)\n\t {\n\t\t printf(\"[print]: (_func_printGetWaveFile) Malloc failed!\\n\");\n\t\t fclose(fp1);\n\t\t fclose(fp2);\n\t\t return -1;\n\t }\n\n\t for (j = 0; j < ana_num; j++)\n\t {\n\t\t p_buffer_ptr_app = cp->component_buf;\n\n\t\t if (NULL == fgets(p_buffer_ptr_app, PRINT_BUF_LEN, fp1))\n\t\t {\n\t\t\t printf(\"[print]: (_func_printGetWaveFile) Fgets err2!\\n\");\n\t\t\t fclose(fp1);\n\t\t\t fclose(fp2);\n\t\t\t return -1;\n\t\t }\n\n\t\t for (k = 0; k < 5; k++)\n\t\t {\n\t\t\t p_buffer_ptr_app = strchr(p_buffer_ptr_app, ',');\n\t\t\t p_buffer_ptr_app++;\n\t\t }\n\n\t\t if (NULL == p_buffer_ptr_app)\n\t\t {\n\t\t\t err_flag = 1;\n\t\t\t break;\n\t\t }\n\n\t\t int8_ptr = strtok(p_buffer_ptr_app, \", \");\n\t\t if (int8_ptr)\n\t\t {\n\t\t\t strcpy(coef_a_str, int8_ptr);\n\t\t }\n\n\t\t int8_ptr = strtok(NULL, \", \");\n\t\t if (int8_ptr)\n\t\t {\n\t\t\t strcpy(coef_b_str, int8_ptr);\n\t\t }\n\n\t\t sscanf(coef_a_str, \"%lf\", &cp->wave_data.p_analog_coef_a[j]);\n\t\t sscanf(coef_b_str, \"%lf\", &cp->wave_data.p_analog_coef_b[j]);\n\n\t\t int8_ptr = strtok(NULL, \", \");\n\t\t int8_ptr = strtok(NULL, \", \");\n\t\t if (int8_ptr)\n\t\t {\n\t\t\t strcpy(min_str, int8_ptr);\n\t\t }\n\n\t\t int8_ptr = strtok(NULL, \", \");\n\t\t if (int8_ptr)\n\t\t {\n\t\t\t strcpy(max_str, int8_ptr);\n\t\t }\n\n\t\t sscanf(min_str, \"%d\", &cp->wave_data.p_analog_min[j]);\n\t\t sscanf(max_str, \"%d\", &cp->wave_data.p_analog_max[j]);\n\n\t\t int8_ptr = strtok(NULL, \", \");\n\t\t int8_ptr = strtok(NULL, \", \");\n\t\t int8_ptr = strtok(NULL, \", \");\n\t\t if (int8_ptr)\n\t\t {\n\t\t\t strcpy(ps_str, int8_ptr);\n\t\t }\n\n\t\t if ('P' == ps_str[0])\n\t\t {\n\t\t\t cp->wave_data.p_analog_ps[j] = 0;\n\t\t }\n\t\t else\n\t\t {\n\t\t\t cp->wave_data.p_analog_ps[j] = 1;\n\t\t }\n\t }\n\n\t p_buffer_ptr_app = cp->component_buf;\n\t for (j = 0; j < bin_num; j++)\n\t {\n\t\t if (NULL == fgets(p_buffer_ptr_app, PRINT_BUF_LEN, fp1))\n\t\t {\n\t\t\t printf(\"[print]: (_func_printGetWaveFile) Fgets err3!\\n\");\n\t\t\t fclose(fp1);\n\t\t\t fclose(fp2);\n\t\t\t return -1;\n\t\t }\n\t }\n\n\t if (NULL == fgets(p_buffer_ptr_app, PRINT_BUF_LEN, fp1))\n\t {\n\t\t printf(\"[print]: (_func_printGetWaveFile) Fgets err4!\\n\");\n\t\t fclose(fp1);\n\t\t fclose(fp2);\n\t\t return -1;\n\t }\n\n\t if (NULL == fgets(p_buffer_ptr_app, PRINT_BUF_LEN, fp1))\n\t {\n\t\t printf(\"[print]: (_func_printGetWaveFile) Fgets err5!\\n\");\n\t\t fclose(fp1);\n\t\t fclose(fp2);\n\t\t return -1;\n\t }\n\t sscanf(p_buffer_ptr_app, \"%d\", &cp->wave_data.nrates);\n\n\t if (cp->wave_data.nrates > 32)\n\t {\n\t\t cp->wave_data.nrates = 32;\n\t }\n\n\t for (j = 0; j < cp->wave_data.nrates; j++)\n\t {\n\t\t if (NULL == fgets(p_buffer_ptr_app, PRINT_BUF_LEN, fp1))\n\t\t {\n\t\t\t printf(\"[print]: (_func_printGetWaveFile) Fgets err6!\\n\");\n\t\t\t fclose(fp1);\n\t\t\t fclose(fp2);\n\t\t\t return -1;\n\t\t }\n\n\t\t int8_ptr = strtok(p_buffer_ptr_app, \", \");\n\t\t if (int8_ptr)\n\t\t {\n\t\t\t strcpy(rec_freq_str, int8_ptr);\n\t\t }\n\t\t sscanf(rec_freq_str, \"%f\", &cp->wave_data.rec_freq[j]);\n\n\t\t int8_ptr = strtok(NULL, \", \");\n\t\t if (int8_ptr)\n\t\t {\n\t\t\t strcpy(rec_dot_str, int8_ptr);\n\t\t }\n\t\t sscanf(rec_dot_str, \"%d\", &cp->wave_data.rec_total_dot_num);\n\n\t\t cp->wave_data.stamp_dot_num[j] = cp->wave_data.rec_total_dot_num;\n\t\t if (0 == j)\n\t\t {\n\t\t\t cp->wave_data.rate_dot_num[j] = cp->wave_data.rec_total_dot_num;\n\t\t }\n\t\t else\n\t\t {\n\t\t\t cp->wave_data.rate_dot_num[j] = cp->wave_data.rec_total_dot_num - cp->wave_data.stamp_dot_num[j-1];\n\t\t }\n\t }\n\n\t // 获取DAT文件类型\n\t while (1)\n\t {\n\t\t p_buffer_ptr_app = cp->component_buf;\n\t\t if (NULL == fgets(p_buffer_ptr_app, PRINT_BUF_LEN, fp1))\n\t\t {\n\t\t\t printf(\"[print]: (_func_printGetWaveFile) Fgets err7!\\n\");\n\t\t\t fclose(fp1);\n\t\t\t fclose(fp2);\n\t\t\t return -1;\n\t\t }\n\n\t\t if (feof(fp1))\n\t\t {\n\t\t\t PRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printGetWaveFile) File %s has been destroried!\\n\", file_cfg_name);\n\t\t\t return -1;\n\t\t }\n\n\t\t if ((NULL == strstr(p_buffer_ptr_app, \"BINARY\")) &&\n\t\t\t NULL == strstr(p_buffer_ptr_app, \"ASCII\"))\n\t\t {\n\t\t\t continue;\n\t\t }\n\n\t\t if (strstr(p_buffer_ptr_app, \"BINARY\"))\n\t\t {\n\t\t\t comtrade_data_type = 0;\n\t\t\t cp->comtrade_data_type = 0;\n\t\t }\n\t\t else\n\t\t {\n\t\t\t comtrade_data_type = 1;\n\t\t\t cp->comtrade_data_type = 1;\n\t\t }\n\t\t break;\n\t }\n\n\t if (0 == comtrade_data_type)\n\t {\n\t\t p_buffer_ptr_app = cp->component_buf;\n\t\t for (j = 0; j < cp->wave_data.rec_total_dot_num; j++)\n\t\t {\n\t\t\t read_num = fread(p_buffer_ptr_app, 4 + 4 + sizeof(INT16) * ana_num + cp->wave_data.bin_int16_num * sizeof(UINT16), 1, fp2);\n\t\t\t for (k = 0; k < ana_num; k++)\n\t\t\t {\n\t\t\t\t int8_ptr = p_buffer_ptr_app + 4 + 4 + k * sizeof(INT16);\n\t\t\t\t data_analog_int16_value = ((*(int8_ptr + 1) << 8) & 0xFF00) | (*int8_ptr & 0xFF);\n\t\t\t\t cp->wave_data.p_analog_buf[j * ana_num + k] = data_analog_int16_value;\n\t\t\t }\n\n\t\t\t for (k = 0; k < cp->wave_data.bin_int16_num; k++)\n\t\t\t {\n\t\t\t\t int8_ptr = p_buffer_ptr_app + 4 + 4 + sizeof(INT16) * ana_num + k * sizeof(UINT16);\n\t\t\t\t dat_bin_value = ((*(int8_ptr + 1) << 8) & 0xFF00) | (*int8_ptr & 0xFF);\n\t\t\t\t cp->wave_data.p_user_bin_buf[j * cp->wave_data.bin_int16_num + k] = dat_bin_value;\n\t\t\t }\n\n\t\t\t if (0 == (j & 0x3f))\n\t\t\t {\n\t\t\t\t cp->out_val[EN_OUT_RUN_CNT]++;\n\t\t\t }\n\t\t }\n\t }\n\t else\n\t {\n\t\t for (j = 0; j < cp->wave_data.rec_total_dot_num; j++)\n\t\t {\n\t\t\t if (NULL == fgets(p_buffer_ptr_app, PRINT_BUF_LEN, fp2))\n\t\t\t {\n\t\t\t\t printf(\"[print]: (_func_printGetWaveFile) Fgets err8!\\n\");\n\t\t\t\t fclose(fp1);\n\t\t\t\t fclose(fp2);\n\t\t\t\t return -1;\n\t\t\t }\n\n\t\t\t strtok(p_buffer_ptr_app, \",\\t\\n \");\n\t\t\t strtok(NULL, \",\\t\\n \");\n\t\t\t for (k = 0; k < ana_num; k++)\n\t\t\t {\n\t\t\t\t int8_ptr = strtok(NULL, \",\\t\\n \");\n\t\t\t\t sscanf(int8_ptr, \"%d\", &dat_analog_value);\n\t\t\t\t cp->wave_data.p_analog_buf[j * ana_num + k] = dat_analog_value;\n\t\t\t }\n\n\t\t\t for (k = 0; k < bin_num; k++)\n\t\t\t {\n\t\t\t\t int8_ptr = strtok(NULL, \",\\t\\n \");\n\t\t\t\t sscanf(int8_ptr, \"%d\", &dat_bin_value);\n\n\t\t\t\t if (dat_bin_value)\n\t\t\t\t {\n\t\t\t\t\t cp->wave_data.p_user_bin_buf[j * cp->wave_data.bin_int16_num + (k >> 4)]\n\t\t\t\t\t\t\t\t\t\t|= (1 << (k & 0x0f));\n\t\t\t\t }\n\t\t\t\t else\n\t\t\t\t {\n\t\t\t\t\t cp->wave_data.p_user_bin_buf[j * cp->wave_data.bin_int16_num + (k >> 4)]\n\t\t\t\t\t\t\t\t\t\t&= ~(1 << (k & 0x0f));\n\t\t\t\t }\n\t\t\t }\n\t\t }\n\t }\n\n\t fclose(fp1);\n\t fclose(fp2);\n\n\t return 0;\n }\n\n /* 分配波形所需数据空间 */\n LOCAL INT32 printMallocWaveHeap(Print *cp)\n {\n\t if (cp->wave_data.ana_num > 0)\n\t {\n\t\t if (cp->wave_data.p_analog_max)\n\t\t {\n\t\t\t HOPEFREE(cp->wave_data.p_analog_max);\n\t\t\t cp->wave_data.p_analog_max = NULL;\n\t\t }\n\n\t\t cp->wave_data.p_analog_max = HOPEMALLOC(cp->wave_data.ana_num * sizeof(INT32));\n\t\t if (NULL == cp->wave_data.p_analog_max)\n\t\t {\n\t\t\t PRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printMallocWaveHeap) Malloc failed! Size = %0x B\\n\", cp->wave_data.ana_num * sizeof(INT32));\n\t\t\t return -1;\n\t\t }\n\n\t\t if (cp->wave_data.p_analog_min)\n\t\t {\n\t\t\t HOPEFREE(cp->wave_data.p_analog_min);\n\t\t\t cp->wave_data.p_analog_min = NULL;\n\t\t }\n\n\t\t cp->wave_data.p_analog_min = HOPEMALLOC(cp->wave_data.ana_num * sizeof(INT32));\n\t\t if (NULL == cp->wave_data.p_analog_min)\n\t\t {\n\t\t\t PRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printMallocWaveHeap) Malloc failed1!\\n\");\n\t\t\t return -1;\n\t\t }\n\n\t\t if (cp->wave_data.p_analog_coef_a)\n\t\t {\n\t\t\t HOPEFREE(cp->wave_data.p_analog_coef_a);\n\t\t\t cp->wave_data.p_analog_coef_a = NULL;\n\t\t }\n\n\t\t cp->wave_data.p_analog_coef_a = HOPEMALLOC(cp->wave_data.ana_num * sizeof(FLOAT64));\n\t\t if (NULL == cp->wave_data.p_analog_coef_a)\n\t\t {\n\t\t\t PRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printMallocWaveHeap) Malloc failed2!\\n\");\n\t\t\t return -1;\n\t\t }\n\n\t\t if (cp->wave_data.p_analog_coef_b)\n\t\t {\n\t\t\t HOPEFREE(cp->wave_data.p_analog_coef_b);\n\t\t\t cp->wave_data.p_analog_coef_b = NULL;\n\t\t }\n\n\t\t cp->wave_data.p_analog_coef_b = HOPEMALLOC(cp->wave_data.ana_num * sizeof(FLOAT64));\n\t\t if (NULL == cp->wave_data.p_analog_coef_b)\n\t\t {\n\t\t\t PRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printMallocWaveHeap) Malloc failed3!\\n\");\n\t\t\t return -1;\n\t\t }\n\n\t\t if (cp->wave_data.p_analog_ps)\n\t\t {\n\t\t\t HOPEFREE(cp->wave_data.p_analog_ps);\n\t\t\t cp->wave_data.p_analog_ps = NULL;\n\t\t }\n\n\t\t cp->wave_data.p_analog_ps = HOPEMALLOC(cp->wave_data.ana_num * sizeof(INT8));\n\t\t if (NULL == cp->wave_data.p_analog_ps)\n\t\t {\n\t\t\t PRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printMallocWaveHeap) Malloc failed4!\\n\");\n\t\t\t return -1;\n\t\t }\n\n\t\t if (cp->wave_data.p_analog_buf)\n\t\t {\n\t\t\t HOPEFREE(cp->wave_data.p_analog_buf);\n\t\t\t cp->wave_data.p_analog_buf = NULL;\n\t\t }\n\n\t\t cp->wave_data.p_analog_buf = HOPEMALLOC(cp->wave_data.ana_num * sizeof(FLOAT64) * cp->wave_nof_dot_max_num);\n\t\t if (NULL == cp->wave_data.p_analog_ps)\n\t\t {\n\t\t\t PRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printMallocWaveHeap) Malloc failed5!\\n\");\n\t\t\t return -1;\n\t\t }\n\t }\n\n\t if (cp->wave_data.bin_int16_num > 0)\n\t {\n\t\t if (cp->wave_data.p_user_bin_buf)\n\t\t {\n\t\t\t HOPEFREE(cp->wave_data.p_user_bin_buf);\n\t\t\t cp->wave_data.p_user_bin_buf = NULL;\n\t\t }\n\n\t\t cp->wave_data.p_user_bin_buf = HOPEMALLOC(cp->wave_data.bin_int16_num * sizeof(UINT16) * cp->wave_nof_dot_max_num);\n\t\t if (NULL == cp->wave_data.p_user_bin_buf)\n\t\t {\n\t\t\t PRINTINFO(CONSOLE_SHOW, \"[print]: (_func_printMallocWaveHeap) Malloc failed6!\\n\");\n\t\t\t return -1;\n\t\t }\n\t }\n\n\t return 0;\n }\n\n /* 释放波形数据所需空间 */\n LOCAL INT32 printFreeWaveHeap(Print *cp)\n {\n\t if(cp->wave_data.p_analog_max)\n\t {\n\t\t HOPEFREE(cp->wave_data.p_analog_max);\n\t\t cp->wave_data.p_analog_max = NULL;\n\t }\n\n\t if(cp->wave_data.p_analog_min)\n\t {\n\t\t HOPEFREE(cp->wave_data.p_analog_min);\n\t\t cp->wave_data.p_analog_min = NULL;\n\t }\n\n\t if(cp->wave_data.p_analog_coef_a)\n\t {\n\t\t HOPEFREE(cp->wave_data.p_analog_coef_a);\n\t\t cp->wave_data.p_analog_coef_a = NULL;\n\t }\n\n\t if(cp->wave_data.p_analog_coef_b)\n\t {\n\t\t HOPEFREE(cp->wave_data.p_analog_coef_b);\n\t\t cp->wave_data.p_analog_coef_b = NULL;\n\t }\n\n\t if(cp->wave_data.p_analog_ps)\n\t {\n\t\t HOPEFREE(cp->wave_data.p_analog_ps);\n\t\t cp->wave_data.p_analog_ps = NULL;\n\t }\n\n\t if(cp->wave_data.p_analog_buf)\n\t {\n\t\t HOPEFREE(cp->wave_data.p_analog_buf);\n\t\t cp->wave_data.p_analog_buf = NULL;\n\t }\n\n\t if(cp->wave_data.p_user_bin_buf)\n\t {\n\t\t HOPEFREE(cp->wave_data.p_user_bin_buf);\n\t\t cp->wave_data.p_user_bin_buf = NULL;\n\t }\n\n\t return 0;\n }\n\n /* 自动打印 */\n LOCAL void printAutoTripUart(Print *cp)\n {\n\t INT32 i = 0, ret = 0; \n\t EventData event_data = { 0 };\n\t UINT16 event_num = 0;\n\n\t if(realEventEmpty(EN_TRIP_EVENT, PRINT_CLIENT_NO)) \n\t {\n\t\t return;\n\t }\n\n\t event_num = getRealEventNum(EN_TRIP_EVENT, PRINT_CLIENT_NO);\n\t if(event_num == 0) \n\t {\n\t\t return;\n\t }\n\n\t printHeaderLineUart(cp, slan_item_trip_rpt_header_str.desc[cp->dev_cfg.lang_sel]);\n\n\t printStrLine(cp, item_trip_rpt_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t printStrLine(cp, item_trip_rpt_line_tab1[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t for(i = 0; i < event_num; i++)\n\t {\n\t\t ret = getRealEvent(EN_TRIP_EVENT, PRINT_CLIENT_NO, &event_data, 0);\n\t\t if(ret < 0)\n\t\t {\n\t\t\t continue;\n\t\t }\n\n\t\t printRptItem(cp, &event_data);\n\t }\n\n\t printStrLine(cp, item_trip_rtp_line_tab4[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t printCharLine(cp, WITH_RETURN);\n\n\t return;\n }\n\n LOCAL void printAutoTripNet(Print *cp)\n {\n\t INT32 i = 0, ret = 0; \n\t EventData event_data = { 0 };\n\t UINT16 event_num = 0;\n\n\t if(realEventEmpty(EN_TRIP_EVENT, PRINT_CLIENT_NO)) \n\t {\n\t\t return;\n\t }\n\n\t event_num = getRealEventNum(EN_TRIP_EVENT, PRINT_CLIENT_NO);\n\t if(event_num == 0) \n\t {\n\t\t return;\n\t }\n\n\t printHeaderLineNet(cp, slan_item_trip_rpt_header_str.desc[cp->dev_cfg.lang_sel]);\n\n\t printStrLine(cp, item_trip_rpt_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t printStrLine(cp, item_trip_rpt_line_tab1[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t for(i = 0; i < event_num; i++)\n\t {\n\t\t ret = getRealEvent(EN_TRIP_EVENT, PRINT_CLIENT_NO, &event_data, 0);\n\t\t if(ret < 0)\n\t\t {\n\t\t\t continue;\n\t\t }\n\n\t\t printRptItem(cp, &event_data);\n\t }\n\n\t printStrLine(cp, item_trip_rtp_line_tab4[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t printCharLine(cp, WITH_RETURN);\n\n\t return;\n }\n\n LOCAL void printAutoFaultUart(Print *cp)\n  {\n\t  INT32 i = 0, ret = 0; \n\t  FaultPara fault_para = { 0 };\n\t  UINT16 fault_num = 0;\n\t  UINT32 num = 0, m = 0, n = 0;\n\n\t  num = ((PrintRefInfo *)s_ref_tbl_cfg[EN_REF_TBL_WAVE_TITLE].p_ref_info)->entry_num;\n \n\t  if(realFaultEmpty(PRINT_CLIENT_NO)) \n\t  {\n\t\t  return;\n\t  }\n \n\t  fault_num = getRealFaultNum(PRINT_CLIENT_NO);\n\t  if(fault_num == 0) \n\t  {\n\t\t  return;\n\t  }\n \n\t  for(i = 0; i < fault_num; i++)\n\t  {\n\t\t  ret = getRealFaultVal(PRINT_CLIENT_NO, &fault_para, 0);\n\t\t  if(ret < 0)\n\t\t  {\n\t\t\t  continue;\n\t\t  }\n\t\t  memcpy((void*)&cp->wave_data.fault_head, &fault_para,\n\t\t  \t    (UINT32) &((FaultPara *)0)->trip_event_start);\n\t\t  cp->wave_data.fault_head.fan_num = fault_para.fan_num;\n\t\t  cp->wave_data.fault_head.fan_start = fault_para.fan_start;\n\t\t  cp->wave_data.fault_head.para_num = fault_para.para_num;\n\t\t  //自动打印与手动打印一致通过倒序查询，自动打印始终打印最新报告，则偏移为0\n\t\t  putInt16(cp->print_shm_content.print_para_val, (INT32 *)&n, 0);\n\t\t  cp->print_shm_content.print_para_val[2] = 0x0f;\n\t\t  \n\t\t  if (num > 2)\n\t\t  {\n\t\t      for (m=0; m < num-1; m++)\n\t\t\t      cp->print_shm_content.print_para_val[m+3] = m & 0x0f;\n\t\t\t  cp->print_shm_content.print_para_num = m+2;\n\t\t  }\n\t\t  else\n\t\t  {\n\t\t      cp->print_shm_content.print_para_val[3] = 0;\n\t\t\t  cp->print_shm_content.print_para_num = 3;\n\t\t  }\n\t\t  \n\t\t  printOscillogramUart(cp);\n\t  }\n \n\t  return;\n  } \n\n LOCAL void printAutoFaultNet(Print *cp)\n  {\n\t  INT32 i = 0, ret = 0; \n\t  FaultPara fault_para = { 0 };\n\t  UINT16 fault_num = 0;\n\t  UINT32 num = 0, m = 0, n = 0;\n\n\t  num = ((PrintRefInfo *)s_ref_tbl_cfg[EN_REF_TBL_WAVE_TITLE].p_ref_info)->entry_num;\n \n\t  if(realFaultEmpty(PRINT_CLIENT_NO)) \n\t  {\n\t\t  return;\n\t  }\n \n\t  fault_num = getRealFaultNum(PRINT_CLIENT_NO);\n\t  if(fault_num == 0) \n\t  {\n\t\t  return;\n\t  }\n \n\t  for(i = 0; i < fault_num; i++)\n\t  {\n\t\t  ret = getRealFaultVal(PRINT_CLIENT_NO, &fault_para, 0);\n\t\t  if(ret < 0)\n\t\t  {\n\t\t\t  continue;\n\t\t  }\n\t\t  memcpy((void*)&cp->wave_data.fault_head, &fault_para,\n\t\t  \t    (UINT32) &((FaultPara *)0)->trip_event_start);\n\t\t  cp->wave_data.fault_head.fan_num = fault_para.fan_num;\n\t\t  cp->wave_data.fault_head.fan_start = fault_para.fan_start;\n\t\t  cp->wave_data.fault_head.para_num = fault_para.para_num;\n\t\t  //自动打印与手动打印一致通过倒序查询，自动打印始终打印最新报告，则偏移为0\n\t\t  putInt16(cp->print_shm_content.print_para_val, (INT32 *)&n, 0);\n\t\t  cp->print_shm_content.print_para_val[2] = 0x0f;\n\t\t  \n\t\t  if (num > 2)\n\t\t  {\n\t\t      for (m=0; m < num-1; m++)\n\t\t\t      cp->print_shm_content.print_para_val[m+3] = i & 0x0f;\n\t\t\t  cp->print_shm_content.print_para_num = m+2;\n\t\t  }\n\t\t  else\n\t\t  {\n\t\t      cp->print_shm_content.print_para_val[3] = 0;\n\t\t\t  cp->print_shm_content.print_para_num = 3;\n\t\t  }\n\t\t  \n\t\t  printOscillogramNet(cp);\n\t  }\n \n\t  return;\n  } \n\n LOCAL void printAutoSelfsupervUart(Print *cp)\n {\n\t INT32 i = 0, ret = 0;\n\t EventData event_data = { 0 };\n\t UINT16 event_num = 0;\n\n\t if(realEventEmpty(EN_CHECK_EVENT, PRINT_CLIENT_NO)) \n\t {\n\t\t return;\n\t }\n\n\t event_num = getRealEventNum(EN_CHECK_EVENT, PRINT_CLIENT_NO);\n\t if(event_num == 0) \n\t {\n\t\t return;\n\t }\n\n\t printHeaderLineUart(cp, slan_selfcheck_header_str.desc[cp->dev_cfg.lang_sel]);\n\n\t printStrLine(cp, auto_selfcheck_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t printStrLine(cp, auto_selfcheck_line_tab1[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t for(i = 0; i < event_num; i++)\n\t {\n\t\t ret = getRealEvent(EN_CHECK_EVENT, PRINT_CLIENT_NO, &event_data, 0);\n\t\t if(ret < 0) \n\t\t {\n\t\t\t continue;\n\t\t }\n\n\t\t printRptItem(cp,&event_data);\n\t }\n\n\t printStrLine(cp, auto_selfcheck_line_tab4[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t printCharLine(cp, WITH_RETURN);\n\n\t return;\n }\n\n LOCAL void printAutoSelfsupervNet(Print *cp)\n {\n\t INT32 i = 0, ret = 0;\n\t EventData event_data = { 0 };\n\t UINT16 event_num = 0;\n\n\t if(realEventEmpty(EN_CHECK_EVENT, PRINT_CLIENT_NO)) \n\t {\n\t\t return;\n\t }\n\n\t event_num = getRealEventNum(EN_CHECK_EVENT, PRINT_CLIENT_NO);\n\t if(event_num == 0) \n\t {\n\t\t return;\n\t }\n\n\t printHeaderLineNet(cp, slan_selfcheck_header_str.desc[cp->dev_cfg.lang_sel]);\n\n\t printStrLine(cp, auto_selfcheck_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t printStrLine(cp, auto_selfcheck_line_tab1[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t for(i = 0; i < event_num; i++)\n\t {\n\t\t ret = getRealEvent(EN_CHECK_EVENT, PRINT_CLIENT_NO, &event_data, 0);\n\t\t if(ret < 0) \n\t\t {\n\t\t\t continue;\n\t\t }\n\n\t\t printRptItem(cp,&event_data);\n\t }\n\n\t printStrLine(cp, auto_selfcheck_line_tab4[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t printCharLine(cp, WITH_RETURN);\n\n\t return;\n }\n\n LOCAL void printAutoBinchgUart(Print *cp)\n {\n\t INT32 i = 0, ret = 0;\n\t EventData event_data = { 0 };\n\t UINT16 event_num = 0;\n\n\t if(realEventEmpty(EN_BI_EVENT, PRINT_CLIENT_NO)) \n\t {\n\t\t return;\n\t }\n\n\t event_num = getRealEventNum(EN_BI_EVENT, PRINT_CLIENT_NO);\n\t if(event_num == 0) \n\t {\n\t\t return;\n\t }\n\n\t printHeaderLineUart(cp, slan_binchg_header_str.desc[cp->dev_cfg.lang_sel]);\n\n\t printStrLine(cp, binchg_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t printStrLine(cp, binchg_line_tab1[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t for(i = 0; i < event_num; i++)\n\t {\n\t\t ret = getRealEvent(EN_BI_EVENT, PRINT_CLIENT_NO, &event_data, 0);\n\t\t if(ret < 0) \n\t\t {\n\t\t\t continue;\n\t\t }\n\n\t\t printRptItem(cp, &event_data);\n\t }\n\n\t printStrLine(cp, binchg_line_tab4[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t printCharLine(cp, WITH_RETURN);\n\n\t return;\n }\n\n LOCAL void printAutoBinchgNet(Print *cp)\n {\n\t INT32 i = 0, ret = 0;\n\t EventData event_data = { 0 };\n\t UINT16 event_num = 0;\n\n\t if(realEventEmpty(EN_BI_EVENT, PRINT_CLIENT_NO)) \n\t {\n\t\t return;\n\t }\n\n\t event_num = getRealEventNum(EN_BI_EVENT, PRINT_CLIENT_NO);\n\t if(event_num == 0) \n\t {\n\t\t return;\n\t }\n\n\t printHeaderLineNet(cp, slan_binchg_header_str.desc[cp->dev_cfg.lang_sel]);\n\n\t printStrLine(cp, binchg_line_tab0[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\t printStrLine(cp, binchg_line_tab1[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t for(i = 0; i < event_num; i++)\n\t {\n\t\t ret = getRealEvent(EN_BI_EVENT, PRINT_CLIENT_NO, &event_data, 0);\n\t\t if(ret < 0) \n\t\t {\n\t\t\t continue;\n\t\t }\n\n\t\t printRptItem(cp, &event_data);\n\t }\n\n\t printStrLine(cp, binchg_line_tab4[cp->print_method][cp->dev_cfg.lang_sel], WITH_RETURN);\n\n\t printCharLine(cp, WITH_RETURN);\n\n\t return;\n }\n",
					"file": "sy.src/sy.hmi/print/src/printsvr.c",
					"file_size": 411629,
					"file_write_time": 131320621894911738,
					"settings":
					{
						"buffer_size": 386558,
						"encoding": "Western (Windows 1252)",
						"line_ending": "Windows",
						"scratch": true
					}
				},
				{
					"contents": "/*==========================================================================*\n * 文件模块说明: PRINT模块基础模块，包括常用的宏定义及数据结构定义\t\t\t\t*\n * 文件版本: V 1.00\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t*\n * 开发人员: 戴刚\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t*\n * 创建时间: 2015-01-16\t\t\t\t\t\t\t\t\t\t\t\t\t\t*\n * Copyright(c) 1993-2015 Shanghai SHR Electrical Power Technology Co. Ltd. *\n *==========================================================================*/\n\n#ifndef _SHR_PRINT_MODULE_PRINT_BASE_H\n#define _SHR_PRINT_MODULE_PRINT_BASE_H\n\n#ifdef __cplusplus\nextern \"C\"{\n#endif\n\n#include \"syslave.h\"\n#include \"db.h\"\n#include \"setting.h\"\n#include \"ivt.h\"\n#include \"hmicomm.h\"\n#include \"event.h\"\n#include \"uartio.h\"\n#include \"regsignal.h\"\n#include \"mm.h\"\n#include \"dev.h\"\n#include \"taskque.h\"\n#include \"word.h\"\n#include \"sram.h\"\n\n// 打印元件结构体声明\nstruct _print;\n\n// 宏定义\n#define PRINT_MAX_CHAN_NUM\t\t\t4\t\t\t\t\t\t // 最大通道个数\n\n#define PRINT_WAVE_PAGE_MAX         32\t\t\t\t\t\t // 打印最多分页数\n#define PRINT_EACH_PAGE_ANALOG_MAX_NUM    24                 // 每页模拟量最多路数\n#define PRINT_EACH_PAGE_PULSE_MAX_NUM     32                 // 每页打印脉冲最多路数(1长字,便于移位等操作)\n\n#define PRINT_DRAWOFF_SELFSUPERV_ENABLE     0x01\t\t\t // 自检报告使能\n#define PRINT_DRAWOFF_BINCHG_ENABLE         0x02\t\t\t // 变位报告使能\n#define PRINT_DRAWOFF_WAVE_ENABLE           0x04\t\t\t // 波形使能\n#define PRINT_DRAWOFF_SETTING_ENABLE        0x08\t\t\t // 定值使能\n#define PRINT_DRAWOFF_SMPL_ENABLE\t\t\t0x10\t\t\t // 采样值使能\n\n#define PRINT_RESOLUTION\t\t\t\t\t75\t\t\t\t // 打印机图形分辨率\n#define PRINT_WORD_RESOLUTION\t\t\t\t720\t\t\t     // 打印机文字分辨率\n#define PRINT_PAPER_LEN\t\t\t\t\t\t210\t\t\t\t // 打印纸宽度，A4为210mm\n#define PRINT_MEASURE\t\t\t\t\t\t25.4\t\t     // 毫米和英寸之间的单位转换\n#define PRINT_TIME_UNIT\t\t\t\t\t\t8\n#define PAPER_WIDTH                 (8*180)\t\t\t\t\t // 串口打印纸宽度\n\n#define PRINT_BUF_LEN\t\t\t\t8192\t\t\t\t\t // 打印缓冲区大小\n\n#define PRINT_NET_PRINTER_PORT\t\t\t9100\t\t\t\t // 网络打印采用PCL控制方式，端口号为9100\n\n#define ESC\t\t\t\t\t0x1b\n#define FS\t\t\t\t\t0x1c\n\n#define WITHOUT_RETURN\t\t0\n#define WITH_RETURN\t\t\t1\n\n//#define PRINT_DEBUG\n\n#define PRINT_LINE_CHAR_LEN\t\t 120\n#define PRINT_LINE_CHAR_LEN_NET  95\n\n#define PRINT_NET_MEM_SIZE\t\t100000\n\n/* 打印方式 */\nenum\n{\n\tPRINT_UART_PROTOCOL,\n\tPRINT_ETH_PROTOCOL,\n\tPRINT_PROTOCOL_NUM\n};\n\ntypedef void (*PrintFunPtr)();\t\t\t\t\t\t\t\t // 函数指针定义\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // _SHR_PRINT_MODULE_PRINT_MAIN_H\n",
					"file": "sy.src/sy.hmi/print/inc/printbase.h",
					"file_size": 2472,
					"file_write_time": 131263207552921435,
					"settings":
					{
						"buffer_size": 2193,
						"encoding": "Western (Windows 1252)",
						"line_ending": "Windows",
						"scratch": true
					}
				}
			],
			"build_system": "",
			"build_system_choices":
			[
			],
			"build_varint": "",
			"command_palette":
			{
				"height": 104.0,
				"last_filter": "install",
				"selected_items":
				[
					[
						"install",
						"Package Control: Install Package"
					],
					[
						"Cscope: ",
						"Cscope: Search for text string"
					],
					[
						"syntax:c",
						"Set Syntax: C"
					],
					[
						"sy",
						"Set Syntax: C"
					],
					[
						"Package Control: ",
						"Package Control: Install Package"
					],
					[
						"set syntax:c",
						"Set Syntax: C"
					],
					[
						"ins",
						"Package Control: Install Package"
					],
					[
						"x",
						"Set Syntax: XML"
					],
					[
						"make",
						"Set Syntax: Makefile"
					],
					[
						"syntax:make",
						"Set Syntax: Makefile"
					],
					[
						"Package Control: install ",
						"Package Control: Install Package"
					],
					[
						"Package Control: install c",
						"Package Control: Install Package"
					],
					[
						":w",
						":w - Save"
					]
				],
				"width": 376.0
			},
			"console":
			{
				"height": 146.0,
				"history":
				[
					"install package",
					"import urllib.request,os; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ','%20')).read())"
				]
			},
			"distraction_free":
			{
				"menu_visible": true,
				"show_minimap": false,
				"show_open_files": false,
				"show_tabs": false,
				"side_bar_visible": false,
				"status_bar_visible": false
			},
			"expanded_folders":
			[
				"/D/workspace/U22_6IN1",
				"/D/workspace/U22_6IN1/sy.release",
				"/D/workspace/U22_6IN1/sy.release/sy.sys",
				"/D/workspace/U22_6IN1/sy.src",
				"/D/workspace/U22_6IN1/sy.src/sy.hmi",
				"/D/workspace/U22_6IN1/sy.src/sy.hmi/goose",
				"/D/workspace/U22_6IN1/sy.src/sy.hmi/rttask",
				"/D/workspace/U22_6IN1/sy.src/sy.hmi/rttask/src"
			],
			"file_history":
			[
				"/E/msys32/home/wangzhichao/.ssh/id_rsa.pub",
				"/D/SVN/Distribution_Network/sy.src/sy.slave/system/src/slave.c",
				"/D/workspace/Distribution_Network/sy.src/sy.slave/system/src/slave.c",
				"/D/workspace/U22_6IN1/sy.src/sy.hmi/lcd/inc/lcdpage.h",
				"/D/workspace/U22_6IN1/sy.src/sy.hmi/lcd/src/lcdservice.c",
				"/D/workspace/U22_6IN1/sy.release/sy.sys/system/inc/ctrl.h",
				"/D/workspace/U22_6IN1/sy.src/sy.hmi/print/src/printsvr.c",
				"/D/workspace/U22_6IN1/sy.src/sy.hmi/lcd/src/lcdwirediagram.c",
				"/D/workspace/U22_6IN1/sy.src/sy.hmi/print/src/print.c",
				"/D/workspace/U22_6IN1/sy.src/sy.hmi/lcd/src/lcdprinter.c",
				"/D/workspace/U22_6IN1/sy.src/sy.hmi/hmicomm/src/hmicomm.c",
				"/D/workspace/U22_6IN1/sy.src/sy.hmi/hmicomm/inc/hmicomm.h",
				"/D/workspace/U22_6IN1/sy.src/sy.hmi/Makefile",
				"/D/version history/U21_6t1/readme.md",
				"/D/version history/U22_6t1/readme.txt",
				"/D/workspace/U22_6IN1/sy.release/sy.sys/common.gnu/inc/linux/types.h",
				"/D/workspace/U22_6IN1/sy.src/sy.hmi/lcd/src/lcdorder.c",
				"/D/5.Real/Zeitest/U21六统一/UDT-531GE_Ver1.18B1/release/extr_UDT-531GE_Ver1.18B1_2016-09-08_15-27-56/10/config.xml",
				"/D/workspace/U22_6IN1/sy.src/sy.hmi/print/src/printmain.c",
				"/D/workspace/U22_6IN1/sy.src/sy.hmi/rttask/src/comtrade.c",
				"/D/workspace/U22_6IN1/sy.src/sy.hmi/rttask/src/rttask.c",
				"/D/workspace/U22_6IN1/sy.src/sy.hmi/rttask/src/wave.c",
				"/D/workspace/U22_6IN1/sy.src/sy.hmi/lcd/src/lcdreport.c",
				"/E/Download/Clover_v2.3k_r3839_EFI_USB/Clover_v2.3k_r3839_EFI_USB/EFI/CLOVER/config.plist",
				"/D/workspace/U22_6IN1/sy.src/sy.hmi/iec103/src/iec103asdu.c",
				"/D/4开发环境/IEC61850客户端(dfdz2016)/osi_cfg.xml",
				"/D/SVN/U22_6T1/sy.hmi/iec103/src/iec103asdu.c",
				"/D/workspace/U22_6IN1/sy.src/sy.hmi/iec103/src/iec103.c",
				"/D/workspace/U22_6IN1/sy.src/sy.hmi/iec103/src/testshow.c",
				"/C/Users/wangzhichao/Desktop/有对有错对应的串口.txt",
				"/D/5.Real/Zeitest/U22六统一/母线打印UDB-501A-DG-G-MPX_Ver1.00B1/符俊backup/config.xml",
				"/D/5.Real/Zeitest/U22六统一/母线打印UDB-501A-DG-G-MPX_Ver1.00B1/符俊backup/配置文件/extr_UDB-501A-DG-G-MPX_Debug_V1.00/5/config.xml",
				"/C/Users/wangzhichao/Desktop/有对有错.txt",
				"/F/CLOVER/config.plist",
				"/E/Download/（管理员运行）win 10 专业版(10586.36或14393.0以上)获取数字数字权利/（管理员运行）win 10 专业版(10586.36或14393.0以上)获取数字数字权利.bat",
				"/D/workspace/U22_6IN1/sy.src/sy.hmi/lcd/src/lcdhmi.cpp",
				"/D/workspace/U22_6IN1/U22_6IN1.sublime-project",
				"/D/SVN/U22_6T1/sy.hmi/lcd/src/lcdwirediagram.c",
				"/D/workspace/U22_6IN1/sy.src/sy.hmi/lcd/src/lcdhome.c",
				"/D/workspace/U22_6IN1/sy.src/sy.hmi/lcd/lcdwirediagram_newrebuild.c",
				"/D/workspace/U22_6IN1/sy.src/sy.hmi/lcd/src/lcdversion.c",
				"/D/workspace/U22_6IN1/sy.src/sy.hmi/lcd/src/lcdgrid.c",
				"/D/workspace/U21_6IN1/sy.src/sy.hmi/print/src/printsvr.c",
				"/D/5.Real/Zeitest/U22 Transformer print/feedback/session3.log",
				"/C/Users/wangzhichao/Desktop/U22 Transformer print/feedback/打印自定义控制字.log",
				"/C/Users/wangzhichao/Desktop/U22 Transformer print/feedback/session3.log",
				"/C/Users/wangzhichao/Desktop/U22 Transformer print/feedback/打印跳闸矩阵.log",
				"/D/workspace/U22_6IN1/sy.src/sy.hmi/lcd/lcdwirediagram_new.c",
				"/C/Users/wangzhichao/Desktop/U22 Transformer print/feedback/session4.log",
				"/D/5.Real/2.LCD/5.变压器录波/UDT531G_wave/fpk及scd/UDT-531T1-DA-G变压器保护装置_工程化_六统一版_Ver1.00B5/UDT-531T1-DA-G变压器保护装置_工程化_六统一版_Ver1.00B5/103cfg.txt",
				"/C/Users/wangzhichao/Desktop/lcd/src/lcdpassword.c",
				"/C/Users/wangzhichao/Desktop/Localinst/103inf.txt",
				"/C/Users/wangzhichao/Desktop/lcd/src/lcdwirediagram.c",
				"/D/workspace/U22/sy.src/sy.hmi/print/makefile",
				"/D/workspace/U22_6IN1/sy.src/sy.hmi/print/makefile",
				"/D/workspace/U22_6IN1/sy.src/sy.hmi/rttask/src/sysntp.c",
				"/D/workspace/U22_6t1/U22_6t1.sublime-project",
				"/C/Users/wangzhichao/Desktop/wave/comtrade/43809_20010302_050321_989.rpt",
				"/D/workspace/U22_6t1/sy.src/sy.hmi/print/src/printsvr.c",
				"/C/Users/wangzhichao/Desktop/wave/comtrade/43810_20010302_062003_497.rpt",
				"/C/Users/wangzhichao/Desktop/wave/comtrade/43809_20010302_050321_989.cfg",
				"/C/Users/wangzhichao/Desktop/wave/comtrade/43809_20010302_050321_989.des",
				"/C/Users/wangzhichao/Desktop/wave/comtrade/43809_20010302_050321_989.hdr",
				"/D/workspace/U22/sy.src/Makefile",
				"/D/workspace/U22_6t1/sy.src/vxworks.mk",
				"/D/workspace/U22/sy.src/vxworks.mk",
				"/D/workspace/Localization/sy.src/sy.hmi/lcd/inc/lcd.h",
				"/D/workspace/Localization/sy.src/sy.hmi/rttask/inc/sramp.h",
				"/D/workspace/Localization/sy.src/sy.hmi/lcd/src/lcd.c",
				"/D/workspace/Localization/sy.src/sy.hmi/Makefile",
				"/C/Users/wangzhichao/Desktop/led说明.txt",
				"/D/workspace/Localization/sy.release/sy.sys/system/inc/ivt.h",
				"/D/workspace/Localization/sy.src/sy.hmi/lcd/src/lcdservice.c",
				"/D/workspace/Localization/sy.src/sy.hmi/iec103/src/iec103asdu.c",
				"/D/workspace/Localization/sy.src/sy.hmi/iec103/src/nr103asdu.c",
				"/D/workspace/Localization/sy.src/sy.hmi/iec103/src/iec103.c",
				"/D/workspace/Localization/sy.src/sy.hmi/lcd - 副本/inc/lcd.h",
				"/D/workspace/Localization/sy.src/sy.hmi/lcd - 副本/src/lcd.c",
				"/D/workspace/Localization/sy.src/sy.hmi/lcd/inc/lcdbase.h",
				"/D/workspace/Localization/sy.src/sy.hmi/lcd/inc/lcdservice.h",
				"/D/workspace/U21/sy.src/sy.hmi/lcd/src/lcdorder.c",
				"/D/workspace/U21/sy.src/sy.hmi/lcd/src/lcdbase.c",
				"/D/SVN/U21/sy.hmi/lcd/src/lcdorder.c",
				"/C/Users/wangzhichao/Desktop/开会",
				"/D/5.Real/Zeitest/103就地化/calc.xml",
				"/D/workspace/Localization/sy.src/sy.hmi/iec103/src/appinit.c",
				"/D/workspace/Localization/sy.src/sy.hmi/hmicomm/src/hmicomm.c",
				"/D/workspace/Localization/sy.src/sy.hmi/lcd/src/lcdmain.c",
				"/E/apprentice/Computer/C programming/教材/C Primer Plus/CPrimerPlus6E_code/Ch17/films2.c",
				"/C/Users/wangzhichao/Desktop/UDT523-1.01.txt",
				"/C/Users/wangzhichao/Desktop/log.txt",
				"/D/workspace/Localization/sy.src/sy.hmi/lcd/inc/lcddebug.h",
				"/D/workspace/Localization/sy.src/sy.hmi/lcd/inc/lcdwirediagram.h",
				"/D/workspace/Localization/sy.src/sy.hmi/lcd/inc/lcdversion.h",
				"/D/workspace/Localization/sy.src/sy.hmi/lcd/inc/lcduigen.h",
				"/D/workspace/Localization/sy.src/sy.hmi/lcd/inc/lcduart.h",
				"/D/workspace/Localization/sy.src/sy.hmi/lcd/inc/lcdstatus.h",
				"/D/workspace/Localization/sy.src/sy.hmi/lcd/inc/lcdset.h",
				"/D/workspace/Localization/sy.src/sy.hmi/lcd/inc/lcdreport.h",
				"/D/workspace/Localization/sy.src/sy.hmi/lcd/inc/lcdprinter.h",
				"/D/workspace/Localization/sy.src/sy.hmi/lcd/inc/lcdpassword.h",
				"/D/workspace/Localization/sy.src/sy.hmi/lcd/inc/lcdpage.h",
				"/D/workspace/Localization/sy.src/sy.hmi/lcd/inc/lcdorder.h",
				"/D/workspace/Localization/sy.src/sy.hmi/lcd/inc/lcdnews.h",
				"/D/workspace/Localization/sy.src/sy.hmi/lcd/inc/lcdmenu.h",
				"/D/workspace/Localization/sy.src/sy.hmi/lcd/inc/lcdmain.h",
				"/D/workspace/Localization/sy.src/sy.hmi/lcd/inc/lcdhome.h",
				"/D/workspace/Localization/sy.src/sy.hmi/lcd/inc/lcdhmi.h",
				"/D/workspace/Localization/sy.src/sy.hmi/lcd/inc/lcdgrid.h",
				"/D/workspace/Localization/sy.src/sy.hmi/lcd/inc/lcdglobal.h",
				"/D/workspace/Localization/sy.src/sy.hmi/lcd/inc/lcdedit.h",
				"/D/workspace/Localization/sy.src/sy.hmi/lcd/inc/lcddraw.h",
				"/D/workspace/Localization/sy.src/sy.hmi/lcd/inc/lcdctrl.h",
				"/D/workspace/Localization/sy.src/sy.hmi/lcd/inc/lcdconfig.h",
				"/D/workspace/Localization/sy.src/sy.hmi/lcd/src/lcdwirediagram.c",
				"/D/workspace/Localization/sy.src/sy.hmi/lcd/src/lcdorder.c",
				"/D/workspace/Localization/sy.src/sy.hmi/lcd/src/lcdconfig.cpp",
				"/D/workspace/Localization/sy.src/sy.hmi/lcd/lcdconfig.cpp",
				"/D/workspace/Localization/sy.src/sy.hmi/1.txt",
				"/D/workspace/Localization/sy.src/sy.hmi/lcd/Makefile",
				"/D/workspace/Localization/sy.src/sy.hmi/rttask/src/rtcommon.c",
				"/D/workspace/Localization/sy.src/sy.hmi/rttask/src/led.c",
				"/D/workspace/Localization/sy.src/sy.hmi/rttask/src/event.c",
				"/D/workspace/Localization/sy.src/sy.hmi/lcd/src/lcdnews.c",
				"/D/5.Real/Zeitest/就地化/UDL511/新建文件夹/extr_UDL-511_B1/10/config.xml",
				"/E/apprentice/Computer/C programming/solutions/CPP/ch15/power.c",
				"/D/SVN/U21/sy.hmi/Makefile",
				"/E/apprentice/Computer/C programming/solutions/CPP/ch15/5.c"
			],
			"find":
			{
				"height": 30.0
			},
			"find_in_files":
			{
				"height": 90.0,
				"where_history":
				[
					"D:\\workspace\\U22_6IN1\\sy.src\\sy.hmi\\print",
					"D:\\workspace\\U22_6IN1\\sy.src\\sy.hmi\\rttask",
					"D:\\workspace\\U22_6IN1\\sy.src",
					"D:\\workspace\\U22_6IN1\\sy.src\\sy.hmi\\lcd",
					"D:\\workspace\\U22_6IN1",
					"D:\\workspace\\Localization\\sy.src\\sy.hmi\\iec103",
					"D:\\workspace\\Localization",
					"D:\\workspace\\Localization\\sy.src",
					"D:\\workspace\\Localization",
					"D:\\workspace\\Localization\\sy.src\\sy.hmi\\lcd",
					"D:\\workspace\\Localization",
					"D:\\workspace\\Localization\\sy.release\\sy.sys\\sy6101L\\lib",
					"D:\\workspace\\Localization",
					"D:\\workspace\\Localization\\sy.src\\sy.hmi\\lcd",
					"D:\\workspace\\Localization\\sy.src",
					"D:\\workspace\\Localization",
					"D:\\workspace\\Localization\\sy.src\\sy.hmi\\lcd",
					"D:\\workspace\\U21_4t1\\sy.src",
					"D:\\workspace\\U21_4t1\\sy.src\\sy.hmi\\lcd",
					"D:\\workspace\\U21_4t1\\sy.src\\sy.hmi\\lcd\\src",
					"D:\\workspace\\U21_4t1\\sy.src",
					"D:\\workspace\\U21_4t1",
					"D:\\workspace\\U21_4t1\\sy.src\\sy.hmi\\lcd",
					"D:\\workspace\\U21_4t1\\sy.src\\sy.hmi\\lcd\\src",
					"D:\\3.platform resource\\5试验fpk\\UDC-311AG_Ver1.19",
					"D:\\3.platform resource\\赵小伟版本程序\\u21 工程\\iec103",
					"D:\\workspace,D:\\3.platform resource\\赵小伟版本程序,D:\\3.platform resource\\邱大为版本程序",
					"D:\\workspace,D:\\3.platform resource\\赵小伟版本程序",
					"D:\\workspace\\U21_6IN1",
					"C:\\Users\\wangzhichao\\Desktop\\代码改动",
					"D:\\workspace\\U21_6IN1"
				]
			},
			"find_state":
			{
				"case_sensitive": true,
				"find_history":
				[
					"printGetWaveFile",
					"printAllDrawoffTripRpt",
					"printDrawoffTripRpt",
					"printAllDrawoffTripRpt",
					"LOCAL",
					"printAllDrawoffTripRpt",
					"printDrawoffTripRpt",
					"printf(\"method = %d, lang_sel = %d\\n\", cp->print_method, cp->dev_cfg.lang_sel)",
					"print_method",
					"runSyncVar",
					"printOneGrpSettingMatrixes",
					"printOneGrpSettings",
					"draw",
					"draw_index",
					"lcdUiWireDiagramDrawBasicGraphMain",
					"形标度组",
					"printWaveScale",
					"printWaveForm",
					"printSetWaveAxis",
					"标度",
					"/V",
					"格",
					"王",
					"王志超",
					"Dec",
					"modi",
					"设定",
					"宽",
					"g_print_executing",
					"B42.Vol0.smpl_ua",
					"=\"",
					"\"B42.Vol0.smpl_u",
					"B42.Vol0.smpl_ua_sta",
					"B42.Vol0.smpl_ua",
					"Vol0",
					"H_PRIM_IE",
					"H_OC1_t1",
					"单位",
					"闰",
					"printEventChangeState",
					"printEventInitStateItem",
					"printEventInitState",
					"printDrawoffTripRptItemUart",
					"printDrawoffTripRptUart",
					"printDrawoffTripRpt",
					"return",
					"tran_val",
					"readPrintShmCmd",
					"getUsCnt",
					"printTimerTask",
					"tran_val",
					"p_ref_info_ana",
					"printTimerTask",
					"lcdUiSendPrintCmd",
					"printSettings",
					"print",
					"shm_content",
					"1000",
					"selSetSettingBitString",
					"selSetSetting",
					"procGenWriSelSetting",
					"selSetSetting",
					"selSetSettingBitString",
					"selSetSetting",
					"procGenWriSelSetting",
					"p_gin",
					"selSetSettingBitString",
					"selSetSetting",
					"procGenWriSelSetting",
					"selSetSetting",
					"procGenWriSelSetting",
					"procGenWrSel",
					"procGenWriExeOrEsc",
					"procGenWriSelSetting",
					"lcdUiWireDiagramShowModeKey",
					"Type",
					"set_val",
					"local_set_value",
					"local_setting_value",
					"offset",
					"printOneGrpSettings",
					"local_setting_value",
					"execute",
					"local_setting_value",
					"printSettings",
					"printSettingsUart",
					"printSettings",
					"printWaveSmplUart",
					"slan_wave_per_unit_descrip",
					"VerSion_PARAMETER",
					"lcdUiWireDiagramShowModeKey",
					"start_sec_index",
					"case",
					"3-1",
					"printIdentityNoUart",
					"start_sec_index is",
					"lcdUiWireDiagramShowModeKey",
					"the section need",
					"lcdUiWireDiagramCalcSecNum",
					"sec_num",
					"lcdUiWireDiagramShowModeKey",
					"lcdUiWireDiagramShowModeShow",
					");\n",
					"LCD_TRACE2",
					"lcdUiWireDiagramShowModeKey",
					"lcdWireDiagramYkCallBack",
					"before",
					"lcdUiWireDiagramShowModeKey",
					"show_sec_num",
					"lcdUiWireDiagramShowModeShow",
					"slan_fpga_crc",
					"is_print_zero_scale",
					"\t\t\t",
					"is_print_zero_scale",
					"printWaveFormUart",
					"printEventInitStateItem",
					"slan_active_section_str",
					"printOneGrpSettingMatrixes",
					"header name : ",
					"p_set_item_unbits_offset",
					"print_item_num",
					"print",
					"printf",
					"print_item_num",
					"p_set_item_unbits_offset",
					"p_setting_item_offset",
					"sub_grp_num",
					"p_set_item_unbits_offset"
				],
				"highlight": true,
				"in_selection": false,
				"preserve_case": false,
				"regex": true,
				"replace_history":
				[
					"sntpTask",
					"LCD_PSD_DBG_MSG",
					"",
					"LCD_MAX_FACTOR_ADJUST",
					"crc_table_ini",
					"LCD_FILE_INI",
					"LCD_INI_BUFFER_SIZE",
					"LCD_INI_DEBUG",
					"INI_BUFFER_SIZE",
					"PRINTINFO",
					"crc32_calc_ini",
					"crc_table_ini",
					"BUFFER_SIZE",
					"printf",
					"U",
					"INT8",
					"INT32",
					"int",
					"unsigned int",
					"short",
					"char",
					"UINT",
					"INT8",
					"INT32",
					"UINT8",
					"INT8",
					"B7",
					"B6",
					"dec_ans",
					"",
					" ",
					",",
					" ",
					",",
					"",
					"swc_1_horgw1",
					"swc_2_horgw1",
					"swc_3_horgw1",
					"add",
					"set",
					" ",
					"",
					" ",
					"service",
					" "
				],
				"reverse": false,
				"show_context": true,
				"use_buffer2": true,
				"whole_word": false,
				"wrap": false
			},
			"groups":
			[
				{
					"selected": 4,
					"sheets":
					[
						{
							"buffer": 0,
							"file": "sy.src/sy.hmi/Makefile",
							"semi_transient": false,
							"settings":
							{
								"buffer_size": 1832,
								"regions":
								{
								},
								"selection":
								[
									[
										895,
										895
									]
								],
								"settings":
								{
									"bracket_highlighter.busy": false,
									"bracket_highlighter.locations":
									{
										"close":
										{
										},
										"icon":
										{
										},
										"open":
										{
										},
										"unmatched":
										{
										}
									},
									"bracket_highlighter.regions":
									[
										"bh_round",
										"bh_round_center",
										"bh_round_open",
										"bh_round_close",
										"bh_round_content",
										"bh_angle",
										"bh_angle_center",
										"bh_angle_open",
										"bh_angle_close",
										"bh_angle_content",
										"bh_curly",
										"bh_curly_center",
										"bh_curly_open",
										"bh_curly_close",
										"bh_curly_content",
										"bh_default",
										"bh_default_center",
										"bh_default_open",
										"bh_default_close",
										"bh_default_content",
										"bh_square",
										"bh_square_center",
										"bh_square_open",
										"bh_square_close",
										"bh_square_content",
										"bh_single_quote",
										"bh_single_quote_center",
										"bh_single_quote_open",
										"bh_single_quote_close",
										"bh_single_quote_content",
										"bh_unmatched",
										"bh_unmatched_center",
										"bh_unmatched_open",
										"bh_unmatched_close",
										"bh_unmatched_content",
										"bh_regex",
										"bh_regex_center",
										"bh_regex_open",
										"bh_regex_close",
										"bh_regex_content",
										"bh_c_define",
										"bh_c_define_center",
										"bh_c_define_open",
										"bh_c_define_close",
										"bh_c_define_content",
										"bh_tag",
										"bh_tag_center",
										"bh_tag_open",
										"bh_tag_close",
										"bh_tag_content",
										"bh_double_quote",
										"bh_double_quote_center",
										"bh_double_quote_open",
										"bh_double_quote_close",
										"bh_double_quote_content"
									],
									"origin_encoding": "ASCII",
									"syntax": "Packages/Makefile/Makefile.sublime-syntax"
								},
								"translation.x": 0.0,
								"translation.y": 330.0,
								"zoom_level": 1.0
							},
							"stack_index": 1,
							"type": "text"
						},
						{
							"buffer": 1,
							"file": "sy.src/sy.hmi/lcd/src/lcdconfig.cpp",
							"semi_transient": false,
							"settings":
							{
								"buffer_size": 12683,
								"regions":
								{
								},
								"selection":
								[
									[
										4163,
										4163
									]
								],
								"settings":
								{
									"bracket_highlighter.busy": false,
									"bracket_highlighter.locations":
									{
										"close":
										{
											"1":
											[
												4519,
												4520
											]
										},
										"icon":
										{
											"1":
											[
												"Packages/BracketHighlighter/icons/curly_bracket.png",
												"brackethighlighter.default"
											]
										},
										"open":
										{
											"1":
											[
												4423,
												4424
											]
										},
										"unmatched":
										{
										}
									},
									"bracket_highlighter.regions":
									[
										"bh_round",
										"bh_round_center",
										"bh_round_open",
										"bh_round_close",
										"bh_round_content",
										"bh_angle",
										"bh_angle_center",
										"bh_angle_open",
										"bh_angle_close",
										"bh_angle_content",
										"bh_curly",
										"bh_curly_center",
										"bh_curly_open",
										"bh_curly_close",
										"bh_curly_content",
										"bh_default",
										"bh_default_center",
										"bh_default_open",
										"bh_default_close",
										"bh_default_content",
										"bh_square",
										"bh_square_center",
										"bh_square_open",
										"bh_square_close",
										"bh_square_content",
										"bh_single_quote",
										"bh_single_quote_center",
										"bh_single_quote_open",
										"bh_single_quote_close",
										"bh_single_quote_content",
										"bh_unmatched",
										"bh_unmatched_center",
										"bh_unmatched_open",
										"bh_unmatched_close",
										"bh_unmatched_content",
										"bh_regex",
										"bh_regex_center",
										"bh_regex_open",
										"bh_regex_close",
										"bh_regex_content",
										"bh_c_define",
										"bh_c_define_center",
										"bh_c_define_open",
										"bh_c_define_close",
										"bh_c_define_content",
										"bh_tag",
										"bh_tag_center",
										"bh_tag_open",
										"bh_tag_close",
										"bh_tag_content",
										"bh_double_quote",
										"bh_double_quote_center",
										"bh_double_quote_open",
										"bh_double_quote_close",
										"bh_double_quote_content"
									],
									"in_converting": true,
									"origin_encoding": "GB2312",
									"syntax": "Packages/C++/C++.sublime-syntax",
									"translate_tabs_to_spaces": false
								},
								"translation.x": 0.0,
								"translation.y": 3721.0,
								"zoom_level": 1.0
							},
							"stack_index": 4,
							"type": "text"
						},
						{
							"buffer": 2,
							"file": "sy.src/sy.hmi/rttask/src/led.c",
							"semi_transient": false,
							"settings":
							{
								"buffer_size": 15288,
								"regions":
								{
								},
								"selection":
								[
									[
										5039,
										5039
									]
								],
								"settings":
								{
									"bracket_highlighter.busy": false,
									"bracket_highlighter.locations":
									{
										"close":
										{
											"1":
											[
												5269,
												5270
											]
										},
										"icon":
										{
											"1":
											[
												"Packages/BracketHighlighter/icons/curly_bracket.png",
												"brackethighlighter.default"
											]
										},
										"open":
										{
											"1":
											[
												4105,
												4106
											]
										},
										"unmatched":
										{
										}
									},
									"bracket_highlighter.regions":
									[
										"bh_round",
										"bh_round_center",
										"bh_round_open",
										"bh_round_close",
										"bh_round_content",
										"bh_angle",
										"bh_angle_center",
										"bh_angle_open",
										"bh_angle_close",
										"bh_angle_content",
										"bh_curly",
										"bh_curly_center",
										"bh_curly_open",
										"bh_curly_close",
										"bh_curly_content",
										"bh_default",
										"bh_default_center",
										"bh_default_open",
										"bh_default_close",
										"bh_default_content",
										"bh_square",
										"bh_square_center",
										"bh_square_open",
										"bh_square_close",
										"bh_square_content",
										"bh_single_quote",
										"bh_single_quote_center",
										"bh_single_quote_open",
										"bh_single_quote_close",
										"bh_single_quote_content",
										"bh_unmatched",
										"bh_unmatched_center",
										"bh_unmatched_open",
										"bh_unmatched_close",
										"bh_unmatched_content",
										"bh_regex",
										"bh_regex_center",
										"bh_regex_open",
										"bh_regex_close",
										"bh_regex_content",
										"bh_c_define",
										"bh_c_define_center",
										"bh_c_define_open",
										"bh_c_define_close",
										"bh_c_define_content",
										"bh_tag",
										"bh_tag_center",
										"bh_tag_open",
										"bh_tag_close",
										"bh_tag_content",
										"bh_double_quote",
										"bh_double_quote_center",
										"bh_double_quote_open",
										"bh_double_quote_close",
										"bh_double_quote_content"
									],
									"syntax": "Packages/C++/C.sublime-syntax",
									"translate_tabs_to_spaces": false
								},
								"translation.x": 0.0,
								"translation.y": 5141.0,
								"zoom_level": 1.0
							},
							"stack_index": 6,
							"type": "text"
						},
						{
							"buffer": 3,
							"file": "sy.src/sy.hmi/rttask/inc/led.h",
							"semi_transient": false,
							"settings":
							{
								"buffer_size": 1703,
								"regions":
								{
								},
								"selection":
								[
									[
										80,
										80
									]
								],
								"settings":
								{
									"bracket_highlighter.busy": false,
									"bracket_highlighter.locations":
									{
										"close":
										{
										},
										"icon":
										{
										},
										"open":
										{
										},
										"unmatched":
										{
											"1":
											[
												72,
												73
											]
										}
									},
									"bracket_highlighter.regions":
									[
										"bh_round",
										"bh_round_center",
										"bh_round_open",
										"bh_round_close",
										"bh_round_content",
										"bh_angle",
										"bh_angle_center",
										"bh_angle_open",
										"bh_angle_close",
										"bh_angle_content",
										"bh_curly",
										"bh_curly_center",
										"bh_curly_open",
										"bh_curly_close",
										"bh_curly_content",
										"bh_default",
										"bh_default_center",
										"bh_default_open",
										"bh_default_close",
										"bh_default_content",
										"bh_square",
										"bh_square_center",
										"bh_square_open",
										"bh_square_close",
										"bh_square_content",
										"bh_single_quote",
										"bh_single_quote_center",
										"bh_single_quote_open",
										"bh_single_quote_close",
										"bh_single_quote_content",
										"bh_unmatched",
										"bh_unmatched_center",
										"bh_unmatched_open",
										"bh_unmatched_close",
										"bh_unmatched_content",
										"bh_regex",
										"bh_regex_center",
										"bh_regex_open",
										"bh_regex_close",
										"bh_regex_content",
										"bh_c_define",
										"bh_c_define_center",
										"bh_c_define_open",
										"bh_c_define_close",
										"bh_c_define_content",
										"bh_tag",
										"bh_tag_center",
										"bh_tag_open",
										"bh_tag_close",
										"bh_tag_content",
										"bh_double_quote",
										"bh_double_quote_center",
										"bh_double_quote_open",
										"bh_double_quote_close",
										"bh_double_quote_content"
									],
									"syntax": "Packages/C++/C++.sublime-syntax",
									"translate_tabs_to_spaces": false
								},
								"translation.x": 0.0,
								"translation.y": 0.0,
								"zoom_level": 1.0
							},
							"stack_index": 5,
							"type": "text"
						},
						{
							"buffer": 4,
							"file": "sy.src/sy.hmi/lcd/src/lcdprinter.c",
							"semi_transient": false,
							"settings":
							{
								"buffer_size": 30586,
								"regions":
								{
								},
								"selection":
								[
									[
										27757,
										27757
									]
								],
								"settings":
								{
									"bracket_highlighter.busy": false,
									"bracket_highlighter.locations":
									{
										"close":
										{
											"1":
											[
												27920,
												27921
											]
										},
										"icon":
										{
											"1":
											[
												"Packages/BracketHighlighter/icons/curly_bracket.png",
												"brackethighlighter.default"
											]
										},
										"open":
										{
											"1":
											[
												27555,
												27556
											]
										},
										"unmatched":
										{
										}
									},
									"bracket_highlighter.regions":
									[
										"bh_round",
										"bh_round_center",
										"bh_round_open",
										"bh_round_close",
										"bh_round_content",
										"bh_angle",
										"bh_angle_center",
										"bh_angle_open",
										"bh_angle_close",
										"bh_angle_content",
										"bh_curly",
										"bh_curly_center",
										"bh_curly_open",
										"bh_curly_close",
										"bh_curly_content",
										"bh_default",
										"bh_default_center",
										"bh_default_open",
										"bh_default_close",
										"bh_default_content",
										"bh_square",
										"bh_square_center",
										"bh_square_open",
										"bh_square_close",
										"bh_square_content",
										"bh_single_quote",
										"bh_single_quote_center",
										"bh_single_quote_open",
										"bh_single_quote_close",
										"bh_single_quote_content",
										"bh_unmatched",
										"bh_unmatched_center",
										"bh_unmatched_open",
										"bh_unmatched_close",
										"bh_unmatched_content",
										"bh_regex",
										"bh_regex_center",
										"bh_regex_open",
										"bh_regex_close",
										"bh_regex_content",
										"bh_c_define",
										"bh_c_define_center",
										"bh_c_define_open",
										"bh_c_define_close",
										"bh_c_define_content",
										"bh_tag",
										"bh_tag_center",
										"bh_tag_open",
										"bh_tag_close",
										"bh_tag_content",
										"bh_double_quote",
										"bh_double_quote_center",
										"bh_double_quote_open",
										"bh_double_quote_close",
										"bh_double_quote_content"
									],
									"in_converting": true,
									"origin_encoding": "GB2312",
									"syntax": "Packages/C++/C.sublime-syntax",
									"translate_tabs_to_spaces": false
								},
								"translation.x": 0.0,
								"translation.y": 25314.0,
								"zoom_level": 1.0
							},
							"stack_index": 0,
							"type": "text"
						}
					]
				},
				{
					"selected": 1,
					"sheets":
					[
						{
							"buffer": 5,
							"file": "sy.src/sy.hmi/print/src/printsvr.c",
							"semi_transient": false,
							"settings":
							{
								"buffer_size": 386558,
								"regions":
								{
								},
								"selection":
								[
									[
										194195,
										194195
									]
								],
								"settings":
								{
									"bracket_highlighter.busy": false,
									"bracket_highlighter.locations":
									{
										"close":
										{
											"1":
											[
												194207,
												194208
											]
										},
										"icon":
										{
											"1":
											[
												"Packages/BracketHighlighter/icons/round_bracket.png",
												"brackethighlighter.default"
											]
										},
										"open":
										{
											"1":
											[
												194137,
												194138
											]
										},
										"unmatched":
										{
										}
									},
									"bracket_highlighter.regions":
									[
										"bh_round",
										"bh_round_center",
										"bh_round_open",
										"bh_round_close",
										"bh_round_content",
										"bh_angle",
										"bh_angle_center",
										"bh_angle_open",
										"bh_angle_close",
										"bh_angle_content",
										"bh_curly",
										"bh_curly_center",
										"bh_curly_open",
										"bh_curly_close",
										"bh_curly_content",
										"bh_default",
										"bh_default_center",
										"bh_default_open",
										"bh_default_close",
										"bh_default_content",
										"bh_square",
										"bh_square_center",
										"bh_square_open",
										"bh_square_close",
										"bh_square_content",
										"bh_single_quote",
										"bh_single_quote_center",
										"bh_single_quote_open",
										"bh_single_quote_close",
										"bh_single_quote_content",
										"bh_unmatched",
										"bh_unmatched_center",
										"bh_unmatched_open",
										"bh_unmatched_close",
										"bh_unmatched_content",
										"bh_regex",
										"bh_regex_center",
										"bh_regex_open",
										"bh_regex_close",
										"bh_regex_content",
										"bh_c_define",
										"bh_c_define_center",
										"bh_c_define_open",
										"bh_c_define_close",
										"bh_c_define_content",
										"bh_tag",
										"bh_tag_center",
										"bh_tag_open",
										"bh_tag_close",
										"bh_tag_content",
										"bh_double_quote",
										"bh_double_quote_center",
										"bh_double_quote_open",
										"bh_double_quote_close",
										"bh_double_quote_content"
									],
									"in_converting": true,
									"origin_encoding": "GB2312",
									"revert_to_scratch": true,
									"syntax": "Packages/C++/C.sublime-syntax",
									"translate_tabs_to_spaces": false
								},
								"translation.x": 0.0,
								"translation.y": 124424.0,
								"zoom_level": 1.0
							},
							"stack_index": 3,
							"type": "text"
						},
						{
							"buffer": 6,
							"file": "sy.src/sy.hmi/print/inc/printbase.h",
							"semi_transient": false,
							"settings":
							{
								"buffer_size": 2193,
								"regions":
								{
								},
								"selection":
								[
									[
										1115,
										1143
									]
								],
								"settings":
								{
									"bracket_highlighter.busy": false,
									"bracket_highlighter.locations":
									{
										"close":
										{
										},
										"icon":
										{
										},
										"open":
										{
										},
										"unmatched":
										{
										}
									},
									"bracket_highlighter.regions":
									[
										"bh_round",
										"bh_round_center",
										"bh_round_open",
										"bh_round_close",
										"bh_round_content",
										"bh_angle",
										"bh_angle_center",
										"bh_angle_open",
										"bh_angle_close",
										"bh_angle_content",
										"bh_curly",
										"bh_curly_center",
										"bh_curly_open",
										"bh_curly_close",
										"bh_curly_content",
										"bh_default",
										"bh_default_center",
										"bh_default_open",
										"bh_default_close",
										"bh_default_content",
										"bh_square",
										"bh_square_center",
										"bh_square_open",
										"bh_square_close",
										"bh_square_content",
										"bh_single_quote",
										"bh_single_quote_center",
										"bh_single_quote_open",
										"bh_single_quote_close",
										"bh_single_quote_content",
										"bh_unmatched",
										"bh_unmatched_center",
										"bh_unmatched_open",
										"bh_unmatched_close",
										"bh_unmatched_content",
										"bh_regex",
										"bh_regex_center",
										"bh_regex_open",
										"bh_regex_close",
										"bh_regex_content",
										"bh_c_define",
										"bh_c_define_center",
										"bh_c_define_open",
										"bh_c_define_close",
										"bh_c_define_content",
										"bh_tag",
										"bh_tag_center",
										"bh_tag_open",
										"bh_tag_close",
										"bh_tag_content",
										"bh_double_quote",
										"bh_double_quote_center",
										"bh_double_quote_open",
										"bh_double_quote_close",
										"bh_double_quote_content"
									],
									"in_converting": true,
									"origin_encoding": "GB2312",
									"syntax": "Packages/C++/C++.sublime-syntax",
									"translate_tabs_to_spaces": true
								},
								"translation.x": 0.0,
								"translation.y": 564.0,
								"zoom_level": 1.0
							},
							"stack_index": 2,
							"type": "text"
						}
					]
				}
			],
			"incremental_find":
			{
				"height": 30.0
			},
			"input":
			{
				"height": 36.0
			},
			"layout":
			{
				"cells":
				[
					[
						0,
						0,
						1,
						1
					],
					[
						1,
						0,
						2,
						1
					]
				],
				"cols":
				[
					0.0,
					0.891608391608,
					1.0
				],
				"rows":
				[
					0.0,
					1.0
				]
			},
			"menu_visible": true,
			"output.exec":
			{
				"height": 30.0
			},
			"output.find_results":
			{
				"height": 0.0
			},
			"output.unsaved_changes":
			{
				"height": 142.0
			},
			"pinned_build_system": "Packages/D/D.sublime-build",
			"position": "0,2,3,-32000,-32000,-1,-1,768,125,62,892",
			"project": "U22_6IN1.sublime-project",
			"replace":
			{
				"height": 56.0
			},
			"save_all_on_build": true,
			"select_file":
			{
				"height": 0.0,
				"last_filter": "",
				"selected_items":
				[
					[
						"",
						"sy.release\\sy.sys\\common.gnu\\inc\\cmd_confdefs.h"
					]
				],
				"width": 0.0
			},
			"select_project":
			{
				"height": 500.0,
				"last_filter": "",
				"selected_items":
				[
					[
						"",
						"D:\\workspace\\Distribution_Network\\distribution_network.sublime-project"
					]
				],
				"width": 380.0
			},
			"select_symbol":
			{
				"height": 392.0,
				"last_filter": "",
				"selected_items":
				[
				],
				"width": 520.0
			},
			"selected_group": 0,
			"settings":
			{
			},
			"show_minimap": true,
			"show_open_files": false,
			"show_tabs": true,
			"side_bar_visible": true,
			"side_bar_width": 222.0,
			"status_bar_visible": true,
			"template_settings":
			{
			},
			"window_id": 38,
			"workspace_name": "/D/workspace/U22_6IN1/U22_6IN1.sublime-workspace"
		}
	],
	"workspaces":
	{
		"recent_workspaces":
		[
			"/D/workspace/U22_6IN1/U22_6IN1.sublime-workspace",
			"/D/workspace/Distribution_Network/distribution_network.sublime-workspace",
			"/D/workspace/U21/U21.sublime-workspace",
			"/D/workspace/U21_6IN1/U21_6t1.sublime-workspace",
			"/D/workspace/U22/U22.sublime-workspace",
			"/D/workspace/BSPU21/BSP.sublime-workspace",
			"/D/workspace/U21_4t1/U21_4t1.sublime-workspace",
			"/D/workspace/4U/4U.sublime-workspace",
			"/E/apprentice/eclipse/algorithm.sublime-workspace"
		]
	}
}
